<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql事务</title>
      <link href="/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql锁</title>
      <link href="/2020/11/09/Mysql%E9%94%81/"/>
      <url>/2020/11/09/Mysql%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>InnoDB存储引擎锁的实现提供了一致性的非锁定读、行级锁支持。行级锁没有相关的额外开销，并可以同时得到并发性和一致性。</p><h2 id="LOCK与LATCH"><a href="#LOCK与LATCH" class="headerlink" title="LOCK与LATCH"></a>LOCK与LATCH</h2><h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><p>轻量级的锁，因为其要求锁定的时间必须非常短，如果持续的时间长，则应用的性能会非常差。InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁），目的就是用来保证并发线程操作临界资源的正确性，通常没有死锁检测机制。</p><h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><p>Lock对象是事务，用来锁定数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放（不同的隔离级别释放时间不同）。lock有死锁机制。</p><p><img src="/2020/11/09/Mysql%E9%94%81/lock_latch.jpg" alt="lock &amp; latch"></p><h3 id="Latch-信息查看"><a href="#Latch-信息查看" class="headerlink" title="Latch 信息查看"></a>Latch 信息查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb mutex;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>mutext被请求的次数</td></tr><tr><td>spin_waits</td><td>spin lock 的次数，InnoDB存储引擎latch在不能获得锁时首先进行自旋，若自旋后还不能获得，则进入等待</td></tr><tr><td>spin_rounds</td><td>自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin_rounds/spin_waits 表示平均每次自旋所需要的内部循环次数</td></tr><tr><td>os_waits</td><td>操作系统等待的次数，当spinlock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒</td></tr><tr><td>os_yields</td><td>进行os_thread_yield唤醒操作的次数</td></tr><tr><td>os_wait_times</td><td>操作系统等待的时间，单位ms</td></tr></tbody></table><h3 id="Lock信息查看"><a href="#Lock信息查看" class="headerlink" title="Lock信息查看"></a>Lock信息查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line">information_schema 下 innodb_trx、innodb_locks、innodb_lock_waits</span><br></pre></td></tr></table></figure><h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li>共享锁 S Lock, 允许事务读一行数据</li><li>排他锁 X Lock, 允许事务删除或者更新一行数据。</li></ul><p>InnoDB存储引擎支持多力度锁定，允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，Mysql支持意向锁。</p><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读是InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。<br>如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会u因此去等待行上锁的释放，InnoDB存储引擎会读取行的一个快照数据。快照数据是改行之前的版本数据，通过undo段来完成，undo用来在事务中回滚数据，一次快照数据本身没有额外开销。读取快照数据本身没有额外开销，也不需要上锁。</p><p>一个行记录可能有多个快照数据，由此来来的并发控制称为多版本并发控制。<br>在事务隔离级别为READCOMMITED和REPEATABLEREAD下， InnoDB存储引擎使用非锁定一致性读。但是对于快照的定义不同。</p><p>在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。<br>在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p><h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... for update</span><br><span class="line">select ... lock in share mode</span><br></pre></td></tr></table></figure><h3 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h3><p>InnoDB自增长ID的锁机制称为Auto-Inc Locking, 为了提高插入的性能，在完成对自增长值插入的SQL语句后立即释放，而不需要等到事务提交。必须等待前一个插入完成，并且对Inser。。Select的大户巨量的插入会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>轻量级互斥量的自增长实现机制，大大提高了自增长值插入的性能。通过innodb_autoinc_lock_mode来控制自增长的模式。默认值为1.</p><ul><li>insert-like : 所有的插入语句，insert/replace/insert-select, replace-select, load data.</li><li>simple-inserts: 插入之前就确定插入行数的语句，如insert/replace。</li><li>bulk inserts: 插入前不能确定得到插入行数的语句。</li><li>mixed-mode inserts: 插入中有一部分的数据是自增长的， 一部分是确定的。</li></ul><p>innodb_autoinc_lock_mode: 0, auto-inc locking 的方式，<br>innodb_autoinc_lock_mode: 1, 默认值，<br>                  对于imple inserts, 该值会用互斥量去对内存中的计数器进行累加操作，<br>                  对于bulk inserts,使用auto-inc locking 方式，不考虑回滚操作时，对于自增值列的增长是连续的，statement-based方式的replication可以很好的工作。<br>innodb_autoinc_lock_mode: 2, 所有的insert-like自增长的值产生的都是通过互斥量。性能最高。出现的问题是增长的值不连续， 基于statement-based replication 会出现问题。所以在使用当前模式时，任何时候都应该使用 row-based replalication, 这样才能保证最大的并发性能以及replication主从数据的一致。</p><p>MyISAM自增主键是表锁设计，自增长不用考虑并发插入的问题， 因此在Master傻姑娘使用InnoDB存储引擎，slave上使用MyISAM存储引擎的replication架构下用户必须考虑这种问题。？？？</p><h3 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h3><p>InnoDB引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其家一个索引，这样就可以避免表锁。</p><p>对于外键值的插入或者更新，首先要查询父表中的记录，如果以一致性非锁定读的方式读取，会发生数据不一致的问题，此时需要对父表加一个S锁。如果这时父表已经有一个X锁，则子表的操作会被阻塞。</p><h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><h3 id="行锁的三种算法"><a href="#行锁的三种算法" class="headerlink" title="行锁的三种算法"></a>行锁的三种算法</h3><ul><li>Record Lock: 单行记录上锁，总是会去锁定索引记录，如果InnoDB存储引擎在建立的时候没有设置任何一个索引，那么InnoDB存储引擎会使用隐式的主键来进行锁定。</li><li>Gap Lock: 锁定一个范围，不包含记录本身,为了阻止多个事务将记录插入到同一个范围内。但是又导致Phantom Problem（幻读）问题的产生。</li><li>Next-Key Lock: Gap Lock + Record Lock, 锁定一个范围，并锁定记录本身， 解决了Phantom Problem。</li></ul><p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock锁住索引本身而不是范围。</p><p>对于辅助所用，加上的是Next-keyLock， 锁定的是范围，并且还会对下一个键值加上Gap Lock.</p><p>显示关闭gap_lock后，除了外键约束和唯一性检查依然需要GapLock，其余情况仅需要使用RecordLock进行锁定。</p><ul><li>将事务的隔离级别设置为READ COMMITTED</li><li>设置innodb_locks_unsafe_for_binlog=1</li></ul><h3 id="解决Phantom-Problem"><a href="#解决Phantom-Problem" class="headerlink" title="解决Phantom Problem"></a>解决Phantom Problem</h3><p>默认的可重复读的事务隔离级别下，InnoDB存储引擎采用Next-Key Locking机制来避免幻读。<br>在ReadCommited模式下，仅采用RecordLock来加锁。</p><h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过所及之可以实现事务的隔离性要求，使得事务可以并发地工作。<br>脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交的数据。</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>在不同的事务下，当前事务可以读到另外事务未提交的数据（脏数据）。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务内，多次读取同一数据集合，由于当前事务看到了另外的事务提交的数据，两次返回的数据是不一样的。<br>InnoDB存储引擎中，使用Next-Key Lock算法来避免不可重复读的问题（不可重复读也叫幻读）。</p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>一个事务的更新操作会被另一个事务的更新成操作覆盖。 </p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>因为不同锁止键的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁匙放它所占用的资源，就是阻塞，阻塞时为了确保事务可以并发且正常地运行。</p><p>innodb_lock_wait_timeout: 等待超时时间<br>innodb_rollback_on_timeout: 等待超时时是否对进行中的事务进行回滚。默认为OFF，默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@innodb_lock_wait_timeout&#x3D;60;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>两个或者两情歌以上的事务在执行过程中，因为争夺锁资源而造成相互等待的现象。</p><h4 id="超时解决"><a href="#超时解决" class="headerlink" title="超时解决"></a>超时解决</h4><p>解决思索最简单的方式是不要有等待，将任何的等待都化为回滚，并且事务重新开始。<br>如果超时的事务更新了很多行，占用了较多的undo log会导致回滚性能差。</p><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>采用 wait-for graph（等待图）的方式进行死锁检测。要求数据库保存两种信息，通过这两种信息构造一张图，如果图中有回路，就代表存在死锁，从而选择回滚undo量最小的事务。</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁升级是指将所得粒度降低。InnoDB存储引擎不存在锁升级的问题。因为不是根据每个记录来产生行锁，而是根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。因此不管是一个事务锁住页中一个记录还是多个记录，开销通常是一样。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2020/11/06/ThreadLocal/"/>
      <url>/2020/11/06/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> ThreadLocal 是JDK包提供的，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的副本，在实际多线程操作的时候，操作的都是自己本地内存中的变量，从而规避了线程安全问题。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadLocal tl = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">tl.set(k);</span><br><span class="line">tl.get();</span><br><span class="line">tl.remove();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Thread 类中有两个变量，一个threadLocals， 一个inheritableThreadLocals。</p><h2 id="不支持继承性"><a href="#不支持继承性" class="headerlink" title="不支持继承性"></a>不支持继承性</h2><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/2020/11/06/Mysql%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/11/06/Mysql%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB存储引擎索引"><a href="#InnoDB存储引擎索引" class="headerlink" title="InnoDB存储引擎索引"></a>InnoDB存储引擎索引</h2><p>InnoDB支持B+树索引、全文索引和哈希索引。</p><p>B+树索引就是传统意义上的索引，是目前关系型数据库中查找最为常用和最为有效的索引。<br>InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为敢于是否在一张表中生成哈希索引。</p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>也叫折半查找，必须是一组有序的记录数组。具体详见《二分查找法》。</p><h3 id="二叉查找树与平衡二叉树"><a href="#二叉查找树与平衡二叉树" class="headerlink" title="二叉查找树与平衡二叉树"></a>二叉查找树与平衡二叉树</h3><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</p><p>前序遍历：根 -&gt; 左 -&gt; 右<br>中序遍历: 左 -&gt; 根 -&gt; 右<br>后序遍历: 左 -&gt; 右 -&gt; 根</p><p>当一个二叉查找树的每个结点只有左子树或者只有右子树时，该数据结构退化成了链表，查找性能会变低，时间复杂度变成O(n).</p><p>平衡二叉树：在二叉树的基础上，必须满足任何结点的两个子树高度最大差1. 平衡二叉树的查询速度极快，但是维护一颗平衡二叉树的代价非常大。 需要经过1次或者多次左旋和右旋来得到插入或者更新后的平衡树。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树由B树和索引顺序访问方法演化而来，为磁盘或者其他直接存取辅助设备设计的一种平衡查找树。<br>在B+树中，所有记录结点都是按照键值的大小顺序存放在同一层的叶子结点上，由各个叶子结点指针进行连接。</p><h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>B+树的插入必须保证插入后叶子结点中的记录依然排序，同时要考虑插入到B+树的三种情况，每种情况都可能会导致不同的插入算法。</p><p>1）叶子页未满，索引页未满：直接将记录插入到叶子结点。<br>2）叶子页已满，索引页未满：<br>   2.1）拆分LeafPage<br>   2.2) 将中间的结点放入到IndexPage中<br>   2.3）小于中间结点的记录放在左边<br>   2.4) 大于或者等于中间结点的记录放在右边<br>3）叶子页已满，索引页已满：<br>   3.1）拆分LeafPage<br>   3.2) 小于中间结点的记录放左边<br>   3.3) 大于或者等于中间结点的记录放右边<br>   3.4) 拆分索引页IndexPage<br>   4.5) 小于中间结点的记录放左边<br>   4.6) 大于中间结点的记录放右边<br>   4.7) 中间结点放入上一层IndexPage</p><p>无论如何变化，B+树总会保持平衡。但是为了保持平衡对于新插入的键值可能需要做大量的拆分页操作。<br>因为B+树结构主要用于磁盘，页的拆分意味着磁盘的额操作，所以在可能的情况下尽量减少页的拆分。<br>B+树提供了类似于平衡二叉树的旋转功能。<br>旋转发生在LeafPage已满，但是其左右兄弟结点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录转移到所在页的兄弟结点上。在通常情况下，左兄弟回被首先检查用来做旋转操作。</p><h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>B+树删除时根据填充因子的变化来衡量（最小填充因子的值为50%）。<br>删除操作同样必须保证删除后叶子结点中的记录已俨然排序。</p><p>叶子结点大于填充因子， 中间结点大于填充因子：直接将记录从叶子结点删除，如果该结点还是IndexPage的结点，用该结点的右结点代替。<br>叶子结点小于填充因子，中间结点大于填充因子：合并叶子结点和它的兄弟结点，同时更新IndexPage<br>叶子结点小于填充因子，中间结点小于填充因子：合并叶子结点和它的兄弟结点，更新IndexPage，合并IndexPage和它的兄弟结点。</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>按照每张表的主键构造一颗B+树，同时叶子结点中存放的是张张表的行记录数据，聚集索引的叶子结点称为数据页。<br>由于实际的树叶也只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。大多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子结点上直接找到数据。此外定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围的查询。</p><p>数据页存放的是完整的每行的数据，索引页存放的是键值和指向数据页的偏移量Offset。<br>聚集索引是按照主键逻辑顺序在磁盘存储。</p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>对于辅助索引，叶子结点除了包含键值意外，每个结点中的索引行中包含了聚集索引键。<br>每张表中可以有多个辅助索引，当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历并通过叶子级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><h3 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h3><p>InnoDB存储引擎的PageHeader中包含了Page_Last_Insert、Page_Direction、Page_N_Direction，通过这几个参数来决定向左分裂或者向右分裂。</p><p>如果插入是随机的，则取页的中间记录作为分裂点的记录。<br>如果向同一方向进行插入的记录数量是5，并且目前已经定位到的记录之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是待插入的记录。</p><h3 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h3><p>只对表中b字段的前100个字符创建索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t  add key idx_b(b(100));</span><br></pre></td></tr></table></figure><p>查看t表中的所有索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>在非高峰时期执行以下语句，更新索引Cardinality信息，使得优化器和索引可以更好的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p>生产环境创建索引时遇到的问题：</p><h4 id="临时表方式创建索引"><a href="#临时表方式创建索引" class="headerlink" title="临时表方式创建索引"></a>临时表方式创建索引</h4><p>先创建临时表，导入数据，创建索引然后修改临时表名称。</p><h4 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h4><p>FIC在辅助索引创建的过程中对表加了S锁，因此在创建的过程中之能对该表进行读操作，如果有大量的食物需要对目标表进行写操作，那么数据库的服务同样不可用。<br>FIC方式只限于辅助索引，对于主键的创建和删除需要重建一张表。</p><h4 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h4><p>PHP脚本维护，且在进行OSC过程中，允许SET sql_bin_log=0， 因此所做的操作不会同步到slave服务器，可能导致主从不一致的情况。</p><h4 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h4><p>允许辅助索引创建的同时，还允许Insert、UPdate、Delete等DML操作，极大地提高了Mysql数据库在生产环境的可用性。<br>还可以在线的操作以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">辅助索引的创建与删除</span><br><span class="line">改变自增长值</span><br><span class="line">添加或者删除外键约束</span><br><span class="line">列的重命名</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name algorithm=&#123;<span class="keyword">default</span>|INPLACE|COPY&#125;</span><br><span class="line"><span class="keyword">lock</span>=&#123;<span class="keyword">default</span>|<span class="keyword">none</span>|<span class="keyword">shared</span>|exclusive&#125;</span><br></pre></td></tr></table></figure><p>algorithm:<br>  copy: 临时表方式创建索引<br>  inplace:不需要创建临时表（默认）<br>  default:根据参数old_alter_table判断通过copy或者inplace算法。<br>lock: 创建索引或者删除索引时对表解锁的情况。<br>   none: 不加锁，任意读写操作都不会收到阻塞。<br>   share: 与FIC类似，执行索引创建或者删除操作时，对目标加S锁。可以并发读，阻塞写事务。<br>   exclusive：执行索引创建或者删除时，对表增加一个X锁，阻塞所有的读写事务。<br>   default：通过判断事物的最大并发性来判断执行DDL模式。none -&gt; share-&gt; exclusive.</p><p>远离：在执行创建或者删除操作时，将INsert、UPDATE、DELETE等DML操作日志写入缓冲中，等待索引创建完成后，再将重做应用到表上，达到数据一致性。因此索引在创建过程中SQL优化器不会选择正在创建中的索引。<br>缓存大小由innodb_online_alter_log_max_size=128MB控制。</p><h2 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h2><p>表示索引中不重复记录数量的预估值。InnoDB根据Cardinality来决定是否使用该索引。<br>Cardinality的值是通过采样的方法来完成的。</p><p>当insert、update的数据占有表中数据的1/16时。<br>每一行的更新次数：stat_modified_counter &gt; 2 000 000 000时<br>就会更新Cardinality值。</p><p>当执行以下命令时会导致InnoDB存储引擎重新计算Cardinality值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">analyze table</span><br><span class="line">show table status</span><br><span class="line">show index</span><br><span class="line">访问information_schema 下的表tables和表statistics</span><br></pre></td></tr></table></figure><h2 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h2><h3 id="不同应用中B-树索引的使用"><a href="#不同应用中B-树索引的使用" class="headerlink" title="不同应用中B+树索引的使用"></a>不同应用中B+树索引的使用</h3><p>OLTP应用和OLAP应用中索引的使用。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>从辅助索引就可以查询到想要的数据，而不需要再查一次聚集索引中的记录。</p><h3 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h3><p>当优化器发现辅助索引不能进行索引覆盖时，并且查找的数据量比较大时会放弃辅助索引，转向全表扫描。</p><p>使用force index();</p><h3 id="Multi-range-Read优化"><a href="#Multi-range-Read优化" class="headerlink" title="Multi-range Read优化"></a>Multi-range Read优化</h3><p>为了减少磁盘的随机访问，并且将随机访问转化为较顺序的数据访问。</p><p>MRR的好处：</p><ul><li>MRR 使得数据访问变得较为顺序，在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。</li><li>减少缓冲池中页被替换的次数</li><li>批量处理对键值的查询操作</li></ul><p>对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR的工作方式如下：</p><ul><li>将查询得到的辅助索引键值存放在一个缓存中，这时缓存中的数据时根据辅助索引键值排序的。</li><li>将缓存中的键值根据rowID进行排序</li><li>根据rowID的排序顺序来访问实际的数据文件。</li></ul><p>如果InnoDB或者MyISAM存储引擎的缓冲池不是足够大，不能存放下一张表中的所有数据，此时频繁的离散读操作还是会导致缓存中的页被替换出缓冲池，然后又不断地被读入缓冲池。如果按照住建顺序进行访问，就可以将重复行为降到最低。<br>可以通过optimizer_swith中的flag来控制，当mrr为on时表示启用mrr优化。<br>mrr_cost_based标记表示是否通过cost_based方式选择是否启用mrr。<br>如果mrr = 0n , mrr_cost_based=off ,  表示总启用mrr。</p><p>SET @@optimizer_switch=’mrr=on,mrr_cost_based=off’;</p><h3 id="IndexConditionPushDown优化"><a href="#IndexConditionPushDown优化" class="headerlink" title="IndexConditionPushDown优化"></a>IndexConditionPushDown优化</h3><p>IndexConditionPushDown 会在读取索引的同时，判断是否可以进行WHERE条件的过滤从而提升性能。</p><h2 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><h3 id="InnoDB存储引擎中的哈希算法"><a href="#InnoDB存储引擎中的哈希算法" class="headerlink" title="InnoDB存储引擎中的哈希算法"></a>InnoDB存储引擎中的哈希算法</h3><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><h3 id="InnoDB全文索引"><a href="#InnoDB全文索引" class="headerlink" title="InnoDB全文索引"></a>InnoDB全文索引</h3><h3 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h3>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql表</title>
      <link href="/2020/11/05/Mysql%E8%A1%A8/"/>
      <url>/2020/11/05/Mysql%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB存储索引中，表时根据主键顺序组织存放的，这种存储方式的表称为索引组织表。</p><p>在InnoDB存储引擎表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则会按照如下方式创建主键：</p><ul><li>判断表中是否有非空的唯一索引，如果有该列为主键；</li><li>表中没有非空的唯一索引，InnoDB引擎自动创建一个6字节大小的指针；<br>当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键（根据定义的索引顺序，而不是建表时列的顺序）。</li></ul><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。<br>表空间由段（Segment）、区（extent）、页（Page）组成。<br><img src="/2020/11/05/Mysql%E8%A1%A8/table_space_struct.jpg" alt="表空间结构"></p><p>在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1，所有的数据都存放在这个表空间内。<br>如果配置了innodb_file_per_table，则每张表内的数据可以单独存放在一个表空间中。此时每张表的表空间存放的只是数据、索引和插入缓冲的BitMap页，其他类的数据如回滚（undo）、插入缓冲索引页、系统事务信息、二次写缓冲等还是存放在原来的共享表空间。</p><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间是由各个段组成的，包含数据段、索引段、回滚段等。<br>数据段就是B+树的叶子节点，索引段就是B+树的非叶子结点。<br>回滚段？？？<br>在InnoDB存储引擎中，对段的管理都是由引擎自身完成的，DBA不能对其进行控制。</p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续的页组成的空间，在任何情况下每个区的大小都是1MB。为了保证区中页的连续行，InnoDB引擎每次从磁盘申请4～5个区。默认情况下InnoDB存储引擎页的大小为16K，一个区中存放64个连续的页。</p><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中，默认每个页的大小为16KB。<br>可以通过参数 innodb_page_size 来设置页的大小为4K、8K、16K。<br>如果设置完成，则所有表中的页大小都变成innodb_page_size，不可用对其再次进行修改。除非通过mysqldump导入和导出来生成新的库。</p><p>页的类型有：</p><ul><li>数据页（B-Tree Node）</li><li>undo 页（undo log Page）</li><li>系统页（System Page）</li><li>事务数据页（Transaction System Page）</li><li>插入缓冲位图页（Insert Buffer BitMap）</li><li>插入缓冲空闲列表页（Insert Buffer Free List）</li><li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li><li>压缩的二进制大对象页（Compressed BLOB Page）</li></ul><h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>Innodb存储引擎按行进行存放，每个页存放的行记录有影星的定义，最多允许存放16KB/2 - 200 行的记录。</p><h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><h4 id="Compact-行记录格式"><a href="#Compact-行记录格式" class="headerlink" title="Compact 行记录格式"></a>Compact 行记录格式</h4><p>从Mysql5.0开始，设计目的是高效地存储数据。一个页中存放的行数据越多，其性能就越高。</p><p>|—|—|—|—|—|—|—|—|—|<br>| 变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列 2 数据 | …|事务ID列|回滚指针列|__rowid|</p><p>变长字段长度列表：按照列的顺序，逆序放置。<br>  如果列的长度小于255个字节，占用1字节；<br>  如果列的长度大于255个字节，占用2字节；<br>  变长字段的长度最大不可以超过2个字节，因为Mysql数据库中VARCHAR类型的最大长度限制为65535.<br>NULL标志位：表示改行数据中是否有NULL值，有用1表示，占用1个字节。<br>记录头信息：固定占用5个字节。<br>最后的部分是实际存储没咧的数据。<br>事务ID列：隐藏列，占用6字节。<br>回滚指针列:隐藏列，占用7字节。<br>__rowid：占用6字节。</p><h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnoDB存储引擎的数据都是存放在页类型为B-tree Node中，当发生行溢出是，数据存放在页类型为uncompress BLOG页中。</p><h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><h3 id="Named-File-Formats-机制"><a href="#Named-File-Formats-机制" class="headerlink" title="Named File Formats 机制"></a>Named File Formats 机制</h3><p>###约束</p><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>分区功能不是在存储引擎层面完成的。<br>支持分区的存储引擎有：MyISAM、InnoDB、NDB。<br>不支持分区的存储引擎有：CSV、FEDORATED、MERGE。</p><p>分区的过程是将一个表或者索引分解为多个更小的、更可管理的部分。<br>从逻辑上讲只有一个表或者一个索引库，但是在物理上这个表或者索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，页可以作为一个更大的对象的一部分进行处理。</p><p>Mysql支持水平分区，不支持垂直分区（水平分区，将同一表中的不同行的记录分配到不同的物理文件；垂直分区，将同一表中的不同列分配到不同的物理文件）。<br>Mysql不支持全局分区，只支持局部分区。<br>局部分区：一个分区中既存放了数据由存放了索引。<br>全局分区：数据存放在各个区，所有数据的索引存放在一个对象中。</p><p>分区主要用来数据库高可用性的管理，对于某些SQL的性能带来提高。</p><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><ul><li>RANGE分区:行数据基于属于一个给定连续区间的列值被放入分区。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t (</span><br><span class="line">  id int</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by range(id)(</span><br><span class="line"> partition p0 values less than (10),</span><br><span class="line"> partition p1 values less than (20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add partition (partition p2 values less than maxvalue);</span><br></pre></td></tr></table></figure><p>启用分区后，表是由建立各个分区时的各个分区ibd文件组成。</p><ul><li>List分区：和RANGE分区类似，只是LIST分区面向的是离散的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">   a INT, </span><br><span class="line">   b INT</span><br><span class="line">) engine &#x3D; INNODB</span><br><span class="line">partition by list(b)(</span><br><span class="line">  partition p0 values in (1,3,5,7,9),</span><br><span class="line">  partition p1 values in (0,2,4,6,8)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>HASH分区：根据用户自定义的表达式返回值进行分区，返回值不能为负数。<br>Hash分区的目的是将数据均匀地分布到盂县定义的各个区中，保证各分区的数据数量大致都一样。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">  a int, </span><br><span class="line">  b datetime</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by hash(year(b))</span><br><span class="line">partitions 4;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">  a int,</span><br><span class="line">  b datetime</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by linear hash(year(b))</span><br><span class="line">prtions 4;</span><br></pre></td></tr></table></figure><p>LINEAR HASH分区的优点在于，增加、删除、合并和拆分分区将变得更加快捷，有利于处理含有大量数据的表。<br>缺点在于，与使用HASH分区得到的数据分布相比，各个分区间数据的分布可能不大均衡。</p><ul><li>KEY分区：根据MYSQL数据库提供的哈希函数来分区。<br>与HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用MYSQL数据库提供的函数进行分区。对于NDB Cluster引擎，MYSQL数据库使用MD5函数来分区；对于其他引擎，Mysql数据库使用内部的哈希函数。<br>在KEY分区中，使用关键字LINEAR 和在HASH分区中具有同样的效果。</li></ul><p>无论哪种类型的分区，如果表中存在主键或者唯一索引时，分区列必须时唯一索引的一个组成部分。<br>如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p><p>以上四种RANGE、LIST、HASH、KEY分区条件是，数据必须是整形，如果不是整型，那应该需要通过函数将其转化成整型，如YEAR（）, TO_DAYS(), MONTH()等函数。</p><ul><li>Column分区，RANGE分区和LIST分区的一种进化。<br>COLUMN分区可以直接使用菲整形的数据进行分区，分区根据类型直接比较得到，不需要转化为整形。<br>RANGECOLUMNS分区可以对多个列的值进行分区。</li></ul><p>COLUMN分区支持<br>所有的整型：INT、SMALLINT、TINYINT、BIGING。<br>日期类型：DATE、DATETIME<br>字符串类型：CHAR、VARCHAR、BINARY、VARBINARY。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">  a INT,</span><br><span class="line">  b DATETIME</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by range columns(b)(</span><br><span class="line">  partition p0 values less than (&#39;2020-01-01&#39;),</span><br><span class="line">  partition p1 values less than (&#39;2020-02-01&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h4><p>   子分区是在分区的基础上再进行分区，有时页称为符合分区。 MySQL允许在RANGE和LIST的分区傻姑娘再进行KEY或者HASH的子分区。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">   a int,</span><br><span class="line">   b date</span><br><span class="line"> )engine &#x3D; innodb</span><br><span class="line"> partition by range(year(b))</span><br><span class="line"> subpartition by hash(to_days(b))</span><br><span class="line"> subpartitions 2(</span><br><span class="line">     partition p0 values less than (1990),</span><br><span class="line">     partition p1 values less than (2000),</span><br><span class="line">     partition p2 values less than maxvalue</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><h4 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h4><p>MysQL允许对NULL值做分区，对于RANGE分区，如果像分区列插入了NULL值，则Mysql数据库将该值放入到最左边的分区。<br>LIST分区下要使用NULL值，必须显式地指出将该值放入哪个分区。<br>HASH和KEY分区函数会将NULL值的记录返回0.</p><h4 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h4><p>当数据量大时，分区可以有效降低B+树的层级。<br>当数据量小时，分区带来的收益并不明显，并且有可能导致扫描所有分区反而降低效率。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 文件</title>
      <link href="/2020/11/04/%E6%96%87%E4%BB%B6/"/>
      <url>/2020/11/04/%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>  动态参数可以在Mysql实例运行中进行更改，可以通过SET命令对动态参数值进行修改。<br>  SET [global|session]  key = value;</p><h3 id="静态参数"><a href="#静态参数" class="headerlink" title="静态参数"></a>静态参数</h3><p>  静态参数在整个实例生命周期内不得进行更改，需要重新启动实例才会生效。</p><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了对Mysql的启动、运行、关闭过程中所有的错误、警告和正确的信息。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>可以帮助定位可能存在问题的SQL语句，从而进行SQL层面的优化。Mysql在启动时设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。<br>通过设置 long_query_time 来设置，单位为秒。<br>log_queries_not_using_indexes: 记录没有使用索引的查询日志。<br>log_throttle_queries_not_using_indexes:每分钟允许记录到showLog的且未使用索引的SQL语句次数，0表示不限制。</p><p>查看慢日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow *.log</span><br><span class="line">&#x2F;&#x2F;查看执行时间最长的10条sql语句</span><br><span class="line">mysqldumpslow -s al -n 10 *.log</span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。</p><p>查看查询日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail *.log</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类对数据本身没有修改的操作。二进制日志还包括了执行数据库更改操作的时间等其他额外信息。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>恢复<br>某些数据的恢复需要二进制日志，如在一个数据库全备文件恢复后，用户可以通过二进制日志进行pint-in-time的恢复。</li><li>复制<br>与恢复类似，通过复制和执行二进制日志使另一台远程的MySQL数据库与当前数据库进行实时同步。</li><li>审计<br>通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li>max_binlog_size: 单个日志文件的最大值，默认1G</li><li>binlog_cache_size: 所有未提交的二进制日志会被记录到一个缓存中，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，该缓冲的大小默认为32。该值是基于会话的，每个会话会申请32K的空间。</li><li>binlog_cache_use: 记录了使用临时文件写二进制日志的次数。</li><li>sync_binlog：表示每写缓冲多少次就同步到磁盘，为1时，表示采用同步写磁盘的方式来写二进制日志，这时写操作不使用操作系统的缓冲来写二进制日志。默认值为0.</li><li>binlog-do-db：写入哪些库的日志，默认为空表示同步所有库的日志到二进制日志。</li><li>binlog-ignore-db：忽略哪些库的日志</li><li>log-slave-update：当前库为slave时，如果需要将从master取得并执行的二进制日志写入自己的二进制日志文件中时需要设置该值。</li><li>binlog_format：STATEMENT/ROW/MIXED<br>STATEMENT：格式基于SQL语句，如果主服务器运行rand、uuid等函数或者触发器等操作时，就会导致主从服务器上表中的数据库表中的数据库不一致。<br>ROW：二进制的日志，记录了表的更改情况，解决了Statement下复制的问题。可以设置InnoDB的事务隔离设置为READ_COMMITTED，以获得更好的并发性。<br>MIXED：默认采用STATEMENT，但是在特殊情况下会转为ROW。</li></ul><h2 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h2><p>名为mysql.sock,可以通过Unix域套接字方式进行与本地MySQL进行连接。套接字文件由参数socket控制。</p><h2 id="PID文件"><a href="#PID文件" class="headerlink" title="PID文件"></a>PID文件</h2><p>MySQL实例启动时，会将自己的进程ID写入一个文件中，该文件为PID文件。</p><h2 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h2><p>因为MySQL插件式存储引擎的体系结构关系，MySQL数据的存储是根据表进行的，每个表都会有与之对应的文件。但不论表采用哪种存储引擎，MySQL都有一个以frm为后缀名的文件，记录了这个表结构或者视图的定义。</p><h2 id="Innodb存储引擎文件"><a href="#Innodb存储引擎文件" class="headerlink" title="Innodb存储引擎文件"></a>Innodb存储引擎文件</h2><h3 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h3><p>InnoDB采用将存储的数据按照表空间进行存放的设计。默认配置喜爱会有一个初始大小为10MB，名为ibdata1的默认表空间文件。</p><p>将ibdata1,ibdata2两个文件用来组成表空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path&#x3D;&#x2F;db&#x2F;ibdata1:2000M;&#x2F;dr2&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure><p>如果该两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。<br>设置innodb_data_file_path后，所有给予innoDB存储引擎的表的数据都会记录带该共享表空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_file_per_table&#x3D;ON &#x2F;&#x2F;每个基于InnoDB存储引擎的表产生一个独立表空间。命名规则是：表名.ibd</span><br></pre></td></tr></table></figure><p>单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还存放在默认的表空间中。</p><p><img src="/2020/11/04/%E6%96%87%E4%BB%B6/table_space.jpg" alt="表空间"></p><h3 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h3><p>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。<br>他们记录了对于InnoDB存储引擎的事务日志。</p><p>重做日志用于由于主机宕机导致实例失败时，恢复到失败前的状态，一次来保证数据的完整性。</p><p>每个InnoDB存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志文件。为了得到更高的可靠性，用户可以设置多个的景象日志组。将不同的组存放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。<br>InnoDB存储引擎献血重做日志文件1，当达到文件的最后时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_file_size:每个重做日志文件的大小</span><br><span class="line">innodb_log_files_in_group: 日志文件组中重做日志文件的数量，默认为2</span><br><span class="line">innodb_mirrored_log_groups: 日志镜像文件组的数量，默认为1，表示没有镜像。</span><br><span class="line">innodb_log_group_home_dir: 日志文件组所在的路径，默认为.&#x2F;</span><br></pre></td></tr></table></figure><p>重做日志文件的大小对InnoDB存储性能有非常大的影响。<br>如果设置太大，在恢复时可能需要很长的时间。<br>如果设置太小，会导致一个事务的日志需要多次切换重做日志文件。同时会导致频繁地发生 async checkpoint， 导致性能抖动。</p><h4 id="二进制文件与重做日志"><a href="#二进制文件与重做日志" class="headerlink" title="二进制文件与重做日志"></a>二进制文件与重做日志</h4><p>层次不同：<br>二进制日志：记录所有与MySQL数据库有关的日志记录，包括InnoDB，MyISAM，Heap等其他存储引擎的日志。<br>重做日志：值记录InnoDB存储引擎本身的事务日志。</p><p>内容不同：<br>二进制日志文件记录的是一个事务的具体操作内容，为逻辑日志。<br>重做日志记录的是关于每个页的更改的物理情况。</p><p>写入时间不同：<br>二进制文件仅在事务提交前进行，无论事务大小，只写磁盘一次。<br>在事务进行的过程后再难过，不断有重做日志条目被写入到重做日志文件中。</p><h4 id="重做日志条目结构"><a href="#重做日志条目结构" class="headerlink" title="重做日志条目结构"></a>重做日志条目结构</h4><p>redo_log_type | space | page_no | redo_log_body<br>redo_log_type ： 占用1字节，表示重做日志的类型<br>space： 表示表空间的ID，采用压缩的方式，占用空间可能小于4字节<br>page_no：表示页的偏移量，压缩方式<br>redo_log_body:每个重做日志的数据部分，恢复时需要调用相应函数解析。</p><h4 id="重做日志写入"><a href="#重做日志写入" class="headerlink" title="重做日志写入"></a>重做日志写入</h4><p>重做日志的写入不是直接写，而是先写入重做日志缓冲（redo log buffer）中，然后按照一定的条件顺序地写入日志文件。</p><p>从重做日志缓冲网磁盘写入时，按照写入的最小单位（扇区大小：512个字节）进行写入，因此可以保证写入必定是成功的，因此在重做日志的写入过程不需要有doublewrite。</p><p>写入时机：<br>1） 不论事务已经提交，主线程每秒都会将重做日志缓冲写入到磁盘的重做日志文件中。<br>2） 事务提交时，设置了innodb_flush_log_at_trx_commit。<br>    值为0时，不将事物的重做日志写入磁盘上的日志文件，<br>    1表示在执行commit时将重做日志缓冲同步写到磁盘，<br>    2表示将重做日志异步写到磁盘（也就是写到文件系统的缓存中）</p><p>因此，为了保证ACID中的D（持久性），必须将innodb_flush_log_at_trx_commit设置为1，当数据库因为意外宕机时，可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB体系架构</title>
      <link href="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB-体系架构"><a href="#InnoDB-体系架构" class="headerlink" title="InnoDB 体系架构"></a>InnoDB 体系架构</h2><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。<br>包括脏页的刷新、合并插入缓冲、UNDO页的会后等。</p><h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>InnoDB中使用了AIO（AsyncIO）来处理写IO请求，提高了数据库性能。<br>IO线程的工作主要是负责AIO的回调处理。</p><p>可以使用innodb_read_io_threads和innodb_write_io_threads进行设置。</p><h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>事务被提交后，其所用的undolog可能不再需要，因此需要Perge Thread来回收已经使用并分配的undo页。<br>可以使用 innodb_purge_thread 来设置线程数量。</p><h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>为了减轻MasterThread的工作，以及用户查询线程的阻塞提升性能。<br>将之前版本中脏页的舒心操作都放入到单独的线程中完成。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>InnoDB存储引擎是基于磁盘存储的，将其中的记录按照页的方式进行管理。缓冲池就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库的性能影响。</p><p>在数据库中进行读取页的操作，首先从磁盘读取到的页放在缓冲池中，下一次再读取相同的页时，首先判断该页是否在缓冲池中。如果在缓冲池中，则直接读取该页，否则读取磁盘上的页。</p><p>对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。</p><p>页从缓冲池刷新到磁盘上的操作是通过Checkpoint的机制刷新回到磁盘。</p><p>因此缓冲池的大小直接影响着数据库的整体性能。可以使用 innodb_buffer_pool_size 来设置缓冲池大小。</p><p>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自使用哈希索引、InnoDB存储的锁信息、数据字典信息等。</p><p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/buffer_pool.jpeg" alt="缓冲池"></p><p>InnoDB可以有多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中。这样减少了数据库内部的资源竞争，增加了数据库的兵法处理能力。可以使用 innodb_buffer_pool_instances来进行配置。</p><h4 id="缓冲池管理算法"><a href="#缓冲池管理算法" class="headerlink" title="缓冲池管理算法"></a>缓冲池管理算法</h4><h5 id="LRU-List"><a href="#LRU-List" class="headerlink" title="LRU List"></a>LRU List</h5><p>LRU List 用来管理已经读取的页，最频繁使用的页存放在LRU列表的前端，最少使用的页存放在LRU列表的尾端。当缓冲池不能存放新读取到的页时，首先释放LRU列表中尾端的页。</p><p>新读取的页并不直接存放在LRUList列表的前端，而是存放在midPoint的位置。midPoint之后的列表称为Old列表，之前的列表称为New列表，New列表中的页都是活跃的热点数据。</p><p>这是因为，如果新读取的页如果放在最前端时，如果遇到需要访问和扫描大部分甚至全部页的时候，热点页面被刷出缓存，但是非热点数据却存放在了LRU列表的最前端。 </p><p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/mid_point.jpg" alt="MID POINT"></p><p>使用参数：innodb_old_blocks_pct 来控制midPoint的位置。<br>         innodb_old_blocks_times 来控制读取到MidPoint位置后需要等待多久才会被加入到LRU列表的New列表。</p><h5 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h5><p>数据库刚启动的时候，LRUList是空的没有任何页。此时页都存放在FreeList中。当需要从缓冲中分页时，县从Free列表中查找是否有可用的空闲页，如果有可用的空闲页，则将该页从FreeList中删除，存放到LRUList中。如果FreeList中没有可用的空闲页，根据LRU算法，淘汰LRU尾部的页，将该页内存空间分配给新的页。</p><h5 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h5><p>在LRU列表中的页被修改后，该页需要通过CheckPoint机制刷回磁盘。<br>FlushList中的页称为脏页里诶包，脏页既存在于LRUList，也存在于FlushList。<br>LRUList用来管理缓冲池中页的可用性，FlushList用来管理将页刷新回磁盘。</p><h4 id="重做缓冲日志"><a href="#重做缓冲日志" class="headerlink" title="重做缓冲日志"></a>重做缓冲日志</h4><p>InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按照一定的频率（每秒一次）将其刷新到重做日志文件。<br>可以使用参数：innodb_log_buffer_size来调整该缓冲区域的大小，默认为8MB。</p><h4 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h4><p>例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象，这些对象记录了一些如LRU、锁、等待信息，而这个对象的内存需要从额外内存池中申请。</p><p>在对一些数据结构本身的内存进行分配是，需要从额外的内存池中进行申请。因此在申请了很大的InnoDB缓冲池是，需要相应地增加额外的内存池。</p><h2 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h2><p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/check_point.png" alt="CheckPoint"></p><p>Write Pos 是当前记录的位置，一边写好一遍往后移。<br>CheckPoint 是当前要擦除的位置，也就是往后推移并且循环的，擦除记录前要把记录更新到数据文件。<br>Write Pos和 CheckPoint之间是可以写入的部分，用来记录新的操作。</p><p>1） 缩短数据库的恢复时间；<br>    当数据库发生宕机时，数据库不需要重做所有的日志，因为CheckPoint之前的页都已经刷新回磁盘，因此只需要对checkPoint之后的重做日志进行恢复，这样大大缩短了数据库的恢复时间。</p><p>2） 缓冲池不够用时，将脏页刷新到磁盘；<br>    当缓冲池不够用时，根据LRU算法会移除最近最少使用的页，如果当前页为脏页，则需要刷新该脏页到磁盘。</p><p>3） 重做日志不可用时，刷新脏页；<br>    重做日志中Write Pos和checkPint之间没有空间来记录RedoLog时，强制刷新脏页，使得CheckPoint后移。</p><h2 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h2><h3 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h3><h4 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h4><p>对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果存在则直接插入；如果不在则先放入到一个InsertBuffer对象中。然后再以一定的频率进行InsertBuffer和辅助索引页子结点的Merge操作。<br>通常会将多个插入操作合并到一个操作中，大大提高了非聚集索引插入的性能。</p><p>InsertBuffer的使用要同时满足两个条件：<br>1） 索引是辅助索引（非聚集索引）<br>    如果是聚集索引，则直接按照顺序写就行了，很高效。<br>2） 索引不是唯一的<br>    因为在插入缓冲时，数据库并不去查找索引页来判断插入的记录唯一性。如果去查找肯定又会有离散读取的情况发生，从而导致InsertBuffer失去意义。</p><p>当满足索引是辅助索引且非唯一时，InnoDB存储引擎会使用InsertBuffer， 这样就可以提高插入操作的性能。</p><p>当应用程序进行大量的插入操作时数据库发生了宕机，这个时候会有大量的InsertBuffer并没有合并到实际的非聚集索引中，因此恢复可能需要很长的时间。</p><p>同时在写密集的情况下，InsertBuffer会占用过多的缓冲池内存（innodb_buffer_pool），默认最大可以占用1/2的缓冲池内存。修改IBUF_POOL_SIZE_PER_MAX_SIZE 可以对 InsertBuffer大小进行控制，比如改为3则最大只能使用1/3的缓冲池内存。</p><h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p>InsertBuffer 的升级版本，可以对Insert、Delete、Update都进行缓冲，分别是InsertBuffer、DeleteBuffer、PurgeBuffer。</p><p>ChangeBuffer适用对象依然是非唯一的辅助索引。</p><p>对一条记录进行UPDATE操作需要分为：<br>1）将记录标记为删除（DeleteBuffer对应该过程）；<br>2）真正将记录删除（PurgeBuffer对应删除操作）</p><p>开启Buffer选项：<br>innodb_change_buffering: [inserts、deletes、purges、changes、all、none]<br>changes表示启用inserts、deletes<br>all表示启用所有，默认值<br>none表示都不启用。</p><p>可以通过innodb_change_buffer_max_size控制changebuffer最大使用内存的数量：<br>该参数的最大有效值为50， 表示只能占用缓冲池的50%。</p><h4 id="Merge-InsertBuffer"><a href="#Merge-InsertBuffer" class="headerlink" title="Merge InsertBuffer"></a>Merge InsertBuffer</h4><ul><li>辅助索引页被读取到缓冲池时；<br>  执行SELECT语句时，要确认该辅助索引页是否有记录存放于InsertBufferB+树中。<br>  有，则将InsertBufferB+树中该页的记录插入到该辅助索引页中。</li><li>InsertBuffer BitMap 追踪到该辅助索引页已无可用空间时；<br>  InsertBuffer BitMap用来追踪每个辅助索引页的可用空间，并至少有1/32页的可用空间。如果插入辅助索引记录时监测到插入记录后可用空间小雨1/32页，则会强制进行一个合并操作。<br>  （强制读取辅助索引页，将InsertBufferB+树中该页的记录以及待插入的记录插入到辅助索引页中。）</li><li>Master Thread<br> Master Thread 每秒或者每10秒 根据srv_innodb_io_capacity 的百分比来进行一个Merge InsertBuffer操作。</li></ul><p>如果在merge时，要进行的merge表已经被删除，此时直接丢弃已经被Insert/Change Buffer的数据记录。</p><h3 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h3><p>DoubleWrite为了提升InnoDB存储引擎的数据页可靠性。</p><p>当InnoDB存储引擎正在将某个页写入到表中，当这个页只被写了一部分（16k的页，只写了前4k）就发生了宕机，这种情况被称为写失效（partial page write）。</p><p>为了解决partial page write，InnoDB实现了Double write buffer，就是在写数据页之前，先把这个数据页写到一块独立的物理文件位置（ibdata），然后再写到数据页。<br>这样在宕机重启时，如果出现数据页损坏，就需要通过该页的副本来还愿该页，然后再进行redo log重做。</p><p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/double_write.png" alt="两次写"></p><p>double write由两部分组成，一部分是内存中的double write buffer，大小是2MB， 另一部分是磁盘上的共享表空间中连续的128个页，大小也是2M。<br>1）当触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝到内存中的doublewrite buffer中；<br>2）接着从两次写缓冲区分两次写入磁盘共享表空间中（连续存储、顺序写）每次写1MB；<br>3）再将doublewrite buffer中的脏页数据写入实际的各个表空间中（离散写）。</p><p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/double_write_recovery.png" alt="两次写恢复"></p><p>当不需要开启doublewrite时，使用skip_innodb_doublewrite 关闭。</p><p>innodb_buffer_pool_flushed : 当前从缓冲池中刷新到磁盘页的数量<br>innodb_dblwr_pages_written: double write 的数量</p><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>InnoDB存储引擎会监控对标上各索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引。自适应哈希索引是通过缓冲池的B+树页构造而来，因此建立的速度很快，不需要对整张表建立哈希索引。 InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><p>自使用哈希索引有一个要求，对这个页的查询条件是一样的。<br>如：where a = xxx;<br>   where a = xxx and b = xxx;</p><p>自使用哈希索引是数据库自优化的，无需DBA对数据库进行调整。<br>可以通过innodb_adaptive_hash_index 来启用或者禁用。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>1）提升吞吐量<br>2）IO Merge操作</p><h3 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h3><p>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。<br>通过AIO可以将多个IO卸乳操作合并为一个IO操作。</p><p>可以通过innodb_flush_neighbors 来关闭或者开启该特性。</p><p>select version();<br>show variables like ‘innodb_%_threads’;<br>show variables like ‘innodb_buffer_pool_size’;<br>show variables like ‘innodb_buffer_pool_instances’;<br>show variables like ‘innodb_change_buffering’;<br>show engine innodb status;</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql体系结构和存储引擎</title>
      <link href="/2020/11/03/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2020/11/03/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql-体系结构"><a href="#Mysql-体系结构" class="headerlink" title="Mysql 体系结构"></a>Mysql 体系结构</h2><p><img src="/2020/11/03/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Mysql_struct.jpeg" alt="MySQL体系结构"></p><ul><li>链接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓存组件</li><li>插件式表存储引擎</li><li>物理文件</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>可以根据MySQL官方手册给出的定义存储引擎的过程来编写符合自己需求的存储引擎。<br>或者使用官方提供的存储引擎。</p><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理的应用。其特点是行锁设计、支持外间，并支持类似于Oracle的非锁定读（默认读取操作不会产生锁）。</p><p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。可以将每个独立的表单独存放在一个idb文件中。InnoDB存储引擎支持使用裸设备来建立其表空间。</p><p>InnoDB通过多版本并发控制（MVCC）来获得高并发性；<br>实现了SQL标准的4种隔离级别，默认为REPEATABLE；<br>使用Next-KeyLocking策略避免欢度现象的产生；<br>提供了插入缓冲（Insert Buffer）；<br>二次写（Double Write）；<br>预读（Read Ahead）。</p><p>Innodb存储引擎采用了聚集的方式，每张表的存储都是按照主键的顺序进行存放。如果没有显式地在表定义时制定主键，InnoDB存储引擎会为每一行生成一个6字节的RowId，并以此作为主键。</p><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>MyISAM引擎主要面向一些OLAP（联机分析处理）的应用。 因此不支持事务、表锁设计，但支持全文索引。</p><p>它的缓存池只缓存索引文件，不缓存数据文件，数据文件的缓存交给操作系统来完成。<br>MYISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。</p><h3 id="Maria存储引擎"><a href="#Maria存储引擎" class="headerlink" title="Maria存储引擎"></a>Maria存储引擎</h3><p>其目标是用来替代原有的MYISAM，可以看作是MyISAM的后续版本。<br>特点是支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项。<br>更好的BLOB自负类型的处理性能。</p><h3 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h3><p>也叫NDBCluster存储引擎，壮阳药用于MySQL Cluster分布式集群环境。</p><p>NDB的特点是数据全部放在内存中，因此主键查找的速度极快，并且通过添加NDB数据存储结点可以线性地提高数据库性能，是高可用、高性能的集群系统。<br>由于其存储引擎特性，Join操作是在Muysql数据库层完成，而不是在存储引擎层完成。</p><h3 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h3><p>表中的数据存放在内存中，适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引。</p><p>Memory存储引擎不支持表锁，并发行能差，不支持TEXT和BLOB列类型。存储varchar时是按照char的方式进行的。</p><p>MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集。<br>如果中间爱护你接过机大于Memory存储引擎表的容量设置，又或者包含有TEXT或者BLOB列类型的字段，Mysql会把中间结果集转换到MyISAM存储引擎表存放到磁盘中（因为MyISAM不缓存数据文件），因此会有性能损失。</p><h3 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h3><p>用来存储归档数据，如日志信息等。<br>使用zlib算法将数据行进行压缩后存储，压缩比达到1:10.<br>该引擎只支持INSERT和SELECT操作，该引擎使用行锁来实现高并发的插入操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+ Tree</title>
      <link href="/2020/10/19/Tree/"/>
      <url>/2020/10/19/Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="B-树的特征与结构"><a href="#B-树的特征与结构" class="headerlink" title="B+树的特征与结构"></a>B+树的特征与结构</h2><ul><li>每个子树不保存数据，值用来保存索引数据，所有的数据都保存在叶子结点上；</li><li>所有的叶子结点中包含了全部元素的信息，以及指向这些元素记录的指针，且叶子结点本身依关键字大小有效到大顺序链接。</li><li>所有的中间结点元素都同时存在于子结点，在子结点元素中是最大/最小元素</li></ul><p><a href="http://www.liuzk.com/410.html" target="_blank" rel="noopener">Mysql索引B+树</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DataBase-分布式事务</title>
      <link href="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>随着业务的增长，需要进行分表、分库，甚至拆分应用演化成微服务。<br>因此一次交易需要跨库、跨服务保证每个系统中的交易要么全部成功，否则全部回滚。这里就涉及到分布式事务。</p><p>XA协议时一个基于数据库的分布式事务协议，其分为两部分：事务管理器和本地资源管理器。<br>事务管理器作为一个全局调度着，负责对各个本地资源管理器统一发送提交或者回滚命令。<br>二阶段提交和三阶段提交都是根据此协议衍生而来，Oracle和Mysql均已实现了XA接口。<br>除了二阶段提交和三阶段提交外还有Try Confirm Cancel (TCC)、本地消息队列等分布式事务解决方案。</p><h3 id="二阶段提交-2PC"><a href="#二阶段提交-2PC" class="headerlink" title="二阶段提交 2PC"></a>二阶段提交 2PC</h3><p>二阶段提交需要进行两个阶段的操作，准备阶段和提交阶段。</p><p>准备阶段就是事务管理器（协调者）分别给不同的系统发送“准备”命令，这些系统出了提交数据库事务之外的所有操作，都要在准备阶段操作完成。</p><p>提交阶段就是事务管理器（协调者）给不同的系统发送“提交”命令，每个系统提交自己的数据库事务，然后给协调者返回“提交成功”， 协调者收到所有响应以后，返回给客户端成功响应。<br>如果遇到异常情况提交不成功，需要做一些补偿机制来保证成功。</p><p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/2pc.jpg" alt="二阶段提交"></p><p>对于二阶段提交：<br>如果准备阶段全部返回成功， 那么进入提交阶段，该必须保证成功。<br>如果准备阶段有一个失败，那么协调者通知每个系统回滚。</p><p>二阶段提交保证了原子性与隔离性。所以2PC适合对数据一致性高的场景。</p><p>缺陷：<br>性能低：整个事务的执行过程需要阻塞服务端线程和数据库会话。<br>协调者单点故障：一旦协调者宕机，就会导致事务回话一致处于等待提交阶段，直到事务超时自动回滚。<br>超时导致同步阻塞：当某个参与者节点通信处于超时，其余参与者都会被懂阻塞导致占用的资源不能释放。</p><p>适合场景：只有病发量不大且需要强一致的情况下才考虑使用2PC。</p><h3 id="三阶段提交-3PC"><a href="#三阶段提交-3PC" class="headerlink" title="三阶段提交 3PC"></a>三阶段提交 3PC</h3><p>三阶段提交是对二阶段提交的一种升级优化，它在二阶段提交的中间增加了precommit阶段。保证了在最后提交阶段之前，各个参与者节点状态都一致。<br>同时在协调者与参与者中都引入超时机制，当参与者由于各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2pc的单点故障问题，但是3pc还是没有能从根本上解决数据一致性的问题。</p><p>三个阶段分别是can commit、Pre Commit 、Do Commit；</p><p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3pc.jpg" alt="三阶段提交"></p><h4 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a>CanCommit</h4><p>类似于二阶段提交的准备阶段，协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作，如果可以提交就返回YES，否则返回NO。如果全部响应YES则进入下一个阶段。</p><h4 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a>PreCommit</h4><p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有两种可能</p><p>所有参与者的反馈都是YES那么执行事务的预执行：<br>  1）发送于提交请求，协调者向参与者发送Precommit请求，并进入Prepared阶段。<br>  2）事务预提交，参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。<br>  3）响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如任何一个参与者向协调者发送了NO响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<br>  1）发送终端请求： 协调者向所有参与者发送abort请求。<br>  2）中断事务：参与者收到来自协调者的abort请求之后（或者超时之后，仍未收到协调者的请求）执行事务的中断。</p><h4 id="DoCommit"><a href="#DoCommit" class="headerlink" title="DoCommit"></a>DoCommit</h4><p>该阶段进行真正的事务提交，也分为两种情况。</p><h5 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h5><p>发送提交请求： 协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态。<br>并向所有参与者发送doCommit请求。<br>事务提交：参与者收到docommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有的事务资源。<br>响应反馈：参与者事务提交之后，向协调者发送ACK请求<br>完成事务： 协调者接收到所有参与者的ACK响应之后，完成事务。</p><h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>协调者没有接收到参与者发送的ACK响应（可能是参与者发送的不是ACK响应，也可能是响应超时），那么就会执行中断事务。</p><p>发送中断请求：协调者向所有参与者发送abort请求。<br>事务回滚：参与者接收到abort请求后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。<br>反馈结果：参与者完成事务回滚之后，向协调者发送ACK信息<br>中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断操作。</p><p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3pc-status.jpg" alt="三阶段提交状态图"></p><p>如果已经完成了Precommit进入到Docommit阶段，有的参与者由于超时没有收到Docommit请求时，会自动提交本地事务，并且释放资源。</p><p>三阶段提交解决了二阶段提交无法释放资源的问题。<br>也保证了在提交事务之前所有参与者的状态都一致</p><h3 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h3><p>针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）</p><p>它分为三个操作：</p><h5 id="Try阶段"><a href="#Try阶段" class="headerlink" title="Try阶段"></a>Try阶段</h5><p>主要针对业务系统做检测以及资源预留。</p><h5 id="Confirm阶段"><a href="#Confirm阶段" class="headerlink" title="Confirm阶段"></a>Confirm阶段</h5><p>确认执行业务操作。</p><h5 id="Cancel阶段"><a href="#Cancel阶段" class="headerlink" title="Cancel阶段"></a>Cancel阶段</h5><p>取消执行业务操作。</p><p>TCC处理流程与2PC类似，不过2PC通常是在跨库的DB层面，TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，是的降低锁冲突、提高吞吐量成为可能。</p><p>不足之处在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。<br>此外其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。<br>为了满足一致性的要求，confirm和cancel必须实现幂等。</p><p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/TCC.png" alt="TCC(图片来源于网络)"></p><h3 id="本地消息队列"><a href="#本地消息队列" class="headerlink" title="本地消息队列"></a>本地消息队列</h3><p>如果只需要保证数据的最终一致性，那么可以使用消息队列来解决。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase-事务</title>
      <link href="/2020/10/15/DataBase-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/10/15/DataBase-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事务Transaction"><a href="#什么是事务Transaction" class="headerlink" title="什么是事务Transaction"></a>什么是事务Transaction</h2><p>Transaction一词在英语的翻译中还有一次交易、业务、事务、办理、处理；</p><p>对于一次账户充值100元的操作，其中就有多个环节。<br>1）检查账户的有效性，查询账户余额；<br>2）记录充值流水；<br>3）为账户余额增加100元。</p><p>对于这三个操作来讲，他是一个Transaction， 要么都成功，只要有一个失败，就必须整个Transaction失败，不允许记录了充值流水成功，但是余额增加失败。这三个是一个整体，是不可分割的工作单元。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>原子性 Atomic：要么都成功，只要有一个步骤失败，整个步骤必须回滚（失败）。<br>一致性 Consistency：事务保证读取到的数据总是一致的，如（不存在100元的充值流水时金额为100元， 存在100元的充值流水时金额为200元）。<br>但是对于这个充值过程来讲，肯定是先记录了充值记录，后增加100元余额。可以查到充值记录，但余额是100是客观存在的。<br>隔离性Isolation：为了保证一致性，事务执行过程中的中间状态不对外部可见，事务需要对整个过程进行隔离。<br>持久性 Durability：只要事务一经提交，就一定会被持久化到磁盘中。</p><h2 id="Transaction-阶段"><a href="#Transaction-阶段" class="headerlink" title="Transaction 阶段"></a>Transaction 阶段</h2><p>Transaction 需要有开始和结束，标记一个Transaction的开始和截止；<br>当所有的操作都成功的时候，需要Commit;<br>当其中某个操作失败的时候，之前的操作需要Rollback；</p><p>Transaction Start;<br>Transaction Commit Or Rollback;<br>Transaction End;</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>假如业务员给账户A增加100元的操作的同时（记录了充值流水100元，流水号为666），对账系统也在同时运行同时读取到了这一笔流水号为666的流水记录。但是后续的为余额增加100元的操作失败了，整个Transaction RollBack。 导致账户余额比对账系统少了100元。</p><p>在这里，对账系统看到了业务系统Transaction未提交时的数据，叫脏读。<br>也就是说当前事务的中间状态，对其他事务时可见的。</p><p>事务的最低隔离级别是未提交读（Read Uncommitted），因此会发生脏读的现象。<br>为了解决脏读的现象，需要将事务隔离起来，只允许读到已提交的数据。 Read Committed.</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>假如业务员A给用户增加100元。</p><p>开启事务；<br>查询账户余额 100元；<br>有其他事情去忙……</p><p>此时业务员B也给用户增加100元。<br>开启事务；<br>查询账户余额 100元<br>增加流水记录；<br>增加账户余额100元，变为200元；<br>结束事务；</p><p>业务员A回来为A增加100元：<br>查询账户余额 200元；</p><p>不可重复读就是业务员A在同一个事务内，先后两次读取同一条数据的结果可能不一样。<br>可重复读就是业务员A在同一个事务内，先后两次读取同一条数据的结果总是相同的，无论其他会话是否已经更新了这条数据。</p><p>为了保障在同一事务下，先后两次读取到的同一条数据结果一致，需要将事务的隔离级别调整为可重复读（Repeatable Read）。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>假如业务员A给用户增加100元。</p><p>开启事务；<br>查询流水中是否有ID为1000的流水记录，不存在；</p><p>业务员B给用户增加100元；<br>开启事务；<br>查询流水中是否有ID为1000的流水记录，不存在；<br>插入流水记录；<br>更新账户余额为200；<br>提交事务；</p><p>业务员A开始执行；<br>插入流水记录，此时已经有ID为1000的流水记录，系统异常；<br>可以开启重试机制；<br>由于隔离性，查询是否有ID为1000的流水记录时还是不存在，重试插入时还是异常。</p><p>为了解决幻读的问题，需要将所有的事务和操作进行串行化。这也是Database的最高隔离级别，性能也最差。</p><p><img src="/2020/10/15/DataBase-%E4%BA%8B%E5%8A%A1/Transaction-Isolation.jpg" alt="事务的隔离级别以及解决的问题"></p><p>对于账户充值来讲，交易的原子性以及持久性是最重要的。可以适当牺牲一些一致性和隔离性。</p><p>以下操作在 ReadCommitted 和 Repeatable Read下是安全的。<br>1）给账户余额表增加一个log_id属性，记录最后一笔交易的流水号。<br>2）首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号。<br>3）写入流水记录。<br>4）更新账户余额以及流水记录ID，需要在更新语句的Where条件中限定，只有流水好等于之前查询出的流水号时才能更新。<br>  update account_balance set amount = amount + 100 , log_id = 2 where user_id = 0 and log_id = 1;<br>5）检查更新余额的返回值，如果为1 提交事务，否则回滚。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-应用上下文生命周期</title>
      <link href="/2020/09/08/Spring-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/09/08/Spring-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h2><p>AbstractApplicationContext#refresh()</p><p>该方法是线程安全的方法，在startupShutdownMonitor的锁同步块中。</p><h2 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h2><p> This implementation performs an actual refresh of this context’s underlying bean factory, shutting down the previous bean factory (if any) and initializing a fresh bean factory for the next phase of the context’s lifecycle.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123; <span class="comment">//如果存在beanfactory， 则关闭</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//为上下文生命周期的下个阶段初始化一个新的beanfactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">//指定ID</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">//设置是否允许被覆盖，是否允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">//从Xml、Annotation、Groovy中读取Bean信息并注册。</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="comment">//set the refrences to this.beanFactory.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a>prepareBeanFactory(beanFactory)</h2><p>Prepare the bean facotry for use in this context.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory)"></a>postProcessBeanFactory(beanFactory)</h2><p>Allows post-processing of the bean factory in context subclasses.</p><p>Modify the application context’s internal bean factory after its standard initialization.<br>All bean definitions will have bean loaded, but no beans have been instantiated yet.<br>This alllows for registering special BeanPostProcessors etc in certain Applicationcontext implementations. </p><h2 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h2><p>invoke factory processors registered as beans in the creation.</p><p>Instantiate and invoke all registered BeanFactoryPostProcessor beans,<br>respecting explicit order if given. Must be called before singleton instantiation.</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-总章</title>
      <link href="/2020/09/01/Redis-%E6%80%BB%E7%AB%A0/"/>
      <url>/2020/09/01/Redis-%E6%80%BB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>要设计一个内存型数据库需要考虑哪些？</p><p>0）终端连接</p><p>1）存储的数据结构（需要支持多样的数据类型、数据结构）</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><pre><code>Hash冲突：Key的Hash值冲突，导致一个桶挂了多个元素，Hash表退化成了链表，查找耗时。rehash：为了解决Hash冲突的问题，需要rehash操作，增加现有的Hash桶数量。渐进式Rehash：每操作一次迁移一个Entry，避免rehash造成的阻塞。</code></pre><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h3 id="整数数组"><a href="#整数数组" class="headerlink" title="整数数组"></a>整数数组</h3><h3 id="压缩队列"><a href="#压缩队列" class="headerlink" title="压缩队列"></a>压缩队列</h3><pre><code>类似于一个数组，数组中的每一个元素都对应保存一个数据。压缩列表表头有三个字段zlbytes 列表长度, zltail 列表尾部偏移量, zllen 列表中entry的个数, 压缩列表再表尾还有一个zlend，表示列表结束。</code></pre><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><pre><code>加速队列和数组的访问。</code></pre><h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><pre><code>byte   1字节boolean 1字节char   2字节,只要是字符无论是英文还是汉字，都占2个字节。short  2字节int    4字节long   8字节float 4字节double  8字节整数数组和压缩列表再查找时间复杂度方面并没有很大的优势，为什么Redis还会把他们作为底层数据结构？1）内存利用率方面：数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存更少。Redis是内存数据库，大量数据存储到内存中，此时需要做尽可能的优化，提高内存的利用率。2）数组对CPU高速缓存支持更友好，所以Redis再设计师，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后看，避免时间复杂度太高，转为Hash和跳表数据结构存储，保证查询效率。数组对CPU缓存友好的原因是，CPU预读取一个CacheLine大小的数据，数组数据排列紧凑，相同大小空间保存的元素更多，访问下一个元素时、恰好已经在CPU缓存中了，如果是随机访问，就不能充分利用CPU缓存。</code></pre><p>2）对数据的加工和操作</p><p>   单个元素的查找、修改、删除对于Redis来讲会非常快（在没有Hash冲突的情况下）<br>   LLEN、SCARD等操作时间复杂度为O（1）, 集合类型采用压缩列表，双向链表，整数数组等数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效的完成相关操作。<br>   HGETALL、SMEMBERS、LRANGE、ZRANGE等复杂度为O(N)的操作要避免，使用HSCAN、SSCAN、ZSCAN来替代，SCAN操作实现了渐进式便利，每次只返回优先数量的数据。</p><p>3）数据的安全性：<br>    1）数据的备份：<br>       实时备份：<br>            对数据进行操作后记录操作日志<br>       定时备份<br>    2）数据的恢复<br>4）服务的高可用<br>    主从模式</p><p>5）服务的监控、故障恢复以及通知<br>    哨兵模式<br>    哨兵集群</p><p>6）数据分片<br>   纵向扩展：扩大服务器的内存，但是当存储数据内容较多，需要RDS备份时，会影响到Redis的使用性能。</p><p>   横向扩展</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="高性能IO模型"><a href="#高性能IO模型" class="headerlink" title="高性能IO模型"></a>高性能IO模型</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><h3 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h3><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h3 id="AOF-AppendOnlyFile"><a href="#AOF-AppendOnlyFile" class="headerlink" title="AOF AppendOnlyFile"></a>AOF AppendOnlyFile</h3><pre><code>记录每一条日志日志压缩</code></pre><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><h3 id="数据同步-读写分离-主从-主从从"><a href="#数据同步-读写分离-主从-主从从" class="headerlink" title="数据同步/读写分离 主从/主从从"></a>数据同步/读写分离 主从/主从从</h3><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><h4 id="监测"><a href="#监测" class="headerlink" title="监测"></a>监测</h4><h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><h4 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h4><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><h3 id="纵向扩容"><a href="#纵向扩容" class="headerlink" title="纵向扩容"></a>纵向扩容</h3><h3 id="横向扩容-分片"><a href="#横向扩容-分片" class="headerlink" title="横向扩容/分片"></a>横向扩容/分片</h3>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Reids </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-注解</title>
      <link href="/2020/08/18/Spring-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/08/18/Spring-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Spring 注解驱动编程发展历程</p><p> 1.2 @Transactional<br>     @ManagedResource<br> 2.0 @Component<br>     @Repository<br> 3.0 @Bean<br>     @Import</p><p> 4.0 @Profile<br>     @Conditional<br>     @Indexed<br>Spring 核心注解场景分类</p><pre><code>|注解|场景说明|起始版本||---|---|---||@Repository| 数据仓储模式注解| 2.0||@Component| 通用组件模式注解| 2.5||@Service| 服务模式注解| 2.5||@Controller| Web控制器模式注解| 2.5||@Configuration| 配置类模式注解| 3.0|</code></pre><h4 id="装配注解"><a href="#装配注解" class="headerlink" title="装配注解"></a>装配注解</h4><pre><code>|注解|场景说明|起始版本||---|---|---||@ImportResource| 替换XML元素\&lt;import\&gt;| 2.5||@Import| 导入Configuration类，无论是否标记@Configuration| 2.5||@ComponentScan| 扫描指定package下标注Spring模式注解的类| 3.1|</code></pre><h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><pre><code>|注解|场景说明|起始版本||---|---|---||@Autowired| Bean依赖注入，支持多种依赖查找方式| 2.5||@Qualifier| 细粒度的@Autowired查找| 2.5|</code></pre><h2 id="Spring-注解编程模型"><a href="#Spring-注解编程模型" class="headerlink" title="Spring 注解编程模型"></a>Spring 注解编程模型</h2><p>   元注解<br>   Spring 模式注解<br>   Spring 组合注解<br>   Spring 注解属性别名/覆盖</p><h2 id="Spring-元注解（Meta-Annotations）"><a href="#Spring-元注解（Meta-Annotations）" class="headerlink" title="Spring 元注解（Meta-Annotations）"></a>Spring 元注解（Meta-Annotations）</h2><p> A meta-annotation is an annotation that is declared on another annotation.<br> An annotation is therefore meta-annotated if it is annotated with another annotation. For example, any annotation that is declared to be documented is meta-annotated with @Documented from the java.lang.annotation package.</p><ul><li>java.lang.annotation.Documented</li><li>java.lang.annotation.Inherited</li><li>java.lang.annotation.Repeatable</li></ul><h2 id="Spring-模式注解（Stereotype-Annotations）"><a href="#Spring-模式注解（Stereotype-Annotations）" class="headerlink" title="Spring 模式注解（Stereotype Annotations）"></a>Spring 模式注解（Stereotype Annotations）</h2><p>  元标注@Component的注解在XML元素 <a href="context:component-scan">context:component-scan</a> 或 注解 @ComponentScan 扫描中派生了 @Component 特性， 并且从Spring Framework 4.0 开始支持多层次派生。</p><ul><li>@Repository</li><li>@Service</li><li>@Controller</li><li>@Configuration</li><li>@SpringBootConfiguration </li></ul><p>Spring 组合注解（Composed Annotations）</p><p>  A composed annotation is an annotation that is meta-annotated withy one or more annotations with the intent of combining the behavor associated with those meta-annotations into a single custom annotation.<br>  For example, an annotation named @TransactionalService that is meta-annotation with Spring’s @Transactional and @Service annotations is a composed annotation that combines the semantics of @Transactional and @Service.<br>  @TransactionalService is technically also a custom stereotype annotation.</p><p>  基本定义： </p><p>  spring组合注解中的元注解允许是Spring模式注解与其他Spring功能性注解的任意组合。</p><p>Spring 注解属性别名（Attribute Alias）</p><p>Spring 注解属性覆盖（Attribute Ovverides）</p><p>Spring @Enable 模块驱动</p><p>  @Import(@Configuration)<br>  @Import(ImportSelector)<br>  @Import(ImportBeanDefinitionRegistrar)<br>    AnnotatedBeanDefinition ad = new AnnotatedGenericBeanDefinition();<br>    BeanDefinitionReaderUtils.registerWithGeneratedName(ad, register);</p><p>Spring 条件注解</p><p>上下文对象： org.springframework.context.annotation.ConditionContext<br>条件判断：org.springframework.context.annotation.ConditionEvaluator<br>配置阶段：org.sprignframework.context.annotation.ConfigurationCondition.ConfigurationPhase<br>判断入口：org.springframework.context.annotation.ConfigurationClassPostProcessor<br>        org.springframework.context.annotation.ConfigurationClassPasser<br>ConditionContext<br>ConditionEvaluator</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-DataBind</title>
      <link href="/2020/08/15/Spring-DataBind/"/>
      <url>/2020/08/15/Spring-DataBind/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Validator</title>
      <link href="/2020/08/14/Spring-Validator/"/>
      <url>/2020/08/14/Spring-Validator/</url>
      
        <content type="html"><![CDATA[<p>Spring 校验使用场景<br>   Spring 常规校验 Validator<br>   Spring 数据绑定 Databinder<br>   Spring Web 参数绑定 WebDataBinder<br>   Spring WebMVC/WebFlux 处理方法参数校验</p><p>Validator 接口设计</p><p>Errors 接口设计</p><p>Errors 文案来源</p><p>自定义Validator</p><p>Validator的救赎</p><p>面试题</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Resource-资源管理</title>
      <link href="/2020/08/07/Spring-Resource-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2020/08/07/Spring-Resource-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>引入冬季</p><h2 id="Java标准资源管理"><a href="#Java标准资源管理" class="headerlink" title="Java标准资源管理"></a>Java标准资源管理</h2><p>  强大<br>  |面向资源|文件系统、artifact（Jar、War、ear）、远程资源（HTTP/FTP）|<br>  |API整合|java.lang.ClassLoader.getResource\ java.io.File / java.net.URL|<br>  |资源定位|java.net.URL / java.net.URI|<br>  |面向流存储|java.net.URLConnection|<br>  |协议扩展|java.net.URLStreamHandler / java.net.URLStreamHandlerFactory|<br>  扩展复杂</p><p><img src="/2020/08/07/Spring-Resource-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/URLStreamHandlerFactory.jpg" alt="扩展协议 "></p><p>Spring资源接口</p><table><thead><tr><th>类型</th><th>接口</th></tr></thead><tbody><tr><td>输入流</td><td>org.springframework.core.io.InputStreamSource</td></tr><tr><td>只读资源</td><td>org.springframework.core.io.Resource</td></tr><tr><td>可写资源</td><td>org.springframework.core.io.WritableResource</td></tr><tr><td>编码资源</td><td>org.springframework.core.io.EncodedResource</td></tr><tr><td>上下文资源</td><td>org.springframework.core.io.ContextResource</td></tr></tbody></table><p><img src="/2020/08/07/Spring-Resource-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/SpringInputStreamResource.png" alt="Spring InputStreamResource"></p><p>Spring内建Resource实现</p><p>|Bean 定义|无|org.springframework.beans.factory.support.BeanDefinitionResource|<br>|字节码|无|org.springframework.core.io.ByteArrayResource|<br>|类路径|classpath:/|org.springframework.core.io.ClassPathResource|<br>|文件系统|file:/|org.springframework.core.io.FileSystemResource|<br>|URL|URL支持的协议|org.springframework.core.io.UrlResource|<br>|ServletContext|无|org.springframework.web.context.support.ServletContextResource|</p><p>Spring Resource 接口扩展<br>Spring 资源加载器</p><ul><li>Resource 加载器<ul><li>org.springframework.core.io.ResourceLoader<ul><li>org.springframewor.core.io.DefaultResourceLoader<ul><li>org.springframework.core.io.FileSystemResourceLoader</li><li>org.springframework.core.io.ClassRelativeResourceLoader</li><li>org.springframework.context.support.AbstractapplicationContext</li></ul></li></ul></li></ul></li></ul><p>Spring 通配路径资源加载器</p><ul><li>通配路径ResourceLoader<ul><li>org.springframework.core.io.support.ResourcePatternResolver<ul><li>org.springframework.core.io.support.PathMatchingResourcePatternResolver</li></ul></li></ul></li><li>路径匹配起<ul><li>org.springframework.util.PathMatcher<ul><li>Ant模式匹配实现 - org.springframework.util.AntPathMatcher</li></ul></li></ul></li></ul><p>Spring 通配路径资源扩展</p><p>依赖注入 Spring Resource</p><p> @Value(“classpath:/…”)<br> private Resource resource;</p><p>依赖注入 ResourceLoader</p><ul><li>实现 ResourceLoaderAware 回调</li><li>@Autowire 注入 ResourceLoader</li><li>注入ApplicationContext 作为 ResourceLoader</li></ul><p>Java 标准资源管理扩展</p><ul><li>实现URLStreamhandler, 并放置在 sun.net.<a href="http://www.protocal.${protocal}.Handler" target="_blank" rel="noopener">www.protocal.${protocal}.Handler</a> 下</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XURLConnection</span> <span class="keyword">extends</span> <span class="title">URLConnection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UrlResource resource;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">XURLConnection</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(url);</span><br><span class="line">   <span class="keyword">this</span>.resource = <span class="keyword">new</span> ClassPathResource(url.getPath());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resource.getInputStream();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> XURLConnection(u);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"x:///META-INF/default.properties"</span>);</span><br><span class="line">InputStream is = url.openStream();</span><br><span class="line">System.out.println(StreamUtils.copyString(is, Charset.forName(<span class="string">"UTF-8"</span>)));</span><br></pre></td></tr></table></figure><ul><li><p>实现URLStreamHandler， 添加 -Djava.protocal.handler.pkgs 启动参数,指向URLStreamHandler 实现类的包</p></li><li><p>实现URLStreamHandlerFactory 并传递到URL之中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Bean配置元信息</title>
      <link href="/2020/07/28/Spring-Bean%E9%85%8D%E7%BD%AE%E5%85%83%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/07/28/Spring-Bean%E9%85%8D%E7%BD%AE%E5%85%83%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-配置元信息"><a href="#Spring-配置元信息" class="headerlink" title="Spring 配置元信息"></a>Spring 配置元信息</h2><p>  Bean配置元信息：BeanDefinition<br>  Bean属性元信息：PropertyValues<br>  容器配置元信息<br>  外部化配置元信息： PropertySource<br>  Profile 元信息： @Profile</p><p>Spring Bean 配置元信息</p><pre><code>GenericBeanDefinitionRootBeanDefinitionAnnotatedBeanDefinition</code></pre><p>Spring Bean 属性元信息<br> PropertyValues<br>  MutablePropertyValues<br>  PropertyValue<br>Bean 属性上下文存储<br>  AttributeAccessor<br>Bean 元信息元素<br>   BeanMetadataElement</p><p>Spring 容器配置元信息</p><h4 id="beans-元素"><a href="#beans-元素" class="headerlink" title="beans 元素"></a>beans 元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- outter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">profile</span>=<span class="string">"dev"</span> <span class="attr">default-lazy-init</span>=<span class="string">"default"</span> <span class="attr">default-merge</span>=<span class="string">"default"</span> <span class="attr">default-autowire</span>=<span class="string">"default"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire-candidates</span>=<span class="string">""</span> <span class="attr">default-init-method</span>=<span class="string">""</span> <span class="attr">default-destroy-method</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inner --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"applicationContext-lookup.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRepository"</span> <span class="attr">class</span>=<span class="string">"com.github.springframework.repository.UserRepository"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Beans元素属性</th><th>默认值</th><th>使用场景</th></tr></thead><tbody><tr><td>profile</td><td>null（留空）</td><td>SpringProfiles 配置值</td></tr><tr><td>default-lazy-init</td><td>default</td><td>当outter Beans “default-lazy-init”属性存在时，继承该值，否则为false</td></tr><tr><td>default-merge</td><td>default</td><td>当outter beans ‘default-merge’ 属性存在时，继承该值，否则为“false”</td></tr><tr><td>default-autowire</td><td>default</td><td>当outter beans “default-autowire”存在时，继承该值，否则为no</td></tr><tr><td>default-autowire-candidates</td><td>null</td><td>默认SpringBean名称的pattern</td></tr><tr><td>default-init-method</td><td>null</td><td>默认springBeans 自定义初始化方法</td></tr><tr><td>default-destroy-method</td><td>null</td><td>默认SpringBean自定义的销毁方法</td></tr></tbody></table><h4 id="Spring-Xml-配置元信息"><a href="#Spring-Xml-配置元信息" class="headerlink" title="Spring Xml 配置元信息"></a>Spring Xml 配置元信息</h4><table><thead><tr><th>xml元素</th><th>使用场景</th></tr></thead><tbody><tr><td>&lt;context:annotation-config/&gt;</td><td>激活Spring注解驱动</td></tr><tr><td>&lt;context:component-scan/&gt;</td><td>Spring @Component 以及自定义注解扫描</td></tr><tr><td>&lt;context:load-time-weaver /&gt;</td><td>激活Spring LoadTimeWeaver</td></tr><tr><td>&lt;context:mbean-export /&gt;</td><td>暴露Springbeans 做为JMX beans</td></tr><tr><td>&lt;context:mbean-server /&gt;</td><td>将当前平台作为MBeanServer</td></tr><tr><td>&lt;context:property-placeholder /&gt;</td><td>加载外部化配置资源作为Spring属性配置</td></tr><tr><td>&lt;context:property-override /&gt;</td><td>利用外部化配置资源覆盖Spring属性值</td></tr></tbody></table><p>底层实现 <code> BeanDefinitionParserDelegate </code> </p><h4 id="基于XML文件装载"><a href="#基于XML文件装载" class="headerlink" title="基于XML文件装载"></a>基于XML文件装载</h4><p>Spring Bean 配置元信息</p><table><thead><tr><th>xml元素</th><th>使用场景</th></tr></thead><tbody><tr><td>&lt;beans:beans /&gt;</td><td>单XML资源下的多个SpringBean配置</td></tr><tr><td>&lt;beans:bean /&gt;</td><td>单个SpringBean定义Beandefinition 配置</td></tr><tr><td>&lt;beans:alias /&gt;</td><td>为SpringBean 定义（BeanDefinition）映射别名</td></tr><tr><td>&lt;beans:import /&gt;</td><td>加载外部SpringXML 配置资源</td></tr></tbody></table><p>底层实现 <code> XmlBeanDefinitionReader </code> 和 <code> BeanDefinitionDocumentReader</code> 和  <code> BeanDefinitionHolder</code></p><h4 id="基于Properties文件装载"><a href="#基于Properties文件装载" class="headerlink" title="基于Properties文件装载"></a>基于Properties文件装载</h4><p>Spring Bean 配置元信息</p><table><thead><tr><th>Properties 属性名</th><th>使用场景</th></tr></thead><tbody><tr><td>(class)</td><td>Bean类全称限定名</td></tr><tr><td>(abstract)</td><td>是否为抽象的BeanDefinition</td></tr><tr><td>(parent)</td><td>指定 parent BeanDefinition</td></tr><tr><td>(lazy-init)</td><td>是否延迟初始化</td></tr><tr><td>(ref)</td><td>引用其他Bean的名称</td></tr><tr><td>(scope)</td><td>设置Bean的scope属性</td></tr><tr><td>${n}</td><td>n标示第n个构造器参数</td></tr><tr><td>底层实现<code>PropertiesBeanDefinitionReader</code></td><td></td></tr></tbody></table><p>基于Java注解装载SpringBean的配置元信息</p><table><thead><tr><th>Spring注解</th><th>场景说明</th></tr></thead><tbody><tr><td>@Repository</td><td>数据仓储模式</td></tr><tr><td>@Component</td><td>通用组建模式</td></tr><tr><td>@Service</td><td>服务模式</td></tr><tr><td>@Controller</td><td>Web控制器模式</td></tr><tr><td>@Configuration</td><td>配置类模式</td></tr><tr><td>@Autowired</td><td>Bean依赖注入，支持多种依赖查找方式</td></tr><tr><td>@Qualifier</td><td>细粒度的@Autowired 依赖查找</td></tr><tr><td>@Resource</td><td>Java注解，类似于@Autowired</td></tr><tr><td>@Inject</td><td>Java注解，类似于@Autowired</td></tr><tr><td>@Profile</td><td>配置话条件装配</td></tr><tr><td>@Conditional</td><td>编程条件装配</td></tr><tr><td>@PostConstructor</td><td>替换XML元素 &lt;bean init-method=” /&gt; 或者 initializingBean</td></tr><tr><td>@PreDestroy</td><td>替换XML元素 <bean destroy-method> 或者 DisposableBean</bean></td></tr></tbody></table><p>ClassPathScanningCandidateComponentProvider<br>AutowiredAnnotationBeanPostProcessor<br>CommonAnnotationBeanPostProcessor</p><p>SpringBean配置元信息底层实现</p><ul><li><p>Xml资源 BeanDefinition解析与注册</p><ul><li>核心API: XmlBeanDefinitionReader<ul><li>资源： Resource</li><li>底层： BeanDefinitionDocumentReader<ul><li>XML 解析： JavaDOM Level 3 API</li><li>BeanDefinition  解析 BeanDefinitionParserDelegate</li><li>BeanDefinition 注册 BeanDefinitionRegistry<br>DefaultBeanDefinitionDocumentReader</li></ul></li></ul></li></ul></li><li><p>Properties 资源 BeanDefinition 解析与注册</p><ul><li>核心API：PropertiesBeanDefinitionReader<ul><li>资源<ul><li>字节流：Resource</li><li>字符流：EncodeResource</li></ul></li><li>底层：<ul><li>存储：java.util.Properties</li><li>BeanDefinition 解析： API内部实现</li><li>BeanDefinition 注册： BeanDefinitionRegistry</li></ul></li></ul></li></ul></li><li><p>Annotation 解析与注册</p><ul><li>核心API：AnnotatedBeanDefinitionReader<ul><li>资源<ul><li>类对象： java.lang.Class</li></ul></li><li>底层<ul><li>条件评估： ConditionEvaluator</li><li>Bean范围解析： ScopeMetadataResolver</li><li>BeanDefinition解析：内部API实现</li><li>BeanDefinition处理：AnnotationConfigUtils.processCommonDefinitionAnnotations</li><li>BeanDefinition注册：BeanDefinitionRegistry</li></ul></li></ul></li></ul></li></ul><p>基于XML文件装载SpringIOC容器配置元信息</p><table><thead><tr><th>命名空间</th><th>所属模块</th><th>Schema资源URL</th></tr></thead><tbody><tr><td>beans</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank" rel="noopener">https://www.springframework.org/schema/beans/spring-beans.xsd</a></td></tr><tr><td>context</td><td>spring-context</td><td><a href="https://www.springframework.org/schema/context/spring-context.xsd" target="_blank" rel="noopener">https://www.springframework.org/schema/context/spring-context.xsd</a></td></tr><tr><td>aop</td><td>spring-aop</td><td><a href="https://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank" rel="noopener">https://www.springframework.org/schema/aop/spring-aop.xsd</a></td></tr><tr><td>tx</td><td>spring-tx</td><td><a href="https://www.springframework.org/schema/tx/spring-tx.xsd" target="_blank" rel="noopener">https://www.springframework.org/schema/tx/spring-tx.xsd</a></td></tr><tr><td>util</td><td>spring-util</td><td><a href="https://www.springframework.org/schema/util/spring-util.xsd" target="_blank" rel="noopener">https://www.springframework.org/schema/util/spring-util.xsd</a></td></tr><tr><td>tool</td><td>spring-tool</td><td><a href="https://www.springframework.org/schema/tool/spring-tool.xsd" target="_blank" rel="noopener">https://www.springframework.org/schema/tool/spring-tool.xsd</a></td></tr></tbody></table><p>基于Java注解装载SpringIOC容器配置元信息</p><table><thead><tr><th>Spring注解</th><th>场景说明</th><th>Since</th></tr></thead><tbody><tr><td>@ImportResource</td><td>替换XML元素 &lt;/import&gt;</td><td>3.0</td></tr><tr><td>@Import</td><td>导入Configuration Class</td><td>3.0</td></tr><tr><td>@ComponentScan</td><td>扫描指定package下标注Spring模式注解的类</td><td>3.1</td></tr><tr><td>@PropertySource</td><td>配置属性抽象</td><td>3.1</td></tr><tr><td>@PropertySources</td><td>@PropertySource集合注解</td><td>4.0</td></tr></tbody></table><p>基于ExtensibleXML authoring扩展Spring XML元素</p><ul><li>编写 XML Schema 文件，定义XML结构</li><li>自定义NameSpaceHandler， 实现命名空间绑定</li><li>自定义BeanDefinitionParser， 实现XML元素与BeanDefinition解析</li><li>注册XML扩展：命名空间与XML Schema 映射</li></ul><p>Extensible XML authoring扩展原理</p><ul><li>AbstractApplicationcontext.obtainFreshBeanFactory<ul><li>AbstractRefreshableApplicationContext.refreshBeanFactory<ul><li>AbstractXmlApplicationContext.loadBeanDefinitions<ul><li>XmlBeanDefinitionReader.doLoadBeanDefinitions<ul><li>BeanDefinitionParserDelegate.parseCustomElement</li></ul></li></ul></li></ul></li></ul></li></ul><p>BewanDefinitionParserDelegate.parseCustomElement(Element, BeanDefinition);</p><ul><li>获取namespace</li><li>通过namespace 解析NamespaceHandler</li><li>构造ParserContext</li><li>解析元素，获取BeanDefinition</li></ul><p>基于Properties文件装载外部化配置<br>基于YAML文件装载外部化配置</p><ul><li>org.springfrmework.beans.factory.config.YamlProcessor<ul><li>org.springframework.beans.factory.config.YamlMapFactoryBean</li><li>org.springframework.beans.factory.config.YamlPropertiesFactoryBean</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-生命周期</title>
      <link href="/2020/07/22/Spring-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/07/22/Spring-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBean-元信息"><a href="#SpringBean-元信息" class="headerlink" title="SpringBean 元信息"></a>SpringBean 元信息</h2><p><img src="/2020/07/22/Spring-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/BeanDefinition.jpg" alt="BeanDefinition Class Diagram"></p><h3 id="元信息的配置"><a href="#元信息的配置" class="headerlink" title="元信息的配置"></a>元信息的配置</h3><ul><li>通过资源的方式配置，如： XML、 Properties、Groovy</li><li>通过注解配置 ： @Bean</li><li>通过API配置 ：BeanDefinitionBuilder / GenericBeanDefinition </li></ul><h3 id="元信息的读取"><a href="#元信息的读取" class="headerlink" title="元信息的读取"></a>元信息的读取</h3><p>1) Get beanDefinitionRegistry for registry beanDefinitions.<br>2) Get ResourceLoader<br>3) Get ClassLoader.</p><ul><li>读取通过资源方式配置，如：XmlBeanDefinitionReader、PropertiesBeanDefinitionReader、GroovyBeanDefinitionReader</li><li>读取注解配置的Bean：AnnotatedBeanDefinitionReader</li></ul><p><img src="/2020/07/22/Spring-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/BeanDefinitionReader.jpg" alt="BeanDefinitionReader Class Diagram"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">AnnotatedBeanDefinitionReader reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(beanFactory);</span><br><span class="line">reader.register(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="元信息的解析"><a href="#元信息的解析" class="headerlink" title="元信息的解析"></a>元信息的解析</h3><p><img src="/2020/07/22/Spring-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/BeanDefinitionParser.png" alt="BeanDefinitionParser"></p><p>图片版本的看不太清，整理一份文字版本的层级关系，除BeanDefinitionParser是顶层抽象接口外，其余Parser都是类或者抽象类。  </p><ul><li>BeanDefinitionParser<ul><li>SpringConfiguredBeanDefinitionParser</li><li>AnnotationDrivenCacheBeanDefinitionParser</li><li>ScriptingDefaultsParser</li><li>ComponentScanBeanDefinitionParser</li><li>AnnotationConfigBeanDefinitionParser</li><li>AspectJAutoProxyBeanDewfinitionParser</li><li>SpringConfiguredBeanDefinitionParser</li><li>ConfigBeanDefinitionParser</li><li>AnnotationDrivenBeanDefinitionParser</li><li>AbstractBeanDefinitionParser<ul><li>MBeanExportBeanDefinitionParser</li><li>MBeanServiceBeanDefinitionParser</li><li>ScriptBeanDefinitionParser</li><li>AbstractSingleBeanDefinitionParser<ul><li>ExecutorBeanDefinitionParser</li><li>SchedulerBeanDefinitionParser</li><li>SetBeanDefinitionParser</li><li>AbstractPropertyLoadingBeanDefinitionParser</li><li>LoadTimeWeaverBeanDefinitionParser</li><li>CacheAdviceParser</li><li>ListBeanDefinitionParser</li><li>ScheduledTasksBeanDefinitionParser</li><li>MapBeanDefinitionParser</li><li>PropertiesBeanDefinitionParser</li><li>PropertyPathBeanDefinitionParser</li><li>AbstractSimpleBeanDefinitionParser<ul><li>ConstantBeanDefinitionParser</li><li>AbstractJndiLocatingBeanDefinitionParser<ul><li>JndiLookupBeanDefinitionParser</li><li>LocalStatelessSessionBeanDefinitionParser</li><li>RemoteStatelessSessionBeanDefinitionParser</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="SpringBean-注册"><a href="#SpringBean-注册" class="headerlink" title="SpringBean 注册"></a>SpringBean 注册</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition &#x3D; this.beanDefinitionMap.get(beanName);</span><br><span class="line">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      if (hasBeanCreationStarted()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">        synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">          this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">          List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">          updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">          updatedDefinitions.add(beanName);</span><br><span class="line">          this.beanDefinitionNames &#x3D; updatedDefinitions;</span><br><span class="line">          removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        &#x2F;&#x2F; Still in startup registration phase</span><br><span class="line">        this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        this.beanDefinitionNames.add(beanName);</span><br><span class="line">        removeManualSingletonName(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      this.frozenBeanDefinitionNames &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (existingDefinition !&#x3D; null || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Spring BeanDefinition 合并阶段</p><p>GenericBeanDefinition -&gt; RootBeanDefinition</p><p>Spring Bean Class 加载阶段</p><p>BeanDefinition 中定义的Class名称加载具体的Class类。 </p><p>ClassLoader 类加载<br>Java Security 安全控制<br>ConfigurableBeanFactory 临时 ClassLoader</p><p>Spring Bean 实例化<br>   实例化前：<br>     InstantiationAwareBeanProcessor.postProcessorBeforeInstantiation()<br>     提前生成一些代理对象，替换掉默认的springIOC的实现内容。<br>   实例化<br>     传统实例化方式<br>       + 实例化策略 InstantiationStrategy</p><pre><code>构造器依赖注入（根据类型来注入）</code></pre><p>   实例化后<br>        InstantiationAwareBeanProcessor.postProcessorAfterInstantiation()</p><p>Spring Bean 属性赋值前阶段</p><p>   Bean的属性值元信息： PropertyValues<br>   构造器参数值：ConstructorValues</p><p>   Bean属性赋值前回调<br>    &lt;= 5.0  InstantiationAwareBeanPostProcessor#postProcessorPropertyValues();<br>    &gt;= 5.1 InstantiationAwareBeanPostProcessor#postProcessorProperties();</p><p>Spring Bean Aware 接口回调阶段</p><p> Aware接口是一个标志接口，并没有提供任何实现。<br> BeanNameAware<br> BeanClassLoaderAware<br> BeanFactoryAware<br> EnvironmentAware<br> EmbeddedValueResolverAware<br> ApplicationEventPublisherAware<br> MessageSourceAware<br> ApplicationContextAware</p><p>Spring Bean 初始化</p><p>   初始化前<br>   BeanPostProcessor#postProcessorBeforeInitialization<br>   初始化<br>   @PostConstructor<br>   AfterPropertiesSet<br>   init-method<br>   初始化后<br>   BeanPostProcessor#postProcessAfterInitialization<br>   初始化完成<br>   SmartinitializingSingleton#afterSingletonsInstanted</p><h5 id="AbstractAutowireCapableBeanFactory"><a href="#AbstractAutowireCapableBeanFactory" class="headerlink" title="AbstractAutowireCapableBeanFactory"></a>AbstractAutowireCapableBeanFactory</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the given bean instance, applying factory callbacks</span></span><br><span class="line"><span class="comment"> * as well as init methods and bean post processors.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Called from &#123;<span class="doctag">@link</span> #createBean&#125; for traditionally defined beans,</span></span><br><span class="line"><span class="comment"> * and from &#123;<span class="doctag">@link</span> #initializeBean&#125; for existing bean instances.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the bean name in the factory (for debugging purposes)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the new bean instance we may need to initialize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition that the bean was created with</span></span><br><span class="line"><span class="comment"> * (can also be &#123;<span class="doctag">@code</span> null&#125;, if given an existing bean instance)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initialized bean instance (potentially wrapped)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanNameAware</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanClassLoaderAware</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryAware</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #applyBeanPostProcessorsBeforeInitialization</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #invokeInitMethods</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object wrappedBean = bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">        (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">        beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring  Bean 销毁<br>    销毁前<br>      DestructionAwareBeanPostProcessor#postProcessorBeforeDestruction<br>    销毁<br>      @PreDestroy<br>      实现DisposableBean接口的destroy方法<br>      自定义销毁方法<br>    垃圾回收<br>      关闭Spring 容器<br>      执行GC<br>      SpringBean 覆盖finalize()方法被回调</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-作用域</title>
      <link href="/2020/07/21/Spring-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/07/21/Spring-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring Bean 作用域<br> 单例模式<br>singleton Bean 作用域：在BeanFactory中唯一。<br> 原型模式<br>prototype Bean 作用域：</p><p>servlet 引擎：<br>request Bean 作用域： 将Spring Bean 存储在Servlet Request上下文中<br>session Bean 作用域：将SpringBean存储在HttpSession中<br>application bean 作用域：将SpringBean存储在ServletContext中。<br>自定义Bean 作用域</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-依赖处理</title>
      <link href="/2020/07/18/Spring-%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/"/>
      <url>/2020/07/18/Spring-%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>入口：DefaltListableBeanFactory#resolveDependency<br>依赖描述符：DependencyDescriptor<br>自定绑定候选对象处理器：AutowireCandidateResolver</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 依赖处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-BeanFactory</title>
      <link href="/2020/07/17/Spring-BeanFactory/"/>
      <url>/2020/07/17/Spring-BeanFactory/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/07/17/Spring-BeanFactory/BeanFactory.jpg" alt="Spring BeanFactory 类图"></p><p>BeanFactory是访问Spring bean容器的根接口。提供了一些获取Bean的基础方法定义。</p><p><img src="/2020/07/17/Spring-BeanFactory/BeanFactoryMethods.jpg" alt="BeanFactory"></p><p>ListableBeanFactory 和 ConfigurableBeanFactory 提供了一些更具体的特殊目标。</p><p>ListableBeanFactory继承了BeanFactory, 容器可以以列表的形式获取bean的相关信息，提供了获取多个beanName的基础方法。<br><img src="/2020/07/17/Spring-BeanFactory/listable_bean_factory.jpg" alt="ListableBeanFactory"></p><p>ConfigurableBeanFactory 继承了 hierarchicalBeanFactory, 提供了IOC容器的可配置能力，几乎所有的BeanFactory都会实现这个接口。<br><img src="/2020/07/17/Spring-BeanFactory/configurable_bean_factory.jpg" alt="ConfigurableBeanFactory"></p><p>AutowireCapableBeanFactory 提供了自动装配Bean的能力。</p><p><img src="/2020/07/17/Spring-BeanFactory/AutowireCapableBeanFactory.jpg" alt="AutowireCapableBeanFactory"></p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring-BeanFactory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-依赖注入</title>
      <link href="/2020/07/16/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/07/16/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>依赖注入的模式和类型</p><ul><li>手动<ul><li>Xml资源配置元信息</li><li>Java注解配置元信息<ul><li>@Bean</li><li>@Autowired</li></ul></li><li>API配置元信息</li></ul></li><li>自动<ul><li>Autowiring</li></ul><ul><li>类型<ul><li>No : 默认值，未激活自动绑定，需要手动指定依赖注入</li><li>byName: 根据被注入属性的名称做为Bean名称进行依赖查找，并将对象设置到该属性</li><li>byType: 根据被注入属性的类型做为依赖类型进行查找，并将对象设置到该属性</li><li>constructor： 特殊的byType，用于构造器参数</li></ul></li></ul></li></ul><p>xml 资源配置元信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">ref</span>=<span class="string">"nameObj"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>依赖注入类型</th><th>示例</th></tr></thead><tbody><tr><td>set</td><td>&lt;property name=”user” ref=”userBean”/&gt;</td></tr><tr><td>构造器</td><td>&lt;constructor-arg name=”user” ref=”userBean”/&gt;</td></tr><tr><td>字段注入</td><td>@Autowired User user;</td></tr><tr><td>方法注入</td><td>@Autowired public void user(User user){}</td></tr><tr><td>回调注入</td><td>class MyBean implements BeanFactoryAware{}</td></tr></tbody></table><p>依赖注入选择</p><p>基础类型注入<br>集合类型注入<br>限定注入<br>延迟依赖注入<br>依赖处理过程<br>@Autowired 注入原理<br>JSR-330@inject注入原理<br>Java通用注解注入原理<br>自定义依赖注解</p><p>自动绑定<br>  模式<br>  限制和不足</p><p>题目精选</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-依赖查找</title>
      <link href="/2020/07/14/Spring-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/07/14/Spring-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><h3 id="单一类型依赖查找"><a href="#单一类型依赖查找" class="headerlink" title="单一类型依赖查找"></a>单一类型依赖查找</h3><p>JNDI - javax.naming.Context#lookup*(javax.naming.Name);<br>JavaBeans - java.beans.beancontext.BeanContext</p><ul><li>BeanFactory:<ul><li>根据bean名称查找<ul><li>getBean(String);</li><li>getBean(String,Object…) //覆盖默认参数</li></ul></li><li>根据Bean类型查找<ul><li>bean实时查找<ul><li>getBean(Class)</li><li>getBean(Class,Object…)//覆盖默认参数</li></ul></li><li>bean延时查找<ul><li>getBeanProvider(Class);</li><li>getBeanProvider(String,Class); </li></ul></li></ul></li><li>根据Bean名称和类型查找<ul><li>getBean(String,Class);</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ObjectProvider&#125; 进行依赖查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectProviderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ObjectProviderDemo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        lookupByObjectProvider(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByObjectProvider</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; objectProvider = applicationContext.getBeanProvider(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(objectProvider.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合类型依赖查找"><a href="#集合类型依赖查找" class="headerlink" title="集合类型依赖查找"></a>集合类型依赖查找</h3><p>java.beans.beancontext.BeanContext</p><h4 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h4><p>是针对某个类型去查找一个集合列表。<br>一种是查询bean的名称， 一种是查询bean的实例。<br>一般情况下应该使用bean的名称来判断当前bean是否存在，或者进一步判断BeanDefinition是否存在。<br>而查询bean实例会提早初始化bean实例，造成初始化不完整。</p><ul><li>根据Bean类型查找<ul><li>获取同类型Bean名称列表<ul><li>getBeanNamesForType(Class)</li><li>getBeanNamesForType(ResolvableType)</li></ul></li><li>获取痛类型Bean实例列表<ul><li>getBeansOfType(Class)以及重载方法</li></ul></li></ul></li><li>根据注解类型查找<ul><li>获取标注类型Bean 名称列表<ul><li>getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt;);</li></ul></li><li>获取标注类型Bean实例列表<ul><li>getBeansWithAnnotation(Class&lt;? extends Annotation&gt;);</li></ul></li><li>获取指定名称+标注类型实例<ul><li>findAnnotationOnBean(String,Class&lt;? extends Annotation&gt;);</li></ul></li></ul></li></ul><h3 id="层次性依赖查找"><a href="#层次性依赖查找" class="headerlink" title="层次性依赖查找"></a>层次性依赖查找</h3><p>java.beans.beancontext.BeanContext</p><h4 id="HierachicalBeanFactory"><a href="#HierachicalBeanFactory" class="headerlink" title="HierachicalBeanFactory"></a>HierachicalBeanFactory</h4><p><img src="/2020/07/14/Spring-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/hierarchical_class.jpg" alt></p><ul><li>双亲 BeanFactory: getParentBeanFactory();<ul><li>层次查找</li><li>根据Bean名称查找<ul><li>基于containsLocalBean方法实现   </li></ul></li><li>根据Bean类型查找实例列表<ul><li>单一类型：BeanFactoryUtils#beanOfType</li><li>集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors</li></ul></li><li>根据Java注解查找名称列表<ul><li>BeanFactoryUtils#beanNamesForTypeIncludingAncestors</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HierarchicalDependencyLookupDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();</span><br><span class="line"></span><br><span class="line">        HierarchicalBeanFactory parentBeanFactory = createParentBeanFactory();</span><br><span class="line"></span><br><span class="line">        beanFactory.setParentBeanFactory(parentBeanFactory);</span><br><span class="line"></span><br><span class="line">        displayContainsLocalBean(beanFactory, <span class="string">"user"</span>); <span class="comment">//false</span></span><br><span class="line">        displayContainsLocalBean(parentBeanFactory, <span class="string">"user"</span>); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        displayContainsBean(beanFactory, <span class="string">"user"</span>); <span class="comment">//true</span></span><br><span class="line">        displayContainsBean(parentBeanFactory,<span class="string">"user"</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayContainsBean</span><span class="params">(HierarchicalBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"当前 BeanFactory [%s] 是否包含  bean[name:%s]  %s\n"</span>, beanFactory, beanName, containsBean(beanFactory,beanName));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(HierarchicalBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line">        BeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> HierarchicalBeanFactory) &#123;</span><br><span class="line">            HierarchicalBeanFactory parentHierarchicalBeanFactory = HierarchicalBeanFactory<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">parentBeanFactory</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (containsBean(parentHierarchicalBeanFactory, beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.containsLocalBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayContainsLocalBean</span><span class="params">(HierarchicalBeanFactory parentBeanFactory, String user)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"当前 BeanFactory [%s] 是否包含 Local bean[name:%s]  %s\n"</span>, parentBeanFactory, user, parentBeanFactory.containsLocalBean(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HierarchicalBeanFactory <span class="title">createParentBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">"classpath:applicationContext-lookup.xml"</span>;</span><br><span class="line">        reader.loadBeanDefinitions(location);</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟依赖查找"><a href="#延迟依赖查找" class="headerlink" title="延迟依赖查找"></a>延迟依赖查找</h3><p><img src="/2020/07/14/Spring-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/ObjectFactory_Class.jpg" alt></p><ul><li>Bean延迟依赖查找接口<ul><li>org.springframework.beans.factory.ObjectFactory#getObject();</li><li>org.springframework.beans.factory.ObjectProvider<ul><li>Spring5对于Java8的特性扩展</li><li>函数式接口<ul><li>getIfAvailable(Supplier)</li><li>ifAvailable(Consumer)</li></ul></li><li>Stream扩展 - stream() </li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ObjectProvider&#125; 进行依赖查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectProviderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ObjectProviderDemo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        lookupByObjectProvider(applicationContext);</span><br><span class="line">        lookupIfAvailable(applicationContext);</span><br><span class="line">        lookupByStream(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByStream</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; objectProvider = applicationContext.getBeanProvider(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//        Iterator&lt;String&gt; iterator = objectProvider.iterator();</span></span><br><span class="line"><span class="comment">//        while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        objectProvider.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupIfAvailable</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectProvider = applicationContext.getBeanProvider(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = userObjectProvider.getIfAvailable(User::<span class="keyword">new</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"message"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByObjectProvider</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; objectProvider = applicationContext.getBeanProvider(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(objectProvider.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安全依赖查找"><a href="#安全依赖查找" class="headerlink" title="安全依赖查找"></a>安全依赖查找</h3><p>依赖查找安全性对比</p><table><thead><tr><th>依赖查找类型</th><th>代表实现</th><th>是否安全</th></tr></thead><tbody><tr><td>单一类型查找</td><td>BeanFactory#getBean</td><td>否</td></tr><tr><td></td><td>ObjectFactory#getObject</td><td>否</td></tr><tr><td></td><td>ObjectProvider#getIfAvailable</td><td>是</td></tr><tr><td>集合类型查找</td><td>ListableBeanFactory#getBeansOfType</td><td>是</td></tr><tr><td></td><td>ObjectProvider.stream</td><td>是</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.springframework.models.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSafetyDependencyLookupDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(TypeSafetyDependencyLookupDemo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        displayBeanFactoryGetBean(applicationContext);</span><br><span class="line">        displayObjectFactoryGetObject(applicationContext);</span><br><span class="line">        displayObjectProviderIfAvailable(applicationContext);</span><br><span class="line"></span><br><span class="line">        displayListableBeanFactoryGetBeansOfType(applicationContext);</span><br><span class="line"></span><br><span class="line">        displayObjectProviderStreamOps(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectProviderStreamOps</span><span class="params">(AnnotationConfigApplicationContext beanFactory)</span></span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectFactory = beanFactory.getBeanProvider(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        printException(<span class="string">"displayObjectProviderStreamOps"</span>, ()-&gt;userObjectFactory.forEach(System.out::println));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayListableBeanFactoryGetBeansOfType</span><span class="params">(ListableBeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        printException(<span class="string">"displayListableBeanFactoryGetBeansOfType"</span>, ()-&gt;beanFactory.getBeansOfType(User<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectProviderIfAvailable</span><span class="params">(BeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectFactory = beanFactory.getBeanProvider(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        printException(<span class="string">"displayObjectProviderIfAvailable"</span>, ()-&gt;userObjectFactory.getIfAvailable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectFactoryGetObject</span><span class="params">(BeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectFactory = beanFactory.getBeanProvider(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        printException(<span class="string">"displayObjectFactoryGetObject"</span>, ()-&gt;userObjectFactory.getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayBeanFactoryGetBean</span><span class="params">(BeanFactory beanFactory)</span></span>&#123;</span><br><span class="line">        printException(<span class="string">"displayBeanFactoryGetBean"</span>,()-&gt;beanFactory.getBean(User<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printException</span><span class="params">(String source, Runnable run)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Source From : "</span> + source);</span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            run.run();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内建可查找的依赖"><a href="#内建可查找的依赖" class="headerlink" title="内建可查找的依赖"></a>内建可查找的依赖</h3><ul><li>AbstractApplicationContext 内建可查找依赖</li></ul><table><thead><tr><th>Bean名称</th><th>Bean实例</th><th>使用场景</th></tr></thead><tbody><tr><td>environment</td><td>Environment对象</td><td>外部化配置以及Profiles</td></tr><tr><td>systemProperties</td><td>java.util.Proerties对象</td><td>Java系统属性</td></tr><tr><td>systemEnvironment</td><td>java.util.Map对象</td><td>操作系统环境变量</td></tr><tr><td>messageSource</td><td>MessageSource对象</td><td>国际化文案</td></tr><tr><td>lifecycleProcessor</td><td>LifecycleProcessor对象</td><td>LifecycleBean处理器</td></tr><tr><td>applicationEventMulticaster</td><td>ApplicationEventMulticaster对象</td><td>Spring事件广播器</td></tr></tbody></table><ul><li>注解驱动Spring上下文内建可查找的依赖</li></ul><p>AnnotationConfigUtils.</p><table><thead><tr><th>Bean名称</th><th>Bean实例</th><th>使用场景</th></tr></thead><tbody><tr><td>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</td><td>ConfigurationClassPostProcessor对象</td><td>处理Spring配置类</td></tr><tr><td>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</td><td>AutowireAnnotationBeanPostProcessor对象</td><td>处理@Autowired以及@Value注解</td></tr><tr><td>org.springframework.context.annotation.internalCommonAnnotatinProcessor</td><td>CommonAnnotationBeanPostProcessor对象</td><td>条件激活处理JSR-250注解，如@PostConstruct</td></tr><tr><td>org.springframework.context.event.internalEventListenerProcessor</td><td>EventListenerMethodProcessor对象</td><td>处理@EventListener的Spring事件监听方法</td></tr></tbody></table><h3 id="依赖查找中的异常"><a href="#依赖查找中的异常" class="headerlink" title="依赖查找中的异常"></a>依赖查找中的异常</h3><ul><li>NoSuchBeanDefinitionException</li><li>NoUniqueBeanDefinitionException</li><li>BeanInstantiationException</li><li>BeanCreationException</li><li>BeanDefinitionStoreException</li></ul><h3 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h3><ul><li>ObjectFactory 和 BeanFactory 的区别</li><li>BeanFactory.getBean 的线程安全性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 依赖查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Bean</title>
      <link href="/2020/07/14/Spring-Bean/"/>
      <url>/2020/07/14/Spring-Bean/</url>
      
        <content type="html"><![CDATA[<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><blockquote><p>A BeanDefinition describes a bean instance, which has property values,<br>Constructor arguments values, and further information supplied by concrete implementations.<br>This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor to introspect and modify property values and other bean metadata.</p></blockquote><p><img src="/2020/07/14/Spring-Bean/beandefinition_class.jpg" alt="BeanDefinition 类图"></p><p>BeanDefinition： 顶级父接口,继承了BeanMetadataElement和AttributeAccessor.</p><p>AbstractBeanDefinition：是GenericBeanDefinition、RootBeanDefinition、ChildBeanDefinition 的通用属性的完整实现。<br>GenericBeanDefinition: 标准的bean定义目的的一站式服务类.<br>RootBeanDefinition: 根Bean定义，代表合并的BeanDefinition。<br>ChildBeanDefinition: 有parent的BeanDefinition</p><p>BeanDefinition是SpringFramework中定义的配置元信息接口,包含了：</p><ul><li>Bean 的类名</li><li>Bean 的行为配置元素，如作用域、自动绑定模式、生命周期回调等</li><li>其他Bean引用，（Collaborators、Dependends)</li><li>配置设置（Bean的Properties）</li></ul><h3 id="BeanDefinition-元信息"><a href="#BeanDefinition-元信息" class="headerlink" title="BeanDefinition 元信息"></a>BeanDefinition 元信息</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Class</td><td>Bean的全限类名，必须是具体类</td></tr><tr><td>Name</td><td>Bean的名称或者🆔</td></tr><tr><td>Scope</td><td>Bean的作用域，singleton、prototype</td></tr><tr><td>Constructor arguments</td><td>Bean的构造器参数 for DI</td></tr><tr><td>Properties</td><td>Bean的属性设置 for DI</td></tr><tr><td>Autowiring Mode</td><td>Bean的自动绑定模式：ByName 、 byType</td></tr><tr><td>Lazy Initialization Mode</td><td>Bean 延迟初始化模式</td></tr><tr><td>initialzation method</td><td>Bean初始化回调方法名称</td></tr><tr><td>destruction method</td><td>Bean 销毁回调方法名称</td></tr></tbody></table><h3 id="BeanDefinition-构建"><a href="#BeanDefinition-构建" class="headerlink" title="BeanDefinition 构建"></a>BeanDefinition 构建</h3><ul><li>通过BeanDefinitionBuilder构建Beandefinition</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//bean definition builder.</span></span><br><span class="line">BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">beanDefinitionBuilder.addPropertyValue(<span class="string">"id"</span>,<span class="number">1L</span>);</span><br><span class="line">beanDefinitionBuilder.addPropertyValue(<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line"></span><br><span class="line">BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br></pre></td></tr></table></figure><ul><li>通过GenericBeanDefinition 构建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GenericBeanDefinition genericBeanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">genericBeanDefinition.setBeanClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line"><span class="comment">//        propertyValues.addPropertyValue("id",2L);</span></span><br><span class="line"><span class="comment">//        propertyValues.addPropertyValue("name","zhaowu");</span></span><br><span class="line"></span><br><span class="line">propertyValues.add(<span class="string">"id"</span>,<span class="number">2L</span>)</span><br><span class="line">        .add(<span class="string">"name"</span>,<span class="string">"zhaowu"</span>);</span><br><span class="line">genericBeanDefinition.setPropertyValues(propertyValues);</span><br></pre></td></tr></table></figure><h2 id="SpringBean-命名"><a href="#SpringBean-命名" class="headerlink" title="SpringBean 命名"></a>SpringBean 命名</h2><p>每个Bean拥有一个或者多个标识符，这些标识符在Bean所在的容器必须是唯一的。<br>通常，一个Bean仅有一个标识符，可以考虑使用别名来扩充。</p><p>在基于XML的配置元信息中，可以使用id或者name属性来规定Bean的标识符。通常Bean的标识符由字母组成，允许出现特殊字符。可以在Bean的name属性使用逗号“,”或者“;”或者空格来间隔名称做为别名。</p><p>Bean的id或者name属性如果为空，容器会为Bean自动生成一个唯一的名称。</p><h3 id="BeanNameGenerator"><a href="#BeanNameGenerator" class="headerlink" title="BeanNameGenerator"></a>BeanNameGenerator</h3><p><img src="/2020/07/14/Spring-Bean/bean_name_generator.jpg" alt="BeanNameGenerator 类图"></p><h4 id="DefaultBeanNameGenerator"><a href="#DefaultBeanNameGenerator" class="headerlink" title="DefaultBeanNameGenerator"></a>DefaultBeanNameGenerator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate a bean name for the given bean definition, unique within the</span></span><br><span class="line"><span class="comment"> * given bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definition the bean definition to generate a bean name for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean factory that the definition is going to be</span></span><br><span class="line"><span class="comment"> * registered with (to check for existing bean names)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isInnerBean whether the given bean definition will be registered</span></span><br><span class="line"><span class="comment"> * as inner bean or as top-level bean (allowing for special name generation</span></span><br><span class="line"><span class="comment"> * for inner beans versus top-level beans)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the generated bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException if no unique name can be generated</span></span><br><span class="line"><span class="comment"> * for the given bean definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">    <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            generatedBeanName = definition.getParentName() + <span class="string">"$child"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            generatedBeanName = definition.getFactoryBeanName() + <span class="string">"$created"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(generatedBeanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unnamed bean definition specifies neither "</span> +</span><br><span class="line">                <span class="string">"'class' nor 'parent' nor 'factory-bean' - can't generate bean name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String id = generatedBeanName;</span><br><span class="line">    <span class="keyword">if</span> (isInnerBean) &#123;</span><br><span class="line">        <span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Top-level bean: use plain class name with unique suffix if necessary.</span></span><br><span class="line">        <span class="keyword">return</span> uniqueBeanName(generatedBeanName, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可以看出， 首先获取BeanClassName, BeanClassName 为空时，获取ParentName，ParentName为空时获取FactoryBeanName， 当三者都为空的时候名称是无法创建的。 三者不为空时生成的名称前缀为：<br>BeanClassName<br>ParentName$child<br>FactoryBeanName$created</p><p>在生成名字时，如果是内部类， 则生成名字为前缀+#+当前beanDefinition的hashCode， 如下：<br>BeanClassName#hashCode<br>ParentName$child#hashCode<br>FactoryBeanName$created#hashCode</p><p>如果不是内部类， 则调用uniqueBeanName生成唯一的BeanName，格式为 + “#” + 序号。</p><p>BeanClassName#1<br>ParentName$child#1<br>FactoryBeanName$created#1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Turn the given bean name into a unique bean name for the given bean factory,</span></span><br><span class="line"><span class="comment"> * appending a unique counter as suffix if necessary.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the original bean name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the bean factory that the definition is going to be</span></span><br><span class="line"><span class="comment"> * registered with (to check for existing bean names)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the unique bean name to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uniqueBeanName</span><span class="params">(String beanName, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    String id = beanName;</span><br><span class="line">    <span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">    <span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        id = beanName + GENERATED_BEAN_NAME_SEPARATOR + counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AnnotationBeanNameGeneritor"><a href="#AnnotationBeanNameGeneritor" class="headerlink" title="AnnotationBeanNameGeneritor"></a>AnnotationBeanNameGeneritor</h4><p>先判断是否为AnnotatedBeanDefinition, 优先按照AnnotationBeanDefinition配置的Value获取，如果没有配置，则按照缺省的方式来生成beanName(如果是mypackage.MyJdbcDao 则生成 myJdbcDao)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Explicit bean name found.</span></span><br><span class="line">            <span class="keyword">return</span> beanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Derive a default bean name from the given bean definition.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation simply builds a decapitalized version</span></span><br><span class="line"><span class="comment"> * of the short class name: e.g. "mypackage.MyJdbcDao" -&gt; "myJdbcDao".</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that inner classes will thus have names of the form</span></span><br><span class="line"><span class="comment"> * "outerClassName.InnerClassName", which because of the period in the</span></span><br><span class="line"><span class="comment"> * name may be an issue if you are autowiring by name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definition the bean definition to build a bean name for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the default bean name (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    String beanClassName = definition.getBeanClassName();</span><br><span class="line">    Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">"No bean class name set"</span>);</span><br><span class="line">    String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanDefinition-配置"><a href="#BeanDefinition-配置" class="headerlink" title="BeanDefinition 配置"></a>BeanDefinition 配置</h3><h4 id="Xml"><a href="#Xml" class="headerlink" title="Xml"></a>Xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.github.springframework.models.User"</span> <span class="attr">primary</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"superUser"</span> <span class="attr">class</span>=<span class="string">"com.github.springframework.models.SuperUser"</span> <span class="attr">parent</span>=<span class="string">"user"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addr"</span> <span class="attr">value</span>=<span class="string">"上海"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"objectFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetBeanName"</span> <span class="attr">value</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Java注解-Bean"><a href="#Java注解-Bean" class="headerlink" title="Java注解 @Bean"></a>Java注解 @Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanDefinitionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//create factory bean</span></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//register config class.</span></span><br><span class="line">        applicationContext.register(Config<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//refresh</span></span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getUser</span></span><br><span class="line">        System.out.println(applicationContext.getBean(User<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(<span class="number">1L</span>);</span><br><span class="line">            user.setName(<span class="string">"Ann: zhangsan"</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java注解-Component"><a href="#Java注解-Component" class="headerlink" title="Java注解 @Component"></a>Java注解 @Component</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanDefinitionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//create factory bean</span></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//register config class.</span></span><br><span class="line">        applicationContext.register(Config<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//refresh</span></span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(applicationContext.getBean(Config<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(<span class="number">1L</span>);</span><br><span class="line">            user.setName(<span class="string">"Ann: zhangsan"</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanDefinition注册到容器"><a href="#BeanDefinition注册到容器" class="headerlink" title="BeanDefinition注册到容器"></a>BeanDefinition注册到容器</h2><p>BeanDefinitionRegistry 提供了 BeanDefinition 的注册、删除，获取，判断是否存在等功能。</p><p><img src="/2020/07/14/Spring-Bean/BeanDefinition_class_diagram.jpg" alt="BeanDefinitionRegistry 类图1"></p><p><img src="/2020/07/14/Spring-Bean/BeanDefinitionRegistry_Class.jpg" alt="BeanDefinitionRegistry 类图2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry, String name)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanDefinitionBuilder.addPropertyValue(<span class="string">"id"</span>, <span class="number">1L</span>)</span><br><span class="line">            .addPropertyValue(<span class="string">"name"</span>, <span class="string">"Reg: zhangsan"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(name)) &#123;</span><br><span class="line">        registry.registerBeanDefinition(name, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(),registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于AnnotatinoConfigApplicationContext 是 BeanDefinitionRegistry的间接子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">applicationContext.register(Config<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">beanDefinitionRegistry(applicationContext,<span class="string">"REG:ZhangSan:Name"</span>);</span><br><span class="line">beanDefinitionRegistry(applicationContext,<span class="keyword">null</span>);</span><br><span class="line">applicationContext.refresh();</span><br><span class="line">System.out.println(applicationContext.getBeansOfType(Config<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">System.out.println(applicationContext.getBeansOfType(User<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">System.out.println(applicationContext.getBeansOfType(AnnotationApplicationContextDemo<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure><h2 id="Bean-实例化"><a href="#Bean-实例化" class="headerlink" title="Bean 实例化"></a>Bean 实例化</h2><p>常规：</p><ul><li><p>通过构造器（配置元信息：XML、Java注解、JavaAPI）</p></li><li><p>静态工厂方法（配置元信息：XML、JavaAPI）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user-by-static-method"</span> <span class="attr">class</span>=<span class="string">"com.github.spring.beans.User2"</span>  <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/META-INF/bean-creation-context.xml"</span>);</span><br><span class="line"></span><br><span class="line">User2 user = applicationContext.getBean(<span class="string">"user-by-static-method"</span>, User2<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>Bean工厂方法（配置元信息：XML、JavaAPI）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> User2 <span class="title">createuser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultUserFactory</span> <span class="keyword">implements</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userFactory"</span> <span class="attr">class</span>=<span class="string">"com.github.spring.factory.DefaultUserFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user-by-instance-method"</span> <span class="attr">factory-bean</span>=<span class="string">"userFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createuser"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/META-INF/bean-creation-context.xml"</span>);</span><br><span class="line">User2 user3 = applicationContext.getBean(<span class="string">"user-by-instance-method"</span>, User2<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>FactoryBean（XML、Java注解、JavaAPI）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">User2</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User2 <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User2<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user-by-factory-bean"</span> <span class="attr">class</span>=<span class="string">"com.github.spring.factory.UserFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/META-INF/bean-creation-context.xml"</span>);</span><br><span class="line">User2 user2 = applicationContext.getBean(<span class="string">"user-by-factory-method"</span>, User2<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>特殊方式：</p><ul><li>ServiceLoaderFactoryBean</li></ul><p>Java ServiceLoader: 会在classpath:/META-INF/services下加载接口配置文件：</p><p>文件名名称为全限定接口名称，内容为全限定实现类</p><p><img src="/2020/07/14/Spring-Bean/service-loader.jpg" alt="services 配置文件"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.github.spring.factory.DefaultUserFactory</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demoServiceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceLoader&lt;UserFactory&gt; serviceLoader = ServiceLoader.load(UserFactory<span class="class">.<span class="keyword">class</span>, <span class="title">Thread</span>.<span class="title">currentThread</span>().<span class="title">getContextClassLoader</span>())</span>;</span><br><span class="line">    displayServiceLoad(serviceLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayServiceLoad</span><span class="params">(ServiceLoader&lt;UserFactory&gt; serviceLoader)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;UserFactory&gt; iterator = serviceLoader.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        UserFactory userFactory = iterator.next();</span><br><span class="line">        System.out.println(userFactory.createuser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceLoaderFactoryBean的实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userFactoryServiceLoader"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceType"</span> <span class="attr">value</span>=<span class="string">"com.github.spring.factory.UserFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/META-INF/sp-bean-creation-context.xml"</span>);</span><br><span class="line">ServiceLoader&lt;UserFactory&gt; serviceLoader = applicationContext.getBean(<span class="string">"userFactoryServiceLoader"</span>, ServiceLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">displayServiceLoad(serviceLoader);</span><br></pre></td></tr></table></figure><ul><li>AutowireCapableBeanFactory#createBean(java.lang.Class,int, boolean);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AutowireCapableBeanFactory beanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">UserFactory userFactory = beanFactory.createBean(DefaultUserFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(userFactory.createuser());</span><br></pre></td></tr></table></figure><ul><li>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition);</li></ul><h2 id="Bean的初始化"><a href="#Bean的初始化" class="headerlink" title="Bean的初始化"></a>Bean的初始化</h2><ul><li><p>@PostConstructor</p></li><li><p>InitializingBean 的 afterPropertiesSet</p></li><li><p>Bean的initMethod<br>@Bean(initMethod=””)</p><bean initmethod>AbstractBeanDefinition.setInitMethodName("");</bean></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultUserFactory</span> <span class="keyword">implements</span> <span class="title">UserFactory</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultUserFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DefaultUserFactory Constructor Called."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DefaultUserFactory PostConstructor Called."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DefaultUserFactory initUserFactory Called."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DefaultUserFactory afterPropertiesSet called."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInitializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanInitializationDemo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        UserFactory userFactory = applicationContext.getBean(UserFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(<span class="title">userFactory</span>.<span class="title">createuser</span>())</span>;</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"initUserFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultUserFactory <span class="title">userFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><ul><li>xml: <bean lazy-init="true"></bean></li><li>annotation: @Lazy</li></ul><p>对于延迟初始化，是在applicationContext初始化之后进行初始化。<br>非延迟初始化，是在applicationContext初始化之前进行初始化。</p><h2 id="Bean-的销毁"><a href="#Bean-的销毁" class="headerlink" title="Bean 的销毁"></a>Bean 的销毁</h2><ul><li>@PreDestroy</li><li>实现DisposableBean接口的destoy()方法</li><li>Bean的 destroy方法<bean destroy>@Bean(destroy="")AbstractBeanDefinition.setDestroyMethodName(""); </bean></li></ul><h2 id><a href="#" class="headerlink" title></a></h2><ul><li>如何注册一个Spring Bean</li></ul><p>可以通过BeanDefinition和外部单体对象来注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UserFactory userFactory = <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">ConfiguableListableBeanFactory factory = applicationContext.getBeanFactory();</span><br><span class="line">factory.registerSingleton(<span class="string">"userFactory"</span>, userFactory);</span><br><span class="line"></span><br><span class="line">UserFactory userFactory = applicationContext.getBean(<span class="string">"UserFactory"</span>,UserFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Spring BeanDefinition 是什么？</p></li><li><p>Spring 容器是如何注册Bean的？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring-Bean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2020/07/12/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/12/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享。<br>多食用细粒度的对象，以便于重用或者重构。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用共享对象可以有效地支持大量的细粒度的对象。</p><p>大量的细粒度对象，需要把对象的共有属性提取出来，做为内部状态，剩余的非共有做为外部状态。<br>内部状态：可以共享出来的信息，存储在襄垣对象内部，并且不会随着环境的改变而改变。<br>外部状态：对象得以依赖的一个标记，是随着环境的改变而改变的，不可以共享的状态。</p><p><img src="/2020/07/12/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/fly_weight.jpeg" alt="享元模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Flyweight"><a href="#Flyweight" class="headerlink" title="Flyweight"></a>Flyweight</h4><p>抽象享元角色，产品抽象类，同时定义出对象的外部状态和内部状态的接口或者实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String instrinsic; <span class="comment">//inner status</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic; <span class="comment">//external status</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String extrinsic)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.extrinsic = extrinsic;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getInstrinsic</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.instrinsic;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstrinsic</span><span class="params">(String instrinsic)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.instrinsic = instrinsic;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteFlyweight"><a href="#ConcreteFlyweight" class="headerlink" title="ConcreteFlyweight"></a>ConcreteFlyweight</h4><p>具体享元角色，实现抽象角色的定义业务，该角色中需要注意的是内部状态处理应该与环境无关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight1</span> <span class="keyword">extends</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight1</span><span class="params">(String _Extrinsic)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight2</span> <span class="keyword">extends</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight2</span><span class="params">(String _Extrinsic)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unsharConcreteFlyweight"><a href="#unsharConcreteFlyweight" class="headerlink" title="unsharConcreteFlyweight"></a>unsharConcreteFlyweight</h4><p>不可共享的享元角色</p><p>不存在外部状态或者安全要求不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。</p><h4 id="FlyweightFactory"><a href="#FlyweightFactory" class="headerlink" title="FlyweightFactory"></a>FlyweightFactory</h4><p>享元工厂，构造一个池容器，同时提供从池中获得对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Flyweight&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String extrinsic)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Flyweight flyweight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pool.containsKey(extrinsic))&#123;</span><br><span class="line">            flyweight = pool.get(extrinsic);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight1(extrinsic);</span><br><span class="line">            pool.put(extrinsic, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>可以减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>提高了程序的复杂性，需要分离出内部状态和外部状态，而且外部状态具有固话特征，不能随着内部状态的改变而改变。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>线程安全的问题<br>创建的对象尽量多，多到满足业务对象为止。</li><li>性能平衡<br>外部状态最好以基本类型为标志，如String, Int等可以大幅提升效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 享元模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>门面模式</title>
      <link href="/2020/07/11/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/11/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>门面模式也叫外观模式。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。</p><p>外观模式提供一个高层次的接口，使得子系统更易于使用。</p><p>门面模式注重要求“统一的对象”，提供一个访问子系统的接口，除了这个接口不允许任何访问子系统的行为发生。</p><p><img src="/2020/07/11/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/facade_class.jpeg" alt="外观模式"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h4><p>子系统角色，可以同时有一个或者多个子系统，每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面知识一个客户端而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//..logic a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//. logic b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//. logic c.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h4><p>门面角色，客户端可以调用这个角色的方法。这个角色知道子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统，也就是说改角色没有实际的业务逻辑，只是一个委托类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> classA a = <span class="keyword">new</span> classA();</span><br><span class="line">    <span class="keyword">private</span> classB b = <span class="keyword">new</span> classB();</span><br><span class="line">    <span class="keyword">private</span> classC c = <span class="keyword">new</span> classC();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.doSomethingA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b.doSomethingB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>减少系统的相互依赖</li><li>提高了灵活性</li><li>提高安全性</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>为一个复杂的模块或者子系统提供一个供外界访问的接口</li><li>子系统相对独立</li><li>预防低水平人员带来的风险扩散</li><li>一个子系统可以有多个门面</li><li>门面不参与子系统内的业务逻辑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 外观模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2020/07/10/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/10/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>当我们去国外旅行时，我们国内的插头不能直接插入到国外的插线板上，我们需要购买一个电源适配器来适配国外的插线板。</p><p>或者最新版的macbook pro 用的是utypec，并不能直接插入usb3.0的u盘，我们需要购买一个适配器做转换。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口编程客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><p><img src="/2020/07/10/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/adaptor_class.jpeg" alt="适配器模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>目标角色是一个接口或者抽象类，是一个已经存在的角色，不可能去修改角色中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteTarget"><a href="#ConcreteTarget" class="headerlink" title="ConcreteTarget"></a>ConcreteTarget</h4><p>具体的目标角色实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Adaptee"><a href="#Adaptee" class="headerlink" title="Adaptee"></a>Adaptee</h4><p>源角色，已经使用中的角色。需要将Adaptee转换为Target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Adaptor"><a href="#Adaptor" class="headerlink" title="Adaptor"></a>Adaptor</h4><p>适配器角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Target target = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">target.request();</span><br><span class="line"></span><br><span class="line">Target target2 = <span class="keyword">new</span> Adaptor();</span><br><span class="line">target2.request();</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>当需要把多个Adaptee转换为Target的时候，就不能使用继承了，因为Java中不支持多继承。<br>这种方式叫做对象适配器。<br>我们可以使用聚合（关联）来完成适配。</p><p><img src="/2020/07/10/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/adaptor_calss2.jpeg" alt="对象适配器类图"></p><p>类适配器是由类的继承关系完成的。<br>对象适配器是由类的关联关系纪念性耦合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2020/07/09/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/09/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥梁模式的重点在解耦。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将抽象和实现解耦，使得两者可以独立的变化。<br>它使用了类间的聚合关系、继承、覆写等常用功能。解决了继承的缺点而提出的设计模式。</p><p><img src="/2020/07/09/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/bridge_class.jpeg" alt="桥接模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。</p><h4 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h4><p>抽象化角色，定义出该抽象角色的行为，同时保存一个对实现化角色的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Implementor imp;</span><br><span class="line">    <span class="comment">//必须指定实现者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor imp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imp = imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RefindAbstraction"><a href="#RefindAbstraction" class="headerlink" title="RefindAbstraction"></a>RefindAbstraction</h4><p>修正抽象化角色，引用实现化角色对抽象化角色进行修正。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefindAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefindAbstraction</span><span class="params">(Implementor imp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">      <span class="keyword">super</span>.request();</span><br><span class="line">      <span class="keyword">super</span>.getImp().doAnyThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implementor"><a href="#Implementor" class="headerlink" title="Implementor"></a>Implementor</h4><p>实现化角色，接口或者抽象类，定义角色必须的行为和属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteImplementor"><a href="#ConcreteImplementor" class="headerlink" title="ConcreteImplementor"></a>ConcreteImplementor</h4><p>具体实现化角色，实现接口或者抽象类定义的方法和属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor1</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor2</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Implementor imp = <span class="keyword">new</span> ConcreteImplementor1();</span><br><span class="line">Abstraction abs = <span class="keyword">new</span> RefindAbstraction(imp);</span><br><span class="line">abs.request();</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>抽象和实现分离<br>为了解决继承的缺点而提出的设计模式，在该模式下，实现可以不受抽象的约束，不再绑定到固定的抽象层次上。</p></li><li><p>优秀的扩展能力</p></li></ul><p>可以随意增加抽象和实现。</p><ul><li>实现细节对客户透明</li></ul><p>由抽象层通过聚合关系完成了封装。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>不希望或者不适用使用继承的场景<br>继承层次太高，无法更细化设计颗粒等场景，需要考虑使用。</li><li>接口或者抽象类不稳定的场景<br>接口或者抽象类不稳定，经常变更时，使用桥梁模式。</li><li>重用型要求高的场景<br>设计的颗粒度粤西，被重用的可能性越大。<br>采用继承受到父类的限制，不可能出现太细的粒度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 桥接模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2020/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更加灵活。</p><p><img src="/2020/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/decorator_class.jpeg" alt="装饰器模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>Component 是一个接口或者抽象类，定义需要被装饰的原始类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Concrete-Component"><a href="#Concrete-Component" class="headerlink" title="Concrete Component"></a>Concrete Component</h4><p>Component 的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><p>抽象类，用于实现接口或者抽象方法。包含被修饰的Componnet属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Component component = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Concrete-Decorator"><a href="#Concrete-Decorator" class="headerlink" title="Concrete Decorator"></a>Concrete Decorator</h4><p>具体装饰角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator1</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.method1();</span><br><span class="line">       <span class="keyword">super</span>.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator2</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator2</span><span class="params">(Component component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.operate();</span><br><span class="line">       <span class="keyword">this</span>.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Component c = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">c = <span class="keyword">new</span> ConcreteDecorator1(c);</span><br><span class="line">c = <span class="keyword">new</span> ConcreteDecorator2(c);</span><br><span class="line">c.operate();</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>装饰类和被装饰类可以独立发展，而不会相互耦合。<br>装饰模式是继承关系的一个替代方案。<br>装饰模式可以动态地扩展一个实现类的功能。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>当装饰多层时导致系统复杂度高。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2020/07/07/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/07/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式也叫发布订阅模式。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并且被自动更新。</p><p><img src="/2020/07/07/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/observer_class.jpeg" alt="观察者模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p>定义被观察者必须实现的职责，必须能够动态的增加、取消观察者。<br>它一般是抽象类或者实现类，仅仅完成作为被观察者必须实现的职责，管理观察者并通知观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obsVector = <span class="keyword">new</span> Vector&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obsVector.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obsVector.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer o : <span class="keyword">this</span>.obsVector)&#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteSubject"><a href="#ConcreteSubject" class="headerlink" title="ConcreteSubject"></a>ConcreteSubject</h4><p>具体的被观察者，定义被观察者自己的业务，同时定义对哪些事件进行通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>观察者接收到消息后，对接收到的信息进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteObserver"><a href="#ConcreteObserver" class="headerlink" title="ConcreteObserver"></a>ConcreteObserver</h4><p>具体的观察者，不同的观察者在处理消息的时候的具体定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something when invoked.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">Observer obs = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">subject.addObserver(obs);</span><br><span class="line">subject.doBusiness();</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>观察者和被观察之间是抽象耦合<br>如论增加观察者还是被观察者都非常容易扩展</li><li>建立了一套规则的触发机制</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>效率缺陷，考虑采用异步方式通知。</p><p>广播链的问题 A -&gt; B -&gt; C</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="Java中的观察者"><a href="#Java中的观察者" class="headerlink" title="Java中的观察者"></a>Java中的观察者</h4><p>java 提供了java.util.Observer接口 和 java.util.Observable 类。<br>被观察者继承java.util.Observable， 观察者实现java.util.Observer.<br>但是在生产环境中考虑到性能一般不会用这种方式来实现。</p><h4 id="生产中的观察者"><a href="#生产中的观察者" class="headerlink" title="生产中的观察者"></a>生产中的观察者</h4><p>一般使用MQ来异步处理<br>本地的如Disruptor</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC And DI</title>
      <link href="/2020/07/06/Spring-IOC-And-DI/"/>
      <url>/2020/07/06/Spring-IOC-And-DI/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-简史"><a href="#IOC-简史" class="headerlink" title="IOC 简史"></a>IOC 简史</h2><ul><li>1983年，Richard E.Sweet 在&lt;<The mesa programming enviroment>&gt;提出好莱坞原则（“不要打电话给我，我会打电话给你”）。</The></li><li>1988年，Rolph E.Johnson 和Brian Foote在《Designing Reusable Classes》中提出控制反转。</li><li>1996年，Michael Mattson在《Object-Oriented Frameworks, A survey of methodological issues》将控制反转命名为好莱坞原则。</li><li>2004，Martin Fowler在《Inversion Of Control Containers and the Dependency Injection pattern》提出自己对和IOC和DI的理解</li><li>2005年，Martin Folower在《Inversion Of Control》中对IOC进一步说明。</li><li><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Martin 大爷关于IOC的说明</a></li></ul><h2 id="IOC-的实现策略"><a href="#IOC-的实现策略" class="headerlink" title="IOC 的实现策略"></a>IOC 的实现策略</h2><p>WIKI:</p><p> In object-oriented programming, there are several basic techniques to implement inversion of control. there are:</p><ul><li>Using a service locator pattern</li><li>Using dependency injection<ul><li>constructor  injection</li><li>parameter injection</li><li>setter injection</li><li>interface injection</li></ul></li><li>Using a contextualized lookup.</li><li>Using template method design pattern</li><li>Using Strategy design pattern.</li></ul><p>EXPERT ONE-ON-ONE J2EE DEVELOPMENT without EJB提到的策略：</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/2020/07/06/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/06/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>主要为了降低模块内部之间类的相互引用，防止出现系统或者模块内部过度耦合。</p><p>中介者模式也叫调停者模式，一个对象要和N个对象交流特别混乱，这个时候加入一个中心，所有的类都和中心交流，这样就变成了星型拓扑结构。</p><p><img src="/2020/07/06/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/star_class.jpeg" alt="星型拓扑结构"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用一个中介对象封装一些列的对象交互，中介者使各对象不需要显示地相互调用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><img src="/2020/07/06/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/mediator_class.jpeg" alt="中介者模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h4><p>抽象中介者角色，定义统一的接口，用于各同事角色之间的通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague1 c1;</span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleague2 c2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcreteColleague1 <span class="title">getC1</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c1;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcreteColleague2 <span class="title">getC2</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c2;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC1</span><span class="params">(ConcreteColleague1 c1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c1 = c1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC2</span><span class="params">(ConcreteColleague2 c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c2 = c2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Concrete-Mediator"><a href="#Concrete-Mediator" class="headerlink" title="Concrete Mediator"></a>Concrete Mediator</h4><p>具体中介者角色通过协调各同事角色实现协作行为，因为它必须依赖于各个同事角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.c1.selfMethod1();</span><br><span class="line">        <span class="keyword">super</span>.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Colleague"><a href="#Colleague" class="headerlink" title="Colleague"></a>Colleague</h4><p>同事角色，每个同事角色都知道中介者角色，而且与其他同事角色通信时，一定要通过中介者角色协作。<br>一种是同事本身的行为叫自发行为，比如改变对象本身的状态，处理自己的行为，与其他同事类或者中介者<br>第二种是依赖行为，必须依赖中介者才能完成的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague2</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>减少类之间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，同时降低了类之间的耦合。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>中介者模式的缺点是中介者会膨胀，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="机场调度中心"><a href="#机场调度中心" class="headerlink" title="机场调度中心"></a>机场调度中心</h4><p>每一架飞机都和机场调度中心保持联系。</p><h4 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h4><p>Controller做为一个中介者，把Model和View隔离开，协调MV协同工作，把M运行的结果和V代表的视图融合成一个前端可以展示的页面，减少MV的依赖关系。</p><h4 id="媒体网关"><a href="#媒体网关" class="headerlink" title="媒体网关"></a>媒体网关</h4><h4 id="中介服务"><a href="#中介服务" class="headerlink" title="中介服务"></a>中介服务</h4>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 中介者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空对象模式</title>
      <link href="/2020/07/06/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/06/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>空对象模式时通过空代码实现一个接口或者抽象类的所有方法，以满足开发需求，简化程序。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过实现一个默认无意义的对象来避免null值的出现。为了避免程序中出现判断null的情况而产生的。</p><p><img src="/2020/07/06/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/null_Object" alt="空对象模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wang..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullAnimal</span> <span class="title">import</span>  <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 解释器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/2020/07/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式是一种按照规定语法进行解析的方案。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给一门语言，定义它的文法的一种表示，并且定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><p>比如Java语言，定义文法的表示是Java的语法。<br>javac编译器看作是解释器，解释器用来将Java“解释为” .class 格式的文件。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="AbstractExpression"><a href="#AbstractExpression" class="headerlink" title="AbstractExpression"></a>AbstractExpression</h4><p>抽象解释器，抽象解释器通常只有一个方法， 是生成语法集合的关键，每个语法集合完成指定语法的解析任务，通过递归调用的方式，最终由最小的语法但愿进行解析完成。<br>具体的解释任务由各个实现类完成。具体的解释器分别由TerminalExpression和Non-terminalExpression完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析公式和数值，其中var中的key是公式中的参数，value值是具体的数字。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String,Integer&gt; <span class="keyword">var</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TerminalExpression"><a href="#TerminalExpression" class="headerlink" title="TerminalExpression"></a>TerminalExpression</h4><p>终结符表达式<br>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符的表达式，但是有多个实例，对应不同的终结符。表达式中每个终结符都在栈中产生了一个varExpression。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VarExpression</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.get(<span class="keyword">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NoneTerminalExpression"><a href="#NoneTerminalExpression" class="headerlink" title="NoneTerminalExpression"></a>NoneTerminalExpression</h4><p>非终结符表达式<br>文法中每条规则都对应一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类，非终结表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  Expression left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>  Expression right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SymbolExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) + <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) - <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>环境角色，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String expStr)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = expStr.toCharArray();</span><br><span class="line"></span><br><span class="line">        Expression left = <span class="keyword">null</span>;</span><br><span class="line">        Expression right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (charArray[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    left = stack.pop();</span><br><span class="line">                    right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));</span><br><span class="line">                    stack.push(<span class="keyword">new</span> AddExpression(left, right));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    left = stack.pop();</span><br><span class="line">                    right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));</span><br><span class="line">                    stack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(<span class="keyword">new</span> VarExpression(String.valueOf(charArray[i])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.expression = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.expression.interpreter(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String expStr = getExpStr();</span><br><span class="line">    HashMap&lt;String, Integer&gt; <span class="keyword">var</span> = getValue(expStr);</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator(expStr);</span><br><span class="line">    System.out.println(calculator.run(<span class="keyword">var</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getValue</span><span class="params">(String expStr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : expStr.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'+'</span> &amp; c != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(String.valueOf(c))) &#123;</span><br><span class="line">                String in = (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">                map.put(String.valueOf(c), Integer.valueOf(in));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getExpStr</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Input Expression"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>扩展性良好，修改语法规则只需要修改相应的非终结符表达式就可以了。<br>如果扩展语法，则只要增加非终结符类就可以了。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>解释器模式会引起类膨胀，每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可以能产生大量的类文件。<br>解释器模式采用递归调用方式，每个表达式需要知道最终的结果，必须一层层递归，无论是面向对象还是面向过程，递归都是在必要条件下才使用，导致调试复杂。</p><p>效率问题，解释器模式使用大量的循环和递归，效率时一个很大的问题。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>重复发生的问题可以解释器模式，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素相同，按照解释器模式终结符表达式相同，非终结符表达式需要定制。</p><p>一个简单语法需要解释的场景，解释器模式一般用来解析表标准的字符集，如SQL语法分析。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>尽量不要在重要的模块中使用解释器模式，维护成本太高。尽量使用shell、JRuby、Groovy来替代。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>成熟的工具<br>Expression4J<br>MESP: Math Expression String Parser、<br>Jep.</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 解释器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2020/07/04/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/04/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该状态之外保存这个状态。<br>这样以后就可以将该状态恢复到原来保存的状态。</p><p><img src="/2020/07/04/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/memento.jpeg" alt="备忘录模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Originator"><a href="#Originator" class="headerlink" title="Originator"></a>Originator</h4><p>发起人角色，记录当前时刻的内部状态，负责定义哪些属性备份范围的状态，负责创建和恢复备忘录数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">" I Am So Sad."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以创建多个备份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以选择任意的备份进行恢复</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memento</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(memento.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h4><p>备忘录角色，负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Caretaker"><a href="#Caretaker" class="headerlink" title="Caretaker"></a>Caretaker</h4><p>备忘录管理员角色，对备忘录进行管理、保存和提供备忘录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">caretaker.setMemento(boy.createMemento());</span><br><span class="line">System.out.println(<span class="string">"Now Boy Is : "</span> + boy.getState());</span><br><span class="line"></span><br><span class="line">boy.change();</span><br><span class="line">System.out.println(<span class="string">"Now Boy Is : "</span> + boy.getState());</span><br><span class="line"></span><br><span class="line">boy.restore(caretaker.getMemento());</span><br><span class="line">System.out.println(<span class="string">"Now Boy Is : "</span> + boy.getState());</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要保存和恢复数据的相关状态场景</li><li>提供一个可回滚的操作 </li><li>需要监控的副本场景中</li><li>数据库连接的事务管理</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>备忘录的生命周期<br>主动管理备忘录的生命周期，不实用就需要立即删除其引用。</li><li>备忘录的性能<br>要控制备忘录的历史记录数量，以及大对象的备忘录。</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="Clone方式的备忘录"><a href="#Clone方式的备忘录" class="headerlink" title="Clone方式的备忘录"></a>Clone方式的备忘录</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Originator <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Originator originator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Originator <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Originator)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Originator originator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Originator <span class="title">getOriginator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOriginator</span><span class="params">(Originator originator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.originator = originator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多状态的备忘录模式"><a href="#多状态的备忘录模式" class="headerlink" title="多状态的备忘录模式"></a>多状态的备忘录模式</h4><p>把整个对象转换成Map，当然也可以序列化、或者直接复制整个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,Object&gt; stateMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(HashMap&lt;String, Object&gt; stateMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stateMap = stateMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title">getStateMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateMap</span><span class="params">(HashMap&lt;String, Object&gt; stateMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stateMap = stateMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Object&gt; <span class="title">backupProp</span><span class="params">(Object bean)</span></span>&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());</span><br><span class="line">            PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor descriptor : descriptors) &#123;</span><br><span class="line">                String fieldName = descriptor.getName();</span><br><span class="line">                Method getter = descriptor.getReadMethod();</span><br><span class="line">                Object fieldValue = getter.invoke(bean, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">                <span class="keyword">if</span> (!fieldName.equalsIgnoreCase(<span class="string">"class"</span>))&#123;</span><br><span class="line">                    result.put(fieldName, fieldValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreProp</span><span class="params">(Object bean, HashMap&lt;String,Object&gt; propMap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());</span><br><span class="line">            PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor descriptor : descriptors) &#123;</span><br><span class="line">                String fieldName = descriptor.getName();</span><br><span class="line">                <span class="keyword">if</span> (propMap.containsKey(fieldName))&#123;</span><br><span class="line">                    Method setter  = descriptor.getWriteMethod();</span><br><span class="line">                    setter.invoke(bean, <span class="keyword">new</span> Object[]&#123;propMap.get(fieldName)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state1 = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> String state2 = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> String state3 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState1</span><span class="params">(String state1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state1 = state1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState2</span><span class="params">(String state2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state2 = state2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState3</span><span class="params">(String state3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state3 = state3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(BeanUtils.backupProp(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        BeanUtils.restoreProp(<span class="keyword">this</span>, memento.getStateMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多备份的备忘录"><a href="#多备份的备忘录" class="headerlink" title="多备份的备忘录"></a>多备份的备忘录</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Memento&gt; map =  <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backup</span><span class="params">(String version, Memento memento)</span></span>&#123;</span><br><span class="line">        map.put(version, memento);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(String version)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> map.get(version);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Memento&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优雅的实现"><a href="#优雅的实现" class="headerlink" title="优雅的实现"></a>优雅的实现</h3><p>Bean 对象专注自己的业务，不需要关心备份和恢复业务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Original</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备份管理员负责版本的备份与恢复工作，职责明晰。<br>同时要注意历史版本次数，防止版本过多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretacker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Original&gt; histo = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backup</span><span class="params">(String key, Original o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (histo.size() &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            histo.put(key,(Original) o.clone() );</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Original <span class="title">get</span><span class="params">(String k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> histo.get(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 总览</title>
      <link href="/2020/07/03/Spring-%E6%80%BB%E8%A7%88/"/>
      <url>/2020/07/03/Spring-%E6%80%BB%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring相关内容来源于Spring官方网站与Spring源码。</p></blockquote><p><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">Spring 5.2.7</a></p><p>Spring框架为企业级应用提供了一个完整的配置开发模型，可以在任何类型的发布平台。<br>Spring专注于企业应用的管道，保证开发团队专注于企业的业务逻辑，而不需要关注发布平台。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h4><ul><li><a href="/2020/07/06/Spring-IOC-And-DI/">Dependency Injection依赖注入</a></li><li>events 事件</li><li>resources 资源管理</li><li>i18n 国际化</li><li>validation 校验</li><li>data binding 数据绑定</li><li>type conversion 类型转换</li><li>SpEL </li><li>AOP Aspect Oriented Programming 面向切面编程</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>Mock Objects: 模拟对象</li><li>TestContext framework: 测试上下文框架</li><li>Spring MVC Test: MVC测试框架</li><li>WebTestClient: web测试客户端</li></ul><h4 id="DataAccess"><a href="#DataAccess" class="headerlink" title="DataAccess"></a>DataAccess</h4><ul><li>transactions: 事务</li><li>DAO Support: DAO 支持</li><li>JDBC:</li><li>ORM：</li><li>Marshalling XML</li></ul><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><h4 id="Spring-WebFlux"><a href="#Spring-WebFlux" class="headerlink" title="Spring WebFlux"></a>Spring WebFlux</h4><h4 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h4><ul><li>remoting</li><li>JMS</li><li>JCA</li><li>JMX</li><li>email</li><li>tasks</li><li>scheduling</li><li>cache</li></ul><h4 id="Languages"><a href="#Languages" class="headerlink" title="Languages"></a>Languages</h4><ul><li>Kotlin</li><li>Groovy</li><li>dynamic languages.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2020/07/03/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/03/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式的封装性非常好，把请求方（Invoker）和执行方（Receiver）分开，扩展性也非常好。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将一个请求封装成一个对象，从而使得不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><p><img src="/2020/07/03/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/command_diagram.jpeg" alt="命令模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h4><p>抽象接收者，定义每个接收者都必须完成的业务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的Receiver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concrete1Reveiver</span> <span class="keyword">extends</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concrete2Reveiver</span> <span class="keyword">extends</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><p>不同的命令实现都需要继承该类，实现自己的execute逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的命令实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">extends</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand1</span><span class="params">(Receiver receiver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">extends</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand2</span><span class="params">(Receiver receiver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">invoker.setCommand(<span class="keyword">new</span> ConcreteCommand1(<span class="keyword">new</span> Concrete1Reveiver()));</span><br><span class="line">invoker.action();</span><br></pre></td></tr></table></figure><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>解耦<br>调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法即可，不需要了解是哪个接收者执行。</li><li>可扩展性好<br>Command子类可以非常容易的扩展，调用者Invoker和高层的模块Client不产生严重的代码耦合。</li><li>与其他模式混合使用<br>与责任链模式结合，实现命令族解析任务<br>与模版方法结合，减少Command子类膨胀的问题。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Command的子类会随着命令的增多逐步膨胀。</p><h3 id="命令的撤销"><a href="#命令的撤销" class="headerlink" title="命令的撤销"></a>命令的撤销</h3><h4 id="反命令"><a href="#反命令" class="headerlink" title="反命令"></a>反命令</h4><p>通过相反的命令来实现命令的撤销。</p><h4 id="结合备忘录模式"><a href="#结合备忘录模式" class="headerlink" title="结合备忘录模式"></a>结合备忘录模式</h4><p>结合备忘录模式还原最后状态，折中发昂发适合接收者为状态的变更情况，而不适合事件处理。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>假设有个录音机，录音机面板有三个按钮， play， rewind， stop。</p><p>需要根据三个按钮作出相应的反馈。</p><h3 id="Receiver-1"><a href="#Receiver-1" class="headerlink" title="Receiver"></a>Receiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Play"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rewind"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Command-1"><a href="#Command-1" class="headerlink" title="Command"></a>Command</h3><p>不同的Command调用不同的Receiver命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.audioPlayer.paly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewindCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioPlayer.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioPlayer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Invoker-1"><a href="#Invoker-1" class="headerlink" title="Invoker"></a>Invoker</h3><p>用于转发Command</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyPad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Use-1"><a href="#Use-1" class="headerlink" title="Use"></a>Use</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KeyPad keyPad = <span class="keyword">new</span> KeyPad();</span><br><span class="line"></span><br><span class="line">keyPad.setCommand(<span class="keyword">new</span> RewindCommand());</span><br><span class="line">keyPad.action();</span><br><span class="line"></span><br><span class="line">keyPad.setCommand(<span class="keyword">new</span> StopCommand());</span><br><span class="line">keyPad.action();</span><br></pre></td></tr></table></figure><p>如果后期需要增加一个按钮，stopAndRewind()，直接增加一个Command子类即可，其他地方不需要动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopAndRewindCommand</span> <span class="keyword">extends</span>  <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioPlayer.stop();</span><br><span class="line">        audioPlayer.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版方法模式</title>
      <link href="/2020/07/02/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/02/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>抽象类定义一组方法的执行顺序，具体的功能由子类来实现。<br>它仅仅使用了Java的继承机制，但使用非常广泛。<br>一般多个子类有公有的方法，并且逻辑基本相同的时候使用。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法框架，再将一些步骤延迟到子类中。使得子类可以不改变算法的结构就可以定义该算法的某些特定步骤。</p><p><img src="/2020/07/02/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/template_method_class.jpeg" alt="模版方法模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>一些基本的操作，由子类实现具体的逻辑，在模版方法中被调用。</p><h4 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h4><p>模版方法可以有一个或者多个，一般是一个具体的方法，包含了基本方法的调用逻辑。</p><p>抽象模版类中包含了一个模版方法goToSchool和三个基本方法toSchool, study, goHome.<br>这样，每个学生继承该抽象类实现自己逻辑即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentBehavor</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">toSchool</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToSchool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//do something.</span></span><br><span class="line">       toSchool();</span><br><span class="line">       <span class="comment">// do something.</span></span><br><span class="line">       study();</span><br><span class="line">       <span class="comment">// do something.</span></span><br><span class="line">       goHome();</span><br><span class="line">       <span class="comment">// do something.</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>封装不变部分，扩展可变部分<br>把认为不变的部分算法封装到父类实现，可变部分通过继承来扩展。</p></li><li><p>提取公共部分代码，便于维护</p></li><li><p>行为由父类控制，子类实现<br>基本方法由子类实现，子类可以扩展增加相应的功能，符合开闭原则。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>在复杂的项目中，增加代码的阅读难度。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 模版方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2020/07/02/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/02/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式的核心在链上， 链是有多个处理者组成的。就像流水线上的质检员。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的关系。<br>将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><p><img src="/2020/07/02/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/chain_class.jpg" alt="责任链模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="抽象事件"><a href="#抽象事件" class="headerlink" title="抽象事件"></a>抽象事件</h4><p>抽象事件类型表明这类型的事件是需要被处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体的事件"><a href="#具体的事件" class="headerlink" title="具体的事件"></a>具体的事件</h4><p>不同类型的子类事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventClick</span> <span class="keyword">implements</span> <span class="title">IEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventEnter</span> <span class="keyword">implements</span> <span class="title">IEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBlank</span> <span class="keyword">implements</span> <span class="title">IEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象的事件处理器"><a href="#抽象的事件处理器" class="headerlink" title="抽象的事件处理器"></a>抽象的事件处理器</h4><p>定义了只有Ievent类型的事件会被处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEventHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(IEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体的事件处理器"><a href="#具体的事件处理器" class="headerlink" title="具体的事件处理器"></a>具体的事件处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickEventHandler</span> <span class="keyword">implements</span> <span class="title">IEventHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(IEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType() != <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Father check Ok. "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnterEventHandler</span> <span class="keyword">implements</span> <span class="title">IEventHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(IEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType() == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Husband Ok."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankEventHandler</span> <span class="keyword">implements</span> <span class="title">IEventHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(IEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType() != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Son Ok"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件处理链"><a href="#事件处理链" class="headerlink" title="事件处理链"></a>事件处理链</h4><p>用于组织事件处理器，符合条件的处理器处理完成后或者没有处理器处理都会停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IEventHandler&gt; eventChains = <span class="keyword">new</span> ArrayList&lt;IEventHandler&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(IEventHandler eventHandler)</span> </span>&#123;</span><br><span class="line">        eventChains.add(eventHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(IEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IEventHandler eventChain : <span class="keyword">this</span>.eventChains) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventChain.check(event)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><p>可以随意组织责任链的顺序，然后检查需要检查的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventHandlerChain chain = <span class="keyword">new</span> EventHandlerChain();</span><br><span class="line">chain.add(<span class="keyword">new</span> ClickEventHandler());</span><br><span class="line">chain.add(<span class="keyword">new</span> EnterEventHandler());</span><br><span class="line">chain.add(<span class="keyword">new</span> BlankEventHandler());</span><br><span class="line"></span><br><span class="line">chain.check(<span class="keyword">new</span> EventClick());</span><br><span class="line">chain.check(<span class="keyword">new</span> EventEnter());</span><br><span class="line">chain.check(<span class="keyword">new</span> EventBlank());</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>将请求和处理分开。请求着可以不用知道是谁处理的，处理者可以不用知道请求着的全貌。<br>两者解耦，提高了系统的灵活性。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>性能问题， 最差的情况下，请求从头遍历到尾，链条特别长的时候，性能损耗是个大的问题。<br>因此在使用的过程中要注意责任链的长短。<br>调试不方便。</p><p>在广告系统中，由不同的事件来触发不同类型的广告时根据责任链模式来处理。<br>每个Handler可以专注自己的业务处理逻辑。具体Handler还可以抽象一个抽象类，把公用的逻辑写在抽象类里面，每个具体的实现类只负责业务的处理即可（优化为模版方法模式）。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2020/07/01/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/01/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式提供了遍历容器的方便性，容器只要管理增减元素即可，需要遍历的时候交由迭代器进行。</p><p>比如Set、Map、List等容器的iterator。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>迭代器是为容器服务的，它提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。</p><p><img src="/2020/07/01/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/iterator_class.jpeg" alt="迭代器模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>抽象迭代器负责定义访问和遍历元素的接口。<br>first() 获取第一个元素；<br>next() 访问下一个元素；<br>hasNext() 是否还有下一个；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteIterator"><a href="#ConcreteIterator" class="headerlink" title="ConcreteIterator"></a>ConcreteIterator</h4><p>具体迭代器要实现迭代器接口，完成容器元素的遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;E&gt; v = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(Vector _vector)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = _vector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cursor != <span class="keyword">this</span>.v.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hasNext() ? <span class="keyword">this</span>.v.get(<span class="keyword">this</span>.cursor++) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v.remove(<span class="keyword">this</span>.cursor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h4><p>抽象容器角色负责提供创建具体迭代器角色的接口， 必然提供一个类似于createIterator（）的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Concrete-Aggregate"><a href="#Concrete-Aggregate" class="headerlink" title="Concrete Aggregate"></a>Concrete Aggregate</h4><p>具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggrate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;&gt;(<span class="keyword">this</span>.v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 迭代器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2020/07/01/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/01/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>也叫合成模式或者部分整体模式，主要用来描述部分与整体的关系。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将对象组合成树形结构以表示部分整体的层次结构，使得用于对单个对象和组合对象的使用具有一致性。</p><p><img src="/2020/07/01/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/combination_class.jpeg" alt="组合模式的通用类图"></p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>定义参加组合对象的共有方法和属性，可以定义一些默认的行为或者属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123;</span><br><span class="line">         c.parent = <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">this</span>.list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Component&gt; <span class="title">getChildren</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getParent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p>树枝对象，作用是组合树枝节点和叶子结点形成一个树形结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h4><p>叶子对象，下面没有分支，最小的遍历单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>高层模块调用简单<br>一颗属性结构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。</li><li>节点自由度增加<br>使用组合模式后，如果想增加一个树枝节点、树叶节点都非常容易。<br>如何开闭原则，利于维护。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>（安全模式）直接使用了实现类(可以扩展)。与依赖倒置原则冲突，限制了接口的影响范围。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="透明的组合模式"><a href="#透明的组合模式" class="headerlink" title="透明的组合模式"></a>透明的组合模式</h4><p>以上的例子就是透明的组合模式，吧用来组合使用的方法放到抽象类中，无论叶子对象还是树枝对象都有相同的结构，通过getChildren();判断当前节点是否为叶子节点还是根节点。</p><p>透明模式的好处是遵循了依赖倒置原则</p><h4 id="安全的组合模式"><a href="#安全的组合模式" class="headerlink" title="安全的组合模式"></a>安全的组合模式</h4><p>安全模式是将叶子节点和树枝节点彻底分开，树枝节点单独拥有用来组合的方法。</p><h5 id="Component-1"><a href="#Component-1" class="headerlink" title="Component"></a>Component</h5><p>定义参加组合对象的共有方法和属性，可以定义一些默认的行为或者属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getParent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Composite-1"><a href="#Composite-1" class="headerlink" title="Composite"></a>Composite</h5><p>树枝对象，作用是组合树枝节点和叶子结点形成一个树形结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123;</span><br><span class="line">         c.parent = <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">this</span>.list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Component&gt; <span class="title">getChildren</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Leaf-1"><a href="#Leaf-1" class="headerlink" title="Leaf"></a>Leaf</h5><p>叶子对象，下面没有分支，最小的遍历单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 组合模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/2020/06/30/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/30/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式是一种集中规整模式，适合用于重构项目时（重构时需求已经清晰，原有的功能点也明确）<br>通过访问者模式可以很容易达到功能集中化。<br>还可以与其他模式混编建立一套自己的过滤器和拦截器。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>封装一些用于某种数据结构中的各个元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新操作。</p><p><img src="/2020/06/30/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/visitor_class.jpeg" alt="访问者模式通用类图"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="Visitor-抽象访问者"><a href="#Visitor-抽象访问者" class="headerlink" title="Visitor 抽象访问者"></a>Visitor 抽象访问者</h4><p>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVisitor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 el1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 el2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteVisitor-具体访问者"><a href="#ConcreteVisitor-具体访问者" class="headerlink" title="ConcreteVisitor 具体访问者"></a>ConcreteVisitor 具体访问者</h4><p>影响访问者访问到一个类后该做什么事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> <span class="keyword">implements</span> <span class="title">IVisitor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 el1)</span></span>&#123;</span><br><span class="line">        el1.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 el2)</span></span>&#123;</span><br><span class="line">        el2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Element-抽象元素"><a href="#Element-抽象元素" class="headerlink" title="Element 抽象元素"></a>Element 抽象元素</h4><p>接口或者抽象类，声明接受哪一类访问者访问。<br>抽象元素有两类方法， 一类是本身的业务逻辑。另一类是允许访问者来访问的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//接受访问者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteElement-具体元素"><a href="#ConcreteElement-具体元素" class="headerlink" title="ConcreteElement 具体元素"></a>ConcreteElement 具体元素</h4><p>实现accept方法， 通常是 visitor.visit(this)模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span></span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span></span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ObjectStructure结构对象"><a href="#ObjectStructure结构对象" class="headerlink" title="ObjectStructure结构对象"></a>ObjectStructure结构对象</h4><p>元素生产者，一般容纳在多个不同类、不同接口的容器，如List/Set/Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">createElement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) &gt; <span class="number">5</span> ? <span class="keyword">new</span> ConcreteElement1() : <span class="keyword">new</span> ConcreteElement2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">     ObjectStructure.createElement().accept(<span class="keyword">new</span> Visitor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>违背了迪米特法则，Element具体的细节需要公布给Visitor</li><li>具体元素变更比较困难，元素增加/减少字段Visitor都需要修改</li><li>违背了依赖倒置原则，访问者依赖的是具体的元素，而不是抽象元素。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个对象结构包含很多类对象，它们有不同的接口，需要对这些对象实施一些依赖于其具体类的操作。</p><h3 id="双分派"><a href="#双分派" class="headerlink" title="双分派"></a>双分派</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsActor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(Role role)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Actor can act any role."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(KungFuRole role)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Actor can act Kungfu Role."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YongActor</span> <span class="keyword">extends</span> <span class="title">AbsActor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(KungFuRole role)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Yong Man Lov Act KungFu Role."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldActor</span> <span class="keyword">extends</span> <span class="title">AbsActor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">(KungFuRole role)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Old Man Can Not Act KungFu Role."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Role</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AbsActor actor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KungFuRole</span> <span class="keyword">extends</span> <span class="title">Role</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AbsActor actor)</span></span>&#123;</span><br><span class="line">        actor.act(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdiotRole</span> <span class="keyword">extends</span> <span class="title">Role</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AbsActor actor)</span></span>&#123;</span><br><span class="line">        actor.act(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbsActor actor = <span class="keyword">new</span> OldActor();</span><br><span class="line">Role role = <span class="keyword">new</span> KungFuRole();</span><br><span class="line">actor.act(role); <span class="comment">//oldActor.act(Role)</span></span><br><span class="line">actor.act(<span class="keyword">new</span> KungFuRole()); <span class="comment">//oldActor.act(KungFuRole);</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbsActor actor = <span class="keyword">new</span> OldActor();</span><br><span class="line">Role role = <span class="keyword">new</span> KungFuRole();</span><br><span class="line">role.accept(actor); <span class="comment">//KungFuRole.accept(OldActor);</span></span><br><span class="line">                    <span class="comment">//OldActor.act(KungFuRole)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2020/06/29/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/29/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在状态模式中， 类的行为时给予它的状态改变的。折中类型的设计模式属于行为型模式。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。</p><p><img src="/2020/06/29/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/State_class.jpeg" alt="状态模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="抽象状态角色State"><a href="#抽象状态角色State" class="headerlink" title="抽象状态角色State"></a>抽象状态角色State</h4><p>接口或者抽象类，负责对象状态的定义，并且封装环境角色以实现状态切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseState</span> <span class="keyword">implements</span> <span class="title">IState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Car context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Car context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体状态角色ConcreteState"><a href="#具体状态角色ConcreteState" class="headerlink" title="具体状态角色ConcreteState"></a>具体状态角色ConcreteState</h4><p>每个具体状态必须完成两个职责：本状态下要做的事情以及本状态如何过渡到其他状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenState</span> <span class="keyword">extends</span> <span class="title">BaseState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.OPEN_STATE);</span><br><span class="line">        System.out.println(<span class="string">"车门已开启"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.CLOSE_STATE);</span><br><span class="line">        System.out.println(<span class="string">"关闭车门。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开门状态下不允许飙车start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开门状态下不允许飙车Stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">extends</span> <span class="title">BaseState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.OPEN_STATE);</span><br><span class="line">        System.out.println(<span class="string">"停车后开启车门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.CLOSE_STATE);</span><br><span class="line">        System.out.println(<span class="string">"停车后关闭车门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.RUN_STATE);</span><br><span class="line">        System.out.println(<span class="string">"停车后再次跑起来"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.STOP_STATE);</span><br><span class="line">        System.out.println(<span class="string">"停车后。。停止不同"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunState</span> <span class="keyword">extends</span> <span class="title">BaseState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"飙车时不能开门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"飙车时车门已关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.RUN_STATE);</span><br><span class="line">        System.out.println(<span class="string">"飙车Run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.context.setCurrentState(Car.STOP_STATE);</span><br><span class="line">        System.out.println(<span class="string">"飙车 stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseState</span> <span class="keyword">extends</span> <span class="title">BaseState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Car.OPEN_STATE);</span><br><span class="line">        System.out.println(<span class="string">"开启车门。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"车门已经关闭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context.setCurrentState(Car.RUN_STATE);</span><br><span class="line">        System.out.println(<span class="string">"汽车开始运行。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context.setCurrentState(Car.STOP_STATE);</span><br><span class="line">        System.out.println(<span class="string">"汽车停止。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环境角色Context"><a href="#环境角色Context" class="headerlink" title="环境角色Context"></a>环境角色Context</h4><p>定义客户端需要的接口，并且负责具体状态的切换。</p><p>把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。<br>环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">IState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BaseState OPEN_STATE = <span class="keyword">new</span> OpenState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BaseState CLOSE_STATE = <span class="keyword">new</span> CloseState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BaseState RUN_STATE = <span class="keyword">new</span> RunState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BaseState STOP_STATE = <span class="keyword">new</span> StopState();</span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCurrentState(CLOSE_STATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseState <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">setCurrentState</span><span class="params">(BaseState currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">        <span class="keyword">this</span>.currentState.setContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>结合建造者模式将已有的状态按照一定的顺序再重新组装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">car.setCurrentState(Car.CLOSE_STATE);</span><br><span class="line"></span><br><span class="line">car.run(); <span class="comment">//汽车开始运行。。。</span></span><br><span class="line">car.stop(); <span class="comment">//飙车 stop</span></span><br><span class="line"></span><br><span class="line">car.run(); <span class="comment">//停车后再次跑起来</span></span><br><span class="line">car.open(); <span class="comment">//飙车时不能开门</span></span><br><span class="line"></span><br><span class="line">car.stop(); <span class="comment">//飙车 stop</span></span><br><span class="line"></span><br><span class="line">car.open(); <span class="comment">//停车后开启车门</span></span><br><span class="line">car.close(); <span class="comment">//关闭车门。。。</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>结构清晰<br>避免过多的switch case和if else，降低了程序的复杂性，提高系统的可维护性。</li><li>遵循设计原则<br>遵循了开闭原则以及单一职责原则，每个状态都是一个子类，要增加状态就要增加子类，修改状态时只修改一个子类即可。</li><li>封装性良好<br>状态变换防止到类的内部来实现，外部调用不需要知道类内部如何实现状态和行为的变换。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>状态过多时子类膨胀</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>行为跟随状态改变而改变的场景</li><li>条件、分支判断语句的替代</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 状态模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2020/06/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式也叫委托模式，许多其他的模式如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了代理模式。<br>在日常应用中，代理模式可以提供非常好的访问控制。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为其他对象提供一种代理以控制这个对象的访问。</p><p>比如，我们的DB的访问权限不能直接公开，一般会公开一个接口来提供对这些数据。</p><p><img src="/2020/06/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy_class.jpeg" alt="代理模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="抽象主题Subject"><a href="#抽象主题Subject" class="headerlink" title="抽象主题Subject"></a>抽象主题Subject</h4><p>可以是抽象类或者接口，普通的业务类型定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体主题RealSubject"><a href="#具体主题RealSubject" class="headerlink" title="具体主题RealSubject"></a>具体主题RealSubject</h4><p>委托角色或者被代理角色。业务逻辑的具体执行者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代理主题Proxy"><a href="#代理主题Proxy" class="headerlink" title="代理主题Proxy"></a>代理主题Proxy</h4><p>代理类、委托类， 负责对真实角色的调用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = <span class="keyword">new</span> Proxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//before </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//after.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>职责清晰<br>真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事物，通过后期的代理完成一件事物，附带的结果就是编程简洁清晰。</li><li>扩展性好<br>具体主题角色是随时都会发生变化的，只要它实现了接口，代理类可以在不做任何修改的情况下使用。</li><li>智能化<br>用于动态代理。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h3><p>客户端只能访问代理角色，而不能访问真实角色。屏蔽了真实角色的变更对高层模块的影响。该模式适合对扩展性要求较高的场合。一般通过编程规范类约束来禁止new一个真实的角色。</p><p>这种方式调用者只需要知道代理即可， 不需要知道代理了谁。</p><p>普通代理的实现者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(IGamePlayer _gamePlayer, String _name)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_gamePlayer == <span class="keyword">null</span> || !(_gamePlayer <span class="keyword">instanceof</span> GameProxy))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Create Not Allowed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killMonster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通代理的代理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            gamePlayer = <span class="keyword">new</span> GamePlayer(<span class="keyword">this</span>,name);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">//TODO </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killMonster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gamePlayer.killMonster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h3><p>只有通过真实角色指定的代理类才可以访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">killMonster</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> IGamePlayer proxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(String _name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = _name;</span><br><span class="line">        <span class="keyword">this</span>.proxy = <span class="keyword">new</span> GamepPlayerProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killMonster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gamePlayer = _gamePlayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killMonster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gamePlayer.killMonster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在实现阶段不需要关心代理谁， 在运行阶段才指定代理哪个对象。</p><p>通过InvocationHandler接口，所有方法都由该Handler来接管实际的业务处理。</p><p>在不改变已有代码结构的情况下增强或者控制对象的行为。</p><p>动态代理Handler类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object _obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = _obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知接口与实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAdvice</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdvice</span> <span class="keyword">implements</span> <span class="title">IAdvice</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(condition)&#123; <span class="comment">//在condition连接点执行BeforeAdvice通知。</span></span><br><span class="line">            (<span class="keyword">new</span> BeforeAdvice()).exec();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(loader, <span class="class"><span class="keyword">interface</span>, <span class="title">h</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</span><br><span class="line">Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), handler);</span><br><span class="line">proxy.killMonster();</span><br></pre></td></tr></table></figure><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><ul><li>CGLib</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before Interceptor1"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After Interceptor1"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor2</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before Interceptor2"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After Interceptor2"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogCallBackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"upgrade"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Upgrade Filter"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Kill Monster Filter"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LogInterceptor logInterceptor = <span class="keyword">new</span> LogInterceptor();</span><br><span class="line"></span><br><span class="line">LogInterceptor2 logInterceptor2 = <span class="keyword">new</span> LogInterceptor2();</span><br><span class="line"></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(GamePlayer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;logInterceptor,logInterceptor2, NoOp.INSTANCE&#125;);</span><br><span class="line"></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> LogCallBackFilter());</span><br><span class="line"></span><br><span class="line">IGamePlayer gamePlayer = (IGamePlayer)enhancer.create(new Class[]&#123;String.class&#125;, new Object[]&#123;"Lisi"&#125;);</span><br><span class="line"></span><br><span class="line">gamePlayer.killMonster();</span><br><span class="line">gamePlayer.upgrade();</span><br></pre></td></tr></table></figure><ul><li>ASM</li><li>AOP</li></ul><p>扩展阅读<br><a href="https://www.jianshu.com/p/a728dac249e1?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">cglib动态代理、asm学习笔记</a><br><a href="https://juejin.im/post/5c1ca8df6fb9a049b347f55c" target="_blank" rel="noopener">Java动态代理详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2020/06/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式使用的就是面向对象的继承和多态机制。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p><p><img src="/2020/06/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy_class.jpeg" alt="策略模式通用类图"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Strategy-抽象策略角色"><a href="#Strategy-抽象策略角色" class="headerlink" title="Strategy 抽象策略角色"></a>Strategy 抽象策略角色</h4><p>策略算法的抽象，通常是接口，定义每个策略或者算法必须具有的方法和属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcreteStrategy-具体策略角色"><a href="#ConcreteStrategy-具体策略角色" class="headerlink" title="ConcreteStrategy 具体策略角色"></a>ConcreteStrategy 具体策略角色</h4><p>实现抽象策略的具体算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Do Strategy1.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//Do Strategy2.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Context-封装角色"><a href="#Context-封装角色" class="headerlink" title="Context 封装角色"></a>Context 封装角色</h4><p>封装上下文，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。<br>策略模式的重点就是封装角色，它借用了代理模式的思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Strategy strategy = <span class="keyword">new</span> ConcreteStrategy1();</span><br><span class="line">Context context = <span class="keyword">new</span> Context(strategy);</span><br><span class="line">context.doAny(strategy);</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>算法可以自由切换<br>只需要实现策略接口类，通过封装角色对其进行封装即可。</li><li>避免使用多重条件判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)&#123;</span><br><span class="line">   strategy1.<span class="keyword">do</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</span><br><span class="line">   strategy2.<span class="keyword">do</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// .....</span></span><br></pre></td></tr></table></figure></li><li>扩展性好</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>策略类数量多</li><li>所有策略类都需要对外暴露<br>上层模块必须知道有哪些策略， 然后才能决定使用哪一个策略，与迪米特法则相违背。<br>(迪米特法则：一个类对于其他类知道的越少越好)</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当具体的策略数量超过一定个数时，考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则会带来很大的系统维护成本。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个类只有在算法或者行为上稍有不同的场景</li><li>算法需要自由切换的场景</li><li>需要屏蔽算法规则的场景</li></ul><h3 id="策略枚举"><a href="#策略枚举" class="headerlink" title="策略枚举"></a>策略枚举</h3><p>当策略枚举不经常发生变化时可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StrategyEnum &#123;</span><br><span class="line"></span><br><span class="line">    ADD(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUB(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String opt;</span><br><span class="line">    StrategyEnum(String opt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.opt = opt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象池模式</title>
      <link href="/2020/06/24/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/24/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="对象池模式"><a href="#对象池模式" class="headerlink" title="对象池模式"></a>对象池模式</h2><p>一种特殊的工厂对象，一个对象池包含一组已经初始化过且可以使用的对象。用户可以从池中取得对象，并对其进行操作，在不需要的时候将其归还给对象池。</p><p>使用对象池的目的是为了提升性能，当需要创建比较耗费时间的对象时尤为明显。</p><p><img src="/2020/06/24/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/object_pool.jpeg" alt="对象池通用类图"></p><h3 id="角色和职责"><a href="#角色和职责" class="headerlink" title="角色和职责"></a>角色和职责</h3><h4 id="对象池的管理者"><a href="#对象池的管理者" class="headerlink" title="对象池的管理者"></a>对象池的管理者</h4><p>管理者来维护对象池，包括初始化对象池、扩充对象池的大小、获取对象时的策略、重置归还对象的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolMgr</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> init ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> factor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Colection c; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//init</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据策略来动态的生成对象。。</span></span><br><span class="line">    <span class="comment">//如果对象不足可以增加对象池的对象，或者blocking直到有对象释放。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aquire</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        reset(o);</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象池的使用者"><a href="#对象池的使用者" class="headerlink" title="对象池的使用者"></a>对象池的使用者</h4><p>使用者从管理者处获取对象，使用完成后必须归还对象避免一致占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   o = PoolMgr.getInstance();  </span><br><span class="line">&#125;finaly&#123;</span><br><span class="line">   PoolMgr.release(o);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>复用池中的对象，消除创建/回收对象所产生的内存开销，CPU开销以及IO开销。<br>常见的有：Socket的链接池、线程池、数据库连接池等。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>多线程并发环境中，需要考虑线程安全问题，需要在数据结构上进行同步或者为锁竞争产生阻塞，这种开销处理不好会比创建销毁独享的开销高很多。<br>由于池中的对象数量有限，对象池小可能会成为性能瓶颈，太大占用内存资源高；<br>轻量级对象的创建/销毁不需要使用对象池，徒增系统的复杂度；</p><h2 id="Common-Pool2"><a href="#Common-Pool2" class="headerlink" title="Common Pool2"></a>Common Pool2</h2><p>Commons Pool2核心部分由三个基础接口和相关的实现类实现：</p><h3 id="PooledObject"><a href="#PooledObject" class="headerlink" title="PooledObject"></a>PooledObject</h3><p>池化对象，对池中的对象进行封装，封装对象的状态和一些其他信息。<br>PooldedObject 有两个实现类，DefaultPoolObject时普通通用的实现，PooledSoftReference使用SoftReference封装了对象，供SoftReferenceObjectPool使用。</p><p><img src="/2020/06/24/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/pooledObject.jpeg" alt="池化对象类图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PooledObject</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">PooledObject</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 获取封装的对象</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象创建的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getCreateTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象上次处于活动状态的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getActiveTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象上次处于空闲状态的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getIdleTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象上次被借出的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastBorrowTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象上次返还的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastReturnTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象上次使用的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastUsedTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将状态置为 PooledObjectState.INVALID</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 lastUseTime</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象状态</span></span><br><span class="line">    <span class="function">PooledObjectState <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将状态置为 PooledObjectState.ABANDONED</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markAbandoned</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将状态置为 PooledObjectState.RETURNING</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markReturning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h3><p> 池化对象工厂，负责对象的创建、初始化、销毁和验证工作，Factory对象由ObjectPool持有并使用。<br>因为对象的创建、初始化、销毁和仰正的工作无法通用，Commons Pool2并没有提供PooledObjectFactory的默认子类实现，只提供了抽象子类BasePooledObjectFactory<br>可以实现create和wrap两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PooledObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个池对象</span></span><br><span class="line">    <span class="function">PooledObject&lt;T&gt; <span class="title">makeObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证对象是否可用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">validateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活对象，从池中取对象时会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钝化对象，向池中返还对象时会调用此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">passivateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p> 持有对象并提供取/还等操作.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> public interface ObjectPool&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 从池中获取一个对象，客户端在使用完对象后必须使用 returnObject 方法返还获取的对象</span><br><span class="line">    T borrowObject() throws Exception, NoSuchElementException,</span><br><span class="line">            IllegalStateException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将对象返还到池中。对象必须是从 borrowObject 方法获取到的</span><br><span class="line">    void returnObject(T obj) throws Exception;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使池中的对象失效，当获取到的对象被确定无效时（由于异常或其他问题），应该调用该方法</span><br><span class="line">    void invalidateObject(T obj) throws Exception;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 池中当前闲置的对象数量</span><br><span class="line">    int getNumIdle();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前从池中借出的对象的数量</span><br><span class="line">    int getNumActive();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 清除池中闲置的对象</span><br><span class="line">    void clear() throws Exception, UnsupportedOperationException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关闭这个池，并释放与之相关的资源</span><br><span class="line">    void close();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象池配置"><a href="#对象池配置" class="headerlink" title="对象池配置"></a>对象池配置</h3><p>对象池配置提供了对象池初始化所需要的参数，Common Pool2中的基础配置类时BaseObjectPoolConfig, 有GenericObjectPoolConfig和GenericKeyedObjectPoolConfig，分别为GenericObjectPool和GenericKeyedObjectPool使用。</p><table><thead><tr><th>参数</th><th>解释</th><th>默认值</th></tr></thead><tbody><tr><td>lifo</td><td>连接池存放池对象的方式； true:放在空闲队列的嘴钱买呢， false:放在空闲队列的最后面</td><td>true</td></tr><tr><td>fairness</td><td>从池中获取/返还对象时是否使用公平锁机制</td><td>false</td></tr><tr><td>maxWaitMillis</td><td>获取资源的等待时间。blockWhenExhausted为true时有效。-1代表无时间限制，一致阻塞到有可用的资源</td><td></td></tr><tr><td>minEvictableIdleTimeMillis</td><td>对象空闲的最小时间，打到此值后空闲对象可能会被移除，-1表示不移除</td><td>30分钟</td></tr><tr><td>softMinEvictableIdletimeMillis</td><td>对象空闲的最小时间，并且池中之少保留有minidle所指定的个数</td><td></td></tr><tr><td>numTestsPerEvictionRun</td><td>资源回收线程执行一次回收操作回收资源的个数</td><td>3</td></tr><tr><td>evictionPolicyClassName</td><td>资源回收策略</td><td>org.apache.commons.pool2.impl.DefaultEvictionPolicy</td></tr><tr><td>testOnCreate</td><td>创建对象时是否调用factory.validateObject</td><td>false</td></tr><tr><td>testOnBorrow</td><td>获取对形势是否调用factory.validateObject</td><td>false</td></tr><tr><td>testOnReturn</td><td>返还对象时是否调用factory.validateObject</td><td>false</td></tr><tr><td>timeBetweenEvictionRunsMills</td><td>回收资源线程的执行周期，默认-1表示不启用回收资源线程</td><td>-1</td></tr><tr><td>blockWhenExhausted</td><td>资源耗尽时，是否阻塞等待获取资源</td><td>true</td></tr><tr><td>testWhileIdel</td><td>池中的限制对象是否由逐出器验证，无法验证的对象将从池中删除销毁</td><td>false</td></tr></tbody></table><h3 id="池化对象的状态"><a href="#池化对象的状态" class="headerlink" title="池化对象的状态"></a>池化对象的状态</h3><table><thead><tr><th>参数值</th><th>描述</th></tr></thead><tbody><tr><td>IDEL</td><td>在池中，处于空闲状态</td></tr><tr><td>ALLOCATED</td><td>被使用中</td></tr><tr><td>EVICTION</td><td>正在被逐出器验证</td></tr><tr><td>VALIDAITTON</td><td>正在验证</td></tr><tr><td>INVALID</td><td>驱逐测试或者验证失败并将被销毁</td></tr><tr><td>ABANDONED</td><td>对象被客户端拿出后，长时间未返回池中，或者没有调用use方法，被标记为抛弃</td></tr></tbody></table><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferFactory</span> <span class="keyword">extends</span> <span class="title">BasePooledObjectFactory</span>&lt;<span class="title">StringBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装为池化对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PooledObject&lt;StringBuffer&gt; <span class="title">wrap</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;&gt;(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完返还对象时将 StringBuffer 清空</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passivateObject</span><span class="params">(PooledObject&lt;StringBuffer&gt; pooledObject)</span> </span>&#123;</span><br><span class="line">        pooledObject.getObject().setLength(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建对象池配置</span></span><br><span class="line">GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line"><span class="comment">// 创建对象工厂</span></span><br><span class="line">PooledObjectFactory factory = <span class="keyword">new</span> StringBufferFactory();</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">ObjectPool&lt;StringBuffer&gt; pool = <span class="keyword">new</span> GenericObjectPool&lt;&gt;(factory, config);</span><br><span class="line">StringReader in = <span class="keyword">new</span> StringReader(<span class="string">"abcdefg"</span>);</span><br><span class="line">StringBuffer buf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 从池中获取对象</span></span><br><span class="line">    buf = pool.borrowObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = in.read(); c != -<span class="number">1</span>; c = in.read()) &#123;</span><br><span class="line">        buf.append((<span class="keyword">char</span>) c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 出现错误将对象置为失效</span></span><br><span class="line">        pool.invalidateObject(buf);</span><br><span class="line">        <span class="comment">// 避免 invalidate 之后再 return 抛异常</span></span><br><span class="line">        buf = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != buf) &#123;</span><br><span class="line">            <span class="comment">// 使用完后必须 returnObject</span></span><br><span class="line">            pool.returnObject(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/36216932" target="_blank" rel="noopener">Apache Common Pool2 对象池应用浅析</a><br><a href="https://www.infoq.cn/article/2015/07/ClojureWerkz/" target="_blank" rel="noopener">一个广为人知但鲜有人用的技巧：对象池</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 对象池模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2020/06/24/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/24/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>不通过new关键字来产生一个对象，而通过对象复制来生产对象的模式，原型模式的核心是clone方法，通过该方法进行对象的拷贝。</p><p>也就是先生产出一个包含大量共有信息的类对象，然后拷贝出副本修正细节信息，建立一个完整的个性对象。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用原型实例指定创建对象的种类，并且<code>通过拷贝这些原型创建新的对象</code>。</p><p><img src="/2020/06/24/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/prototype.jpeg" alt="原型模式通用类图"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>性能好<br>原型模式是内存二进制流侧拷贝，要比直接new一个对象性能好很多，特别在一个循环体内产生大量的对象时，原型模式可以更好的体现其优点。</li><li>逃避构造函数的约束<br>直接在内存中拷贝，构造函数不会执行。优点和缺点都是减少了约束。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要频繁的new一个对象，并且该对象需要繁琐的数据准备时；<br>一个对象要提供给其他对象访问，各个调用者可能需要修改其值时；</p><p>原型模式一般与工厂方法模式一起出现，通过clone的方法来创建对象，然后由工厂方法提供给调用者。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeClass</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrototypeClass <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrototypeClass p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            p = (PrototypeClass)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="构造函数不会被执行"><a href="#构造函数不会被执行" class="headerlink" title="构造函数不会被执行"></a>构造函数不会被执行</h3><p>Object类的clone方法原理是从内存中（堆内存）以二进制流的方式进行拷贝，重新分配一个内存快，构造函数是不会被执行的。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>Object类提供的方法clone只是拷贝本对象，对于其内部的数组、引用对象都不拷贝还是指向原声对象的内部元素地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeClass</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrototypeClass <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrototypeClass p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           p = (PrototypeClass) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) ) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝需要拷贝对象自身外，还需要拷贝对象的所有引用的对象。</p><p>通过clone方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeClass</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrototypeClass <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrototypeClass p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           p = (PrototypeClass) <span class="keyword">super</span>.clone();</span><br><span class="line">           p.arrayList = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.arrayList.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) ) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过序列化方式来实现，通过序列化将对象(该对象的类必须实现Serializable接口)写到一个流中，然后再从流里把对象读出来以实现深克隆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">    oos.writeObject(t);</span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">    <span class="keyword">return</span> (T)ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone与final的冲突"><a href="#clone与final的冲突" class="headerlink" title="clone与final的冲突"></a>clone与final的冲突</h3><p>当使用clone方法的时候，类的成员变量不可以增加final关键字。</p><p>拓展：<br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10649509.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2020/06/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式与工厂模式关注点不同，建造者模式关注零件的组装过程，工厂模式注重零件的创建过程。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>建造者模式也叫生成器模式， 它将一个复杂对象的构建与它的表示分离，使得同样的建造构建过程可以创建不同的表示。</p><p><img src="/2020/06/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/creator.jpeg" alt="建造者模式通用类图"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>封装性良好<br>使用建造者模式可以使得客户端不需要知道产品内部组成的细节。</li><li>建造者独立，易扩展<br>不同的实现类Builder是相互独立的，对系统的扩展有利。</li><li>便于控制细节风险<br>由于建造者独立，因此可以个性化，修改一个建造者不会对其他模块产生影响。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>产品的组成部分必须相同，限制了其使用范围</li><li>产品内部变化复杂时，需要增加很多建造者类</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>相同的方法，不同的执行顺序，产生不同的事件结果时；</li><li>多个部件或者零件都可以装配到一个对象中，但是产生的运行结果不同时；</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能；</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Product-产品类"><a href="#Product-产品类" class="headerlink" title="Product 产品类"></a>Product 产品类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Builder抽象建造者"><a href="#Builder抽象建造者" class="headerlink" title="Builder抽象建造者"></a>Builder抽象建造者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">()</span></span>; <span class="comment">//设置个性部分</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">buildProduct</span><span class="params">()</span></span>;<span class="comment">//建造产品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcreteBuilder-具体建造者"><a href="#ConcreteBuilder-具体建造者" class="headerlink" title="ConcreteBuilder 具体建造者"></a>ConcreteBuilder 具体建造者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pbulic Product <span class="title">buildProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Product();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Director-导演类"><a href="#Director-导演类" class="headerlink" title="Director 导演类"></a>Director 导演类</h3><p>导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。当建造者模式比较庞大时，导演类可以有多个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Product <span class="title">buildProductA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Builder b = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">    b.setPart();</span><br><span class="line">    <span class="keyword">return</span> b.buildProduct();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离</title>
      <link href="/2020/06/22/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
      <url>/2020/06/22/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>动静分离技术：CDN、<br>负载均衡：<br>     实现手段：<br>     1） lvs / lb / 四层数据包， 速度快，不解包。</p><pre><code>2）   反向代理（nginx 、 Node.js 七层  URI/location 建立三次握手，请求传递、转发      存储ip、请求uri、次数、时间等，     ）     Load Balance 健康检查算法：随机轮训哈希最少连接数权重/动态权重</code></pre><p>多级缓存<br>防穿透</p><p>限流<br>熔断<br>降级<br>灰度发布</p><p>服务无状态：分布式问题</p><p>update user set status = 2 where status = 1 and id = 1;</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2020/06/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，抽象工厂模式可以生产多个等级的产品。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>产品等级：不同产品的种类就是不同的产品等级（电视机和洗衣机就是不同的产品等级）<br>产品族：一个具体工厂生产的不同等级的产品（工厂生产的电视机和洗衣机属于一个产品族）</p><p><img src="/2020/06/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/product_level.gif" alt="产品等级和产品族"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一种为访问类提供一个创建一组相关或者相互依赖对象的接口，且访问类无需指定所需要产品的具体类就能得到同族的不同等级的产品。</p><p><img src="/2020/06/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstract_factory.jpeg" alt="抽象工厂模式类图"></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1） 客户端不依赖于产品类实例如何被创建、实现<br>2） 强调一系列相关的产品（同一产品族）一起使用创建对象需要大量的代码<br>3） 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。<br>一个对象族都有相同的约束，则可以使用抽象工厂模式。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="产品角色实现"><a href="#产品角色实现" class="headerlink" title="产品角色实现"></a>产品角色实现</h3><p>抽象产品：Product，定义产品的规范，描述产品的主要特性和功能，抽象工厂模式有多个抽象产品。<br>具体产品：ConcreteProduct，实现抽象产品角色所定义的接口由具体工厂来创建，与具体工厂之间是一对多的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Product&#123;</span><br><span class="line">    <span class="comment">//all product base filds &amp; methods.</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">off</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractTvProduct extends Product&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">switchChannel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractFridgeProduct extends Product&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">increaseTemp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">decreaseTemp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HaierTVProduct extends AbstractTvProduct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HaierFridgeProduct extends AbstractFridgeProduct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TCLTVProduct extends AbstractTvProduct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TCLFridgeProduct extends AbstractFridgeProduct&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂角色实现"><a href="#工厂角色实现" class="headerlink" title="工厂角色实现"></a>工厂角色实现</h3><p>抽象工厂：Abstract Factory，提供了创建产品的接口，包含多个创建产品的方法,可以创建多个不同等级的产品。<br>具体工厂：实现抽象工厂中的多个抽象方法，完成具体产品的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createTV</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Product <span class="title">createFridge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HaierFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createTV</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HaierTVProduct();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Product <span class="title">createFridge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HaierFridgeProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createTV</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TCLTVProduct();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Product <span class="title">createFridge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TCLFridgeProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>隔离了具体类的生成，使得客户并不需要知道什么被创建，具有良好的封装性。</li><li>如果要扩展产品族（有新的工厂要生产电视和冰箱时）的时候，只需要增加具体的产品类和实现工厂方法即可，原有的代码不需要变动，符合开闭原则。</li><li>如果要扩展产品等级时，从抽象产品到工厂类，原有的代码都需要变动，违背了开闭原则。</li></ul><p>参阅：<br><a href="http://c.biancheng.net/view/1351.html" target="_blank" rel="noopener">抽象工厂模式（详解版）</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 抽象工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成器</title>
      <link href="/2020/06/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2020/06/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>1)资源锁细粒度化<br>  将100个资源拆分成10份。<br>  这10份分别上锁，应用场景如秒杀。</p><p>2）业务使用锁细粒度化<br>   只对需要的资源加锁，避免大范围加锁。</p><p>3）无锁化（真无锁，假无锁）<br>    ThreadLocal 真无锁<br>    CAS  假无锁<br>4）异步+线程池<br>   Completeable</p><p> hystrix/sentinel 限流</p><p> Leaf / </p><p> Snowflake<br> 缺点：<br> 1）依赖于时间，需要ntp<br> 2）依赖于NodeId和AreaID的分发，用ZK解决<br>   通过zk的顺序性分配唯一的node和area</p><p>基于Mysql的发布<br>基于Mysql的优化</p><p>基于雪花算法</p><p>基于ZK</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> ID生成器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2020/06/19/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/19/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>new 对象的替代方案</li><li>需要灵活、可扩展的框架时</li><li>在异构项目中，从外部产生的对象</li><li>测试驱动开发框架下使用。<a href="https://www.jianshu.com/p/097d32d09713" target="_blank" rel="noopener">测试驱动开发 -TDD</a></li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><p><img src="/2020/06/19/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/factory_comm.jpeg" alt="工厂方法模式的通用类图"></p><p>抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；<br>Creator为抽象的创建类，即抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的封装，代码结构清晰，降低模块间的耦合；</li><li>良好的扩展性；</li><li>屏蔽具体的产品类，只要接口不变，系统中上层模块就不需要发生变化。</li></ul><p>高层模块只需要知道产品的抽象类，不关心实现类，符合迪米特法则；<br>只依赖产品的抽象，符合倒置原则；<br>使用产品子类替换父类时也没有问题，符合里氏替换原则；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对于不同类型的产品都要增加不同类型的工厂来管理，增加代码的复杂性</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h3><p>产品类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        Product p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            p = (Product)Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T)p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Factory factory &#x3D; new ConcreteFactory();</span><br><span class="line">Product p &#x3D; factory.createt(Product1.class);</span><br></pre></td></tr></table></figure><h3 id="缩小为简单工厂"><a href="#缩小为简单工厂" class="headerlink" title="缩小为简单工厂"></a>缩小为简单工厂</h3><p>去掉抽象的Factory类，create()方法变为静态方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Factory&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Product&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">        Product p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            p = (Product)Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T)p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Product p = Factory.create(Product1<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h3><p>遇到复杂情况下，一个工厂类初始化需要耗费很多资源，这样可以将工厂类细化拆分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Product1();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Product2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的好处是职责清晰，结构简单，但是可扩展性和可维护性差了些。<br>一般情况下，再增加一个协调类，避免调用者直接与各个子工厂类交流，协调类的作用是封装子工厂类，对高层模块提供统一的访问接口。</p><h3 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h3><p>通过反射的方式来创建唯一一个实例</p><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>一个对象被使用完毕后，并不立即释放，工厂类保持其初始状态，等待再次被使用。</p><p>延迟加载框架可以被扩展为，限制某个产品类的最大实例化数量（如链接池的最大链接数量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Product&gt; pMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Product p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pMap.containsKey(type))&#123;</span><br><span class="line">            p = pMap.get(type);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(type.equals(<span class="string">"Product1"</span>))&#123;</span><br><span class="line">                p = <span class="keyword">new</span> Product1();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = <span class="keyword">new</span> Product2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p></blockquote><p><a href="https://www.zhihu.com/question/24843188" target="_blank" rel="noopener">https://www.zhihu.com/question/24843188</a></p><p><a href="https://www.jianshu.com/p/83ef48ce635b" target="_blank" rel="noopener">https://www.jianshu.com/p/83ef48ce635b</a></p><p><a href="https://blog.csdn.net/buyulian/article/details/79203880" target="_blank" rel="noopener">https://blog.csdn.net/buyulian/article/details/79203880</a></p><p><a href="https://blog.csdn.net/qianhaifeng2012/article/details/52014773" target="_blank" rel="noopener">https://blog.csdn.net/qianhaifeng2012/article/details/52014773</a></p><p><a href="https://www.cnblogs.com/aspirant/p/8980573.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8980573.html</a></p><p><a href="http://www.akathink.com/2016/08/01/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">http://www.akathink.com/2016/08/01/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 工厂方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/06/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“混乱”。</p><ul><li>要求生成唯一序号的场景</li><li>整个项目中需要一个共享数据，如计数器</li><li>创建对象要消耗过多资源（IO访问或者数据库资源等）</li><li>定义大量的静态常量和静态方法的工具类</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>确保一个类只有一个实例，而且自行实例化并且向整个系统提供这个实例。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>单例模式在内存中只有一个实例，减少了内存开支。<br>当一个对象需要频繁地创建、销毁时，而且创建或者销毁时的性能无法优化时，单例模式的优势非常明显。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>没有接口，无法扩展，没有接口也不能使用Mock方式虚拟对象。<br>在并行开发环境中，单例模式没有完成无法进行测试。<br>与单一职责原则冲突，单例模式把业务逻辑和单例混合在一个类中。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>高并发情况下，单例模式的线程同步问题。</p><h2 id="提前加载"><a href="#提前加载" class="headerlink" title="提前加载"></a>提前加载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延后加载"><a href="#延后加载" class="headerlink" title="延后加载"></a>延后加载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2020/06/18/Redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/06/18/Redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>IDC机房硬件设备选购方案</p><p>1.1 生产环境中选购依据</p><ul><li>价格</li><li>性能</li><li>冗余</li></ul><p>1.1.1 生产环境负载均衡系统架构设备选购方案</p><p>   负载均衡：<br>   LVS1 DELL  R610 1U CPU E5<em>2 8G * 2/4  硬盘 SAS 146 * 2  RAID1<br>   LVS2 DELL  R610 1U CPU E5</em>2 8G * 2/4  硬盘 SAS 146 * 2  RAID1</p><p>1.1.2 Web层硬件选择RAID</p><p>   www主站1 业务<em>2 DELL R730 2U CPU E5 * 2 8G(16G/32G) SAS 300G * 2  RAID0<br>   www主站2 业务</em>2 DELL R730 2U CPU E5 * 2 8G(16G/32G) SAS 300G * 2  RAID0</p><p>1.1.3 数据库层硬件以及RAID</p><p>  Mysql主库1-1  DELL R730 2U CPU E5<em>2 8/16/32 SAS 300G * 6 RAID10(兼顾冗余/速度）<br>  Mysql主库1-2  DELL R730 2U CPU E5</em>2 8/16/32 SAS 300G * 6 RAID10(兼顾冗余/速度）<br>  Mysql从库1-1  DELL R730 2U CPU E5<em>2 8/16/32 SAS 300G * 6 RAID0/5<br>  Mysql从库1-2  DELL R730 2U CPU E5</em>2 8/16/32 SAS 300G * 6 RAID0/5<br>  Mysql从库2-1  DELL R730 2U CPU E5<em>2 8/16/32 SAS 300G * 6 RAID0/5<br>  Mysql从库2-2  DELL R730 2U CPU E5</em>2 8/16/32 SAS 300G * 6 RAID0/5</p><p>1.1.4 存储层硬件以及RAID</p><p>DELL R610 E5 * 2 16/32G SAS 10K 2T * 6 不做RAID交叉备份/ RAID5<br>DELL R730 E5 * 2 16/32G SAS 10K 2T * 6 RAID5折中方案</p><p>备份服务器一般考虑容量和冗余，对性能要求不高。</p><p>1.1.5 NFS硬件以及RAID</p><p>NFS1 DELL R730 E5 8G * 2 SAS 15K  600G * 6  RAID10/RAID5/RAID0<br>NFS2 DELL R730 E5 8G * 2 SAS 15K  600G * 6  RAID10/RAID5/RAID0    </p><p>1.1.6 GFS、MFS分布式存储</p><p>NFS1 DELL R730 E5 8G * 2 SAS 15K  600G * 6  RAID10/RAID5/RAID0<br>NFS2 DELL R730 E5 8G * 2 SAS 15K  600G * 6  RAID10/RAID5/RAID0   </p><p>1.1.7 监控管理/网关层硬件以及RAID</p><p>DELL R610/R430 E5*1 8/16G 146 SAS * 2 RAID1</p><p>1.1.8 网络设备</p><p>全千兆设备/网线<br>华为 H3C  CISCO DLINK </p><div class="note grey"><p>都需要带有远程管理卡 4+1</p></div><h2 id="Redis搭建"><a href="#Redis搭建" class="headerlink" title="Redis搭建"></a>Redis搭建</h2><p>主机规划：</p><table><thead><tr><th>序号</th><th>主机名称</th><th>角色</th><th>数量</th><th>IP内网</th><th>IP外网</th><th>端口</th><th>软件</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>Redis-Master-01</td><td>Node01</td><td>1</td><td>10.0.0.1</td><td></td><td>6379</td><td>Centos7.7</td><td>–</td></tr><tr><td>1</td><td>Redis-Master-02</td><td>Node02</td><td>1</td><td>10.0.0.2</td><td></td><td>6379</td><td>Centos7.7</td><td>–</td></tr><tr><td>1</td><td>Redis-Master-03</td><td>Node03</td><td>1</td><td>10.0.0.3</td><td></td><td>6379</td><td>Centos7.7</td><td>–</td></tr><tr><td>1</td><td>Redis-slave-01</td><td>slave01</td><td>1</td><td>10.0.0.4</td><td></td><td>6389</td><td>Centos7.7</td><td>–</td></tr><tr><td>1</td><td>Redis-slave-02</td><td>slave02</td><td>1</td><td>10.0.0.5</td><td></td><td>6389</td><td>Centos7.7</td><td>–</td></tr><tr><td>1</td><td>Redis-slave-03</td><td>slave03</td><td>1</td><td>10.0.0.6</td><td></td><td>6389</td><td>Centos7.7</td><td>–</td></tr></tbody></table><p><br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bind 10.0.0.1</span><br><span class="line">port 6379</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid</span><br><span class="line">cluster-enabled yes</span><br><span class="line">daemonize yes</span><br><span class="line">cluster-config-file  nodes-63679.conf </span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><h3 id="ES安装"><a href="#ES安装" class="headerlink" title="ES安装"></a>ES安装</h3><p>cd /etc/yum.repos.d/<br>vim elasticsearcg.repo<br>yum makecache &amp;&amp; yum install -y elasticsearch</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 集群部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式和原则</title>
      <link href="/2020/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%88%99/"/>
      <url>/2020/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>创建软件应用程序时为了满足不断变化和发展的需求，一个成功的应用程序应该提供一种简单的方法来扩展它以满足不断变化的期望。</p><h2 id="SOLID设计原则"><a href="#SOLID设计原则" class="headerlink" title="SOLID设计原则"></a>SOLID设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>有且仅有一个原因引起类的变更。</p><p>问题：<br>Class IUser 负责两个不同的职责,职责1维护User的属性(id, name, age)，职责2维护DB操作（save/update/delete/find）.<br>当由于职责1需求发生改变要增加一个sex的时候，有可能会导致原本运行正常的职责2功能发生故障。</p><p>解决方法：<br>将IUser拆分为 UserInfo和UserDao。</p><p>优点：<br>降低类的复杂性，一个类只负责一项职责；<br>提高类的可读性，提高系统的可维护性；<br>降低变更引起的风险，当修改一个接口的功能时，可以降低对其他功能的影响。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>也就是说通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p><p>可以通过抽象约束、封装变化来实现开闭原则。<br>通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>派生类型必须完全可替代其基类型。在设计模块和类时，必须确保派生类型从行为的角度来看是可替代的。当派生类型被其父类替换时，其余代码就像它是自类型那样使用它。</p><ul><li>子类必须完全实现父类的方法</li><li>子类可以有自己的个性</li><li>覆盖或者实现父类的方法时，输入参数可以被放大</li><li>腹泻或者实现父类的方法时，输出结果可以被缩小</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖于它所不需要的接口。接口隔离原则减少了代码耦合，使软件更强壮，更易于维护和扩展。接口隔离原则要求接口的定义和设计尽量的细化。</p><ul><li>接口尽量小，但是要有限度。<br>对接口进行细化可以提高程序设计的灵活性，但是如果过小，会造成接口数量过多，使设计复杂化。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，不需要的方法隐藏起来，只有专注地为一个模块提供定制服务，才能建立最小依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法完成最多的事情。</li></ul><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>高级模块不应该依赖低级模块，两者都应该依赖抽象。<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，器依赖关系是通过接口或者抽象类产生。</li><li>接口或者抽象类不依赖实现类</li><li>实现类依赖接口或者抽象类</li></ul><h2 id="创建型模式-6-6"><a href="#创建型模式-6-6" class="headerlink" title="创建型模式(6/6)"></a>创建型模式(6/6)</h2><ul><li><a href="/2020/06/18/单例模式">单例模式</a></li><li><a href="/2020/06/19/工厂方法模式">工厂方法模式</a></li><li><a href="/2020/06/22/抽象工厂模式">抽象工厂模式</a></li><li><a href="/2020/06/23/建造者模式">建造者模式</a></li><li><a href="/2020/06/24/原型模式">原型模式</a></li><li><a href="/2020/06/24/对象池模式">对象池模式</a></li></ul><h2 id="行为型模式-12-12"><a href="#行为型模式-12-12" class="headerlink" title="行为型模式(12/12)"></a>行为型模式(12/12)</h2><ul><li><a href="/2020/06/28/策略模式/">策略模式</a></li><li><a href="/2020/06/29/状态模式/">状态模式</a></li><li><a href="/2020/06/30/访问者模式/">访问者模式</a> </li><li><a href="/2020/07/01/迭代器模式/">迭代器模式</a></li><li><a href="/2020/07/02/责任链模式/">责任链模式</a></li><li><a href="/2020/07/02/模版方法模式/">模版方法模式</a></li><li><a href="/2020/07/03/命令模式/">命令模式</a></li><li><a href="/2020/07/04/备忘录模式/">备忘录模式</a></li><li><a href="/2020/07/05/解释器模式/">解释器模式</a></li><li><a href="/2020/07/07/观察者模式/">观察者模式</a></li><li><a href="/2020/07/06/中介者模式/">中介者模式</a></li><li><a href="/2020/07/06/空对象模式/">空对象模式</a></li></ul><h2 id="结构型模式-7-7"><a href="#结构型模式-7-7" class="headerlink" title="结构型模式(7/7)"></a>结构型模式(7/7)</h2><ul><li><a href="/2020/06/28/代理模式/">代理模式</a></li><li><a href="/2020/07/01/组合模式/">组合模式</a></li><li><a href="/2020/07/08/装饰器模式/">装饰器模式</a></li><li><a href="/2020/07/09/桥接模式/">桥接模式</a></li><li><a href="/2020/07/10/适配器模式/">适配器模式</a> </li><li><a href="/2020/07/11/门面模式/">门面模式</a></li><li><a href="/2020/07/12/享元模式/">享元模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 设计原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用JVM参数</title>
      <link href="/2020/06/17/%E5%B8%B8%E7%94%A8JVM%E5%8F%82%E6%95%B0/"/>
      <url>/2020/06/17/%E5%B8%B8%E7%94%A8JVM%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>HotSpot 虚拟机常用配置</p><table><thead><tr><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>-Xms1g</td><td>最小堆内存</td></tr><tr><td>-Xmx4g</td><td>最大堆内存</td></tr><tr><td>-XX:+UseG1GC</td><td>使用G1垃圾回收器</td></tr><tr><td>-Xss256k</td><td>每个线程栈大小256k</td></tr><tr><td>-XX:MetaspaceSize=256m</td><td>元数据区大小256M</td></tr><tr><td>-XX:MaxMetaspaceSize=256m</td><td>元数据区最大256M</td></tr><tr><td>-XX:MaxGCPauseMillis=500</td><td>GC最大停顿毫秒数</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>禁用代码中显式调用GC，System.gc()将会失效</td></tr><tr><td>-XX:+UnlockExperimentalVMOptions</td><td>解锁实验参数</td></tr><tr><td>-XX:+UseStringDeduplication</td><td>GC的同时做重复字符串消除，只用于G1</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=60</td><td>启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45.</td></tr><tr><td>-XX:ParallelGCThreads=8</td><td>设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</td></tr><tr><td>-XX:G1MixedGCCountTarget=4</td><td>设置在标记周期完成之后混合收集的数量，以维持old region（也就是老年代）中，最多有G1MixedGCLiveThresholdPercent的存活对象。默认值为8，混合收集的数量将维持在这个值之内。（JVM build &gt; 23）</td></tr><tr><td>-XX:MaxTenuringThreshold=7</td><td>年老代的最大临界值(tenuring threshold). 默认值为 15.</td></tr><tr><td>-XX:+UseGCLogFileRotation</td><td>滚动记录GC日志文件</td></tr><tr><td>-XX:NumberOfGCLogFiles=5</td><td>GC日志文件数量为5个</td></tr><tr><td>-XX:GCLogFileSize=64M</td><td>单个GC日志文件大小64M</td></tr><tr><td>-Xloggc:/app/data/logs/gc-<code>date +%Y%m%d-%H-%M</code>.log</td><td>GC日志文件存储目录和名称</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印GC详情</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>打印GC时时间戳</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>GC时打印堆信息</td></tr><tr><td>-XX:+PrintAdaptiveSizePolicy</td><td>自适应大小策略，每次 GC 后会重新计算 Eden、From 和 To 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB=0</td><td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 调优 </tag>
            
            <tag> 参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用监控与故障处理工具</title>
      <link href="/2020/06/16/%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/06/16/%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟唯一ID（与操作系统进程ID一致）。</p><blockquote><p>jps [option] [hostid]</p></blockquote><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出lvmid，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机启动时传递给主类main（）的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果是jar包，则输出jar路径</td></tr><tr><td>-v</td><td>输出虚拟机启动时的jvm参数</td></tr></tbody></table><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>用于监视虚拟机各种运行状态信息的命令行工具。<br>显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。</p><blockquote><p>jstat [option vimid [interval[s|ms] [count]]]<br>[protocal:][//]lvmid[@hostname[:port]/servername]</p></blockquote><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类装载耗费的时间</td></tr><tr><td>-gc</td><td>监视Java堆状况，包括Eden、Survivor、老年代、永久代的容量，已用空间，垃圾收集时间</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到最大最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集情况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集状况</td></tr><tr><td>-gcoldcapacity</td><td>与-gcold相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法</td></tr></tbody></table><p>每隔1s查询一次2105的gc情况，查询10次。<br>jstat -gc 2105 1000 10</p><p>jstat -gcutil 2105</p><table><thead><tr><th>S0</th><th>S1</th><th>E</th><th>O</th><th>P</th><th>YGC</th><th>YGCT</th><th>FGC</th><th>FGCT</th><th>GCT</th></tr></thead><tbody><tr><td>0.00</td><td>0.00</td><td>6.20</td><td>41.42</td><td>47.20</td><td>16</td><td>0.105</td><td>3</td><td>0.472</td><td>0.577</td></tr></tbody></table><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>实时查看和调整虚拟机各项参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;&#x3D;&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>用于生成堆转储快照，查询finalize执行队列、Java堆和方法区的详细信息（空间使用率、当前使用收集器类型）</p><p>生成堆转储文件的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError 在虚拟机内存溢出异常出现后自动生成堆转储快照文件。</span><br><span class="line">-XX:HeapDumpOnCtrlBreak 使用ctrl+Break 生成堆转储快照文件</span><br><span class="line">kill -3 pid  生成堆转储快照文件</span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;heap.dump 3120</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成java堆转储快照，格式为-dump:[live,]format=b,file=<filename>,live子参数说明是否只dump出存活对象</filename></td></tr><tr><td>-finalizerinfo</td><td>显示再F-Queue中等待Finalizer线程执行finalize方法的对象。只有在Linux平台有效</td></tr><tr><td>-heap</td><td>显示Java堆详细信息，使用回收器类型、参数配置、分代状况，只在Linux平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>在以ClassLoader为统计口径显示永久代内存状态。只在Linux下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应时，可以使用-F强制生成dump快照，只在Linux下有效</td></tr></tbody></table><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>用于分析jmap生成的堆转储快照。 </p><blockquote><p>jhat heap.dump</p></blockquote><p>jhat功能相对简陋，分析工作耗时且耗费硬件资源，一般不在本机使用。<br>替代方案：VisualVM、Eclipse Memory Analyzer、IBM HeapAnalyzer。</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>生成虚拟机当前时刻的线程快照。目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure><h2 id="高级工具"><a href="#高级工具" class="headerlink" title="高级工具"></a>高级工具</h2><h3 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h3><p>基于JMX的可视化监视、管理工具。</p><h3 id="JHSDB"><a href="#JHSDB" class="headerlink" title="JHSDB"></a>JHSDB</h3><p>基于服务性代理实现的进程外调试工具。服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言实现的API集合。<br><img src="/2020/06/16/%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/jhsdb.jpeg" alt="JCMD 和JHSDB工具对比"></p><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>多合一故障处理工具，不需要被监视的程序基于特殊Agent执行，通用性强，对应用程序的实际性能影响较小，可以直接在生产环境使用。</p><h3 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h3><p>可持续在线监控工具。</p><h3 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h3><p>阿里巴巴提供的性能分析工具<br><a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">https://alibaba.github.io/arthas/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 常用工具 </tag>
            
            <tag> 故障排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看Swap</title>
      <link href="/2020/06/12/Linux%E6%9F%A5%E7%9C%8BSwap/"/>
      <url>/2020/06/12/Linux%E6%9F%A5%E7%9C%8BSwap/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Get current swap usage for all running processes</span><br><span class="line"># Erik Ljungstrom 27&#x2F;05&#x2F;2011</span><br><span class="line">SUM&#x3D;0</span><br><span class="line">OVERALL&#x3D;0</span><br><span class="line">for DIR in &#96;find &#x2F;proc&#x2F; -maxdepth 1 -type d | egrep &quot;^&#x2F;proc&#x2F;[0-9]&quot;&#96; ;</span><br><span class="line">do</span><br><span class="line">    PID&#x3D;&#96;echo $DIR | cut -d &#x2F; -f 3&#96;</span><br><span class="line">    PROGNAME&#x3D;&#96;ps -p $PID -o comm --no-headers&#96;</span><br><span class="line">    for SWAP in &#96;grep Swap $DIR&#x2F;smaps 2&gt;&#x2F;dev&#x2F;null| awk &#39;&#123; print $2 &#125;&#39;&#96;</span><br><span class="line">        do</span><br><span class="line">            let SUM&#x3D;$SUM+$SWAP</span><br><span class="line">        done</span><br><span class="line">    echo &quot;PID&#x3D;$PID - Swap used: $SUM - ($PROGNAME )&quot;</span><br><span class="line">    let OVERALL&#x3D;$OVERALL+$SUM</span><br><span class="line">        SUM&#x3D;0</span><br><span class="line">done</span><br><span class="line">echo &quot;Overall swap used: $OVERALL&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> VIM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成器</title>
      <link href="/2020/06/11/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
      <url>/2020/06/11/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
      
        <content type="html"><![CDATA[<h3 id="Centos-简单优化"><a href="#Centos-简单优化" class="headerlink" title="Centos 简单优化"></a>Centos 简单优化</h3><h5 id="安装基本工具"><a href="#安装基本工具" class="headerlink" title="安装基本工具"></a>安装基本工具</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget vim net-tools lrzsz</span><br></pre></td></tr></table></figure><h2 id="删除UUID"><a href="#删除UUID" class="headerlink" title="删除UUID"></a>删除UUID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ifcfg-ens33</span><br><span class="line">vim ifcfg-eth0</span><br><span class="line">vim em1</span><br></pre></td></tr></table></figure><h4 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IPADDR&#x3D;10.0.0.130</span><br><span class="line">GATEWAY&#x3D;10.0.0.2</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">DNS1&#x3D;10.0.0.2</span><br><span class="line">DNS2&#x3D;1.2.4.8</span><br></pre></td></tr></table></figure><h4 id="关闭防火墙以及NetworkManager和SELINX"><a href="#关闭防火墙以及NetworkManager和SELINX" class="headerlink" title="关闭防火墙以及NetworkManager和SELINX"></a>关闭防火墙以及NetworkManager和SELINX</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl disable NetworkManager</span><br></pre></td></tr></table></figure><h4 id="替换YUM源"><a href="#替换YUM源" class="headerlink" title="替换YUM源"></a>替换YUM源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line">cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line">vim CentOS-Base.repo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译与优化</title>
      <link href="/2020/06/11/%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2020/06/11/%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li>前端编译器： JDK的Javac 、EclipseJDT中的增量式编译器（ECJ）</li><li>即时编译器：HotSpot虚拟机的C1\c2编译器、Graal编译器</li><li>提前编译器：JDK的Jaotc、GNU Compiler for Java, Excelsisor JET.</li></ul><h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p>编译过程分为1个准备过程和3个处理过程：<br>1）初始化插入式注解处理器<br>2）解析与填充符号表</p><ul><li><p>语法、词法分析<br>词法分析是将源代码的字符流转变为标记集合的过程，单个字符是程序编写的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记。</p><p>语法分析时根据标记序列构造抽象语法树的过程，抽象语法树是用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表程序代码中的一个语法结构。例如包、类型、修饰符、运算符、接口、返回值、代码注释等。</p><p>经过词法和语法分析生成语法树以后，编译器后续的操作都建立在抽象语法树之上。</p></li><li><p>填充符号表<br>符号表是一组符号地址和符号信息构成的数据结构，符号表中所登记的信息在编译的不同阶段都要被用到。如，在语义分析过程中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，对符号名进行地址分配时，符号表是地址解析分配的直接依据。</p></li></ul><p>3）注解处理器<br>  插入式注解处理器可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器（javac）的工作过程。</p><p>  如果在处理注解期间对语法树进行过修改，编译器将回到解析以及填充符号表的过程重新处理，知道所有插入式注解处理器都没有再对语法树进行修改位置，每次循环称为一个轮次。</p><p>4）语义分析与字节码生成</p><p>语义分析过程分为标注检查和数据以及控制流分析两个步骤。</p><p>在经过语法分析后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查等等。</p><ul><li><p>标注检查<br>检查的内容包括变量是用钱是否已经被声明、变量与赋值之间的数据类型是否能够匹配等等。<br>常量折叠：int a = 1 + 1 ; ==&gt;  int a = 2;</p></li><li><p>数据流以及控制流分析<br>数据流分析以及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检查异常都被正确处理了等问题。<br>编译器的数据以及控制流分析与类加载时的数据以及控制流分析的目的基本哈桑一致，但是校验范围有所区别。</p></li><li><p>解语法糖<br>Java语言的语法糖包含泛型、变长参数、自动装箱拆箱等，Java虚拟机在运行时并不知节支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程称为解语法糖。</p></li><li><p>字节码生成</p><p>字节码生成阶段需要把前面哥哥步骤生成的信息转化成字节码指令写到磁盘中外，还要进行少量的代码添加和转换工作。<br>如实例构造器&lt;init&gt;()方法和&lt;cinit&gt;()方法的添加。<br>如果用户代码中没有提供任何构造函数，那么编译器将会添加一个没有参数的、可访问性与当前类型一致的默认构造函数，这个工作在填充符号表阶段已经完成。</p><p>编译器会把语句块、变量变量初始化、调用父类的实例构造器方等操作收敛到&lt;init&gt;()和&lt;cinit&gt;()方法中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行，</p></li></ul><p><img src="/2020/06/11/%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/javac.jpeg" alt></p><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>泛型、自动装箱、拆箱、遍历循环、变长参数和条件编译、内部类、枚举类、断言、数值直面量、枚举和字符串的switch、try with resource， lambda等。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>类型擦除</p><h4 id="自动装箱、拆箱和循环遍历"><a href="#自动装箱、拆箱和循环遍历" class="headerlink" title="自动装箱、拆箱和循环遍历"></a>自动装箱、拆箱和循环遍历</h4><p>1）大于127的值不会自动拆箱<br>2）没有遇到运算符的情况下不会自动拆箱<br>3）equals方法不处理数据转型</p><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>Java编译器将所有编译但愿的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间可以互相提供符号信息。</p><p>根据条件中布尔值常量值的真假，编译器将把分支中不成立的代码块消除掉。</p><h2 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h2><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。<br>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存。<br>当程序启动以后，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，减少解释器的中间损耗，获得更高的效率。</p><h3 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h3><p>即时编译器将运行比较频繁的代码块或者方法编译成本地机器吗，并且对这段代码进行优化。</p><p>在Hotspot中内置了2个即时编译器 Client Compiler、 Server Compiler。 虚拟机会根据自身版本与宿主机的硬件性能自动选择运行模式，也可以使用-client 或者 -Server 来强制指定虚拟机运行在客户端模式或者服务端模式。</p><p>解释模式(Interperted Mode)：-Xint<br>编译模式(Compiled Mode): -Xcomp<br>混合模式(Mixed Mode): -Xmixed (默认)</p><p>编译器编译本地代码需要占用程序运行时间，位了打到响应速度与运行效率之间打到最佳平衡，HotSpot在编译子系统中加入了分层编译的功能。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次：<br>第0层，程序春解释执行，并且解释器不开启性能监控。<br>第一层：使用客户端编译器将字节码编译为本地代码，进行简单可靠的稳定优化，不开启性能监控功能。<br>第二层：使用客户端编译器执行，仅开启方法以及回边次数统计等优先的性能监控功能。<br>第三层：使用客户端编译器执行，开启全部性能监控，除了第2层的痛就之外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。<br>第四层：使用服务端编译器将字节码编译为本地代码，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</p><p>实施分层编译后， 解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获得更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无需额外承担手机性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时， 客户端编译器可先采用简单优化来为它争取更多的编译时间。</p><h4 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h4><p>被编译的热点代码有：被多次调用的方法和被多次执行的循环体。这两种情况编译的目标对象都是整个方法体，而不是单独的循环体。</p><h4 id="基于采样的热点探测"><a href="#基于采样的热点探测" class="headerlink" title="基于采样的热点探测"></a>基于采样的热点探测</h4><p>周期性的检查线程的调用栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点方法。<br>优点：简单高效，容易获取方法的调用关系<br>缺点：不能精确确认方法的忍睹，容易受到线程阻塞或者外界因素影响扰乱热点探测。</p><h4 id="基于计数器的热点探测"><a href="#基于计数器的热点探测" class="headerlink" title="基于计数器的热点探测"></a>基于计数器的热点探测</h4><p>为每个方法建立计数器，统计方法的执行次数，如果超过一定的阈值就认为它是热点方法。<br>优点：结果精确严谨<br>缺点：每个方法建立并维护计数器，不能直接获取到方法的调用关系。<br>HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器（在循环边界往回跳）,当调用次数超过设定的阈值，就会触发即时编译。<br>-XX:CompileThreshold 来设定触发即时编译的阈值。<br>默认设置下，方法调用计数器统计的是相对执行瓶绿，当一个时间段内调用次数不足以提交即时编时，这个方法的调用计数器就会被减半（衰减），可以使用-XX:-UseCounterDecay关闭热度衰减。可以设置-XX:CounterHalfLifeTime设置半衰周期的时间，单位是秒。</p><p>当方法被调用时，首先检查该方法是否被即使编译器编译过，是则优先使用编译后的版本执行，否则将方法调用的计数器加一，然后判断方法调用计数器与回边计数器值之和是否超过阈值，超过则像即时编译器提交该方法的代码编译请求。<br>如果没有做过任何设置，执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。当编译工作完成后，这个方法的调用入口地址会被系统自动改写成新值，下次调用该方法时就会使用已编译版本。</p><p><img src="/2020/06/11/%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/comp.jpeg" alt="方法调用计数器 触发即时编译"></p><p>回边计数器：统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”,回边计数器的目的是为了触发栈上的替换编译。回边计数器没有热度衰减过程。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>一般情况下，方法调用产生的标准编译请求和栈上替换编译请求，在虚拟机编译器未完成编译之前，都将按照解释方式执行代码，编译动作在后台的编译线程完成。<br>设置-XX:-BackgroundCompilation禁止后台编译，禁止后触发即时编译条件时，执行线程向虚拟机提交编译请求后一致阻塞等待，直到编译过程完成后再开始执行编译器输出的本地代码。</p><p>服务端编译器效率较低，但是编译速度远超传统的静态优化编译器，相对于客户端编译器编译输出的代码质量有很大的提交，可以大幅降低本地代码的执行时间，从而抵消掉额外的编译水间开销。</p><h3 id="即时编译的缺点"><a href="#即时编译的缺点" class="headerlink" title="即时编译的缺点"></a>即时编译的缺点</h3><p>1）占用程序运行时间<br>2）占用程序运算资源</p><h2 id="提前编译器"><a href="#提前编译器" class="headerlink" title="提前编译器"></a>提前编译器</h2><p>提前编译器的分支：<br>与传统C、C++编译器类似，在程序运行之前把程序代码编译成机器码的静态翻译工作；<br>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接加载进来使用。</p><h2 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h2><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>最重要的优化技术之一。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>最前沿的优化技术之一。</p><ul><li><p>栈上分配<br>支持方法逃逸，但不支持线程逃逸</p></li><li><p>标量替换<br>如果一个数据已经无法在分解为更小的数据表示时（原始数据类型），这些数据就可以称为标量。<br>标量替换就是将用到的成员变量恢复为原始类型来访问的过程。<br>加入逃逸分析可以证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候可能不去创建这个对象，而改为直接创建它的若干个被这个的方法使用的成员变量来替代，成员变量存储在栈上。</p><p>同步消除：如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定不会有竞争，对这个变量的同步措施也可以安全地消除掉。</p></li></ul><h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>语言无关的经典优化技术。如果一个表达式E之前已经被计算过，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。</p><h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>语言相关的经典优化技术。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 编译 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配与回收</title>
      <link href="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
      <url>/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p>Java技术体系的自动内存管理最根本目标是自动化地给对象分配内存以及自动回收分配给对象的内存。<br>《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪种垃圾收集器，以及虚拟机中与内存相关的参数设定。</p><h2 id="HotSpot虚拟机中对象的分配原则"><a href="#HotSpot虚拟机中对象的分配原则" class="headerlink" title="HotSpot虚拟机中对象的分配原则"></a>HotSpot虚拟机中对象的分配原则</h2><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>在大多数情况下，对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时，虚拟机将发起一次minorGC。<br>当survivor区的空间无法存放Eden区的对象时，就会通过担保机制提前转移到老年代去。</p><p>-Xms:20M 堆内存初始值20M<br>-Xmx:20M 堆内存最大20M<br>-Xmn10M  新生代占用10M（剩下的10M留给老年代）<br>-XX:SurvivorRatio=8 决定了新生代Eden区与一个Survivor区的空间比例是8:1:1</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象是需要大量连续内存空间的Java对象，如很长的字符串或者元素数量很多的数组。</p><p>在分配空间时，如果对象比较大，就会提前触发垃圾收集，以获取足够的连续空间才能存放该对象， 当复制对象时大对象意味着高额的内存复制开销。</p><p>-XX:PretenureSizeThreshold=3145728 （大于3M的对象会直接分配到老年代中）<br>该参数只对Serial和ParNew两款收集器有效。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>内存回收时必须决策那些存活对象应该存放在新生代，哪些存活对象存放在老年代。<br>虚拟机为每个对象定义了一个对象年龄（Age）存储在对象头重。</p><p>对象通常在Eden区诞生，如果经过一次MinorGC后仍然存活，并且能被Survivor容纳的话，会被移动到Survivor空间，并且将对象的年龄设置为1岁。对象在Survivor中每经过一次MinorGC，Age增加1， 当年龄增加到一定程度的时候，该对象会被移动到老年代中。<br>可以通过-XX:MaxTenuringThreshold设置（默认为15次）。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需等到-XX:MaxTenuringThreshold中要求的年龄。</p><p>也就是当前Survivor空间大小为1M，有两个Age=1且大小为256k的对象时，这两个对象就会直接进入老年代。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生MinorGC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。<br>如果条件成立，那么这次MinorGC时安全的；；<br>如果不成立，虚拟机会先查看-XX:HandlerPromotionFailure参数的设置值是否允许担保失败<br>   如果允许担保失败，继续检查老年代最大可用的连续空间是否大于历次今生到老年代对象的平均大小<br>      大于，尝试进行一次MinorGC；<br>      小于，或者-XX:HandlePromotionFailure不允许冒险，则变更为FullGC。</p><p>在JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代总大小或者历次晋升的平均大小，就会进行MinorGC，否则就进行FullGc。-XX:HandlePromotionFailure参数不在生效。</p><h2 id="垃圾的回收"><a href="#垃圾的回收" class="headerlink" title="垃圾的回收"></a>垃圾的回收</h2><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><h4 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h4><ul><li>引用计数器</li><li>可达性分析算法（固定可作为GCRoot的对象有）<ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如每个线程背调用的方法堆栈中使用的参数、局部变量、临时变量</li><li>在方法区中类静态属性引用的对象，如Java类的引用类型静态变量</li><li>在方法区中常量引用的对象，如字符串常量池中的引用</li><li>在本地方法栈中JNI引用的对象</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器</li><li>所有背同步锁持有的对象</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul></li></ul><h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><ul><li>强引用，如Object obj = new Object(); 无论任何情况下，只要强引用关系存在，垃圾收集器就永远不会回收掉背引用的对象。</li><li>软引用，描述有用但非必须的对象，被软引用关联的对象在系统将要发生内存溢出前会把这些对象例如回收范围内进行二次回收。（SoftReference）</li><li>弱引用，描述非必须对象，被弱引用的对象只能生存到下一次垃圾收集发生位置。无论内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用，一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的时为了能在这个对象被收集器回收时受到一个系统通知（NIO用的RdirectMemory）</li></ul><h2 id="垃圾收集器算法"><a href="#垃圾收集器算法" class="headerlink" title="垃圾收集器算法"></a>垃圾收集器算法</h2><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>建立在两个分代假说上：<br>1）弱分代假说，绝大数对象都是朝生夕灭的。<br>2）强分代假说，经过越多次收集过程的对象月难消亡。<br>3）（推理假说）跨代引用假说，跨代引用相对于同代来说仅占极少数。</p><h5 id="分代收集区域"><a href="#分代收集区域" class="headerlink" title="分代收集区域"></a>分代收集区域</h5><ul><li>部分收集（Partial GC）<ul><li>新生代收集（Minor GC/ Yong GC）</li><li>老年代收集（Major GC / Old GC）（只有CMS会单独回收老年代）</li><li>混合收集(Mixed GC)，目前只有GC存在混合回收行为。</li></ul></li><li>整堆收集(Full GC)</li></ul><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记需要被回收的对象后，回收掉所有被标记的对象；<br>或者标记不需要被回收的对象，同一回收未被标记的对象。</p><p>缺点：<br>不稳定，标记清除的性能随着对象的增多而降低；<br>空间碎片化问题，肯能会导致在分配较大对象时无法找到足够的连续空间内存不得不提前触发另一次垃圾收集动作。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/ms.jpeg" alt="mark-sweep"></p><h4 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h4><p>为了解决标记清除算法面对大量可回收对象时执行效率低的问题。</p><p>优点：只需要复制少数存活对象，简单高效<br>缺点：浪费内存空间。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/mc.jpeg" alt="mark-copy"></p><p>根据弱分代假说，以及实际情况，大部分的对象在第一次垃圾回收时就会被回收，因此并不需要按照1:1的比例来划分新生代的内存空间。<br>内存被分为较大的Eden区和较小的两个Survivor区域，HotSpot默认比例是8:1:1。<br>打给你Survivor空间不足容纳一次MinorGC后存活的对戏那个时，就需要依赖其他内存区域进行分配担保。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>根据老年代对象的存亡特征以及强分代假说提出的算法。<br>将所有存活的对象向内存空间的一端移动，然后直接清理掉边界以外的内存。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/mark-compact.jpeg" alt="mark-compact"></p><p>吞吐量：赋值器和收集器的效率总和。<br>如果在清理时移动，必然会影响到对象回收的效率。<br>如果清理时不移动，必然会影响到对象分配的效率。</p><h2 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h2><h4 id="Serial-SerialOld"><a href="#Serial-SerialOld" class="headerlink" title="Serial / SerialOld"></a>Serial / SerialOld</h4><p>Serial收集器是最古老的收集器，使用标记拷贝算法，在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。<br>优点：在内存较小的桌面应用或者Client模式下，额外内存消耗最小，简单高效。</p><p>SerialOld同样是单线程收集起，使用标记整理算法。当CMS收集起发生失败时会转为SerialOld工作。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/serialGC.jpeg" alt="Serial GC"></p><h4 id="PS-PO"><a href="#PS-PO" class="headerlink" title="PS / PO"></a>PS / PO</h4><p>Paralle Scavenge/ Paralle Old 的目标是达到一个可控的吞吐量。</p><p>ParalleScavenge 同样是基于标记-复制算法，支持多线程并发收集，<br>吞吐量 = （运行用户代码时间）/(运行用户代码时间+运行垃圾收集时间)<br>-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间<br>-XX:GCTimeRatio 控制垃圾收集时间占总时间的比率<br>-XX:+UseAdaptiveSizePolicy 就不需要人工指定新生代的大小，Eden于Survivor的比例，以及晋升老年代的大小，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><p>ParalleOld 收集老年代，基于标记整理算法。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/pspo.jpeg" alt="Paralle Scavenge / Paralle Old"></p><h4 id="ParNew-CMS"><a href="#ParNew-CMS" class="headerlink" title="ParNew / CMS"></a>ParNew / CMS</h4><p>ParNew是Serial收集器的多线程并行版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集起完全一致。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/ParNewSerialOld.jpeg" alt="ParNew / SerialOld"></p><p>CMD是一种以获取最短回收停顿时间为目的的收集器。符合希望系统停顿时间尽可能短，以给用户带来良好交互体验的需求。他是一种标记-清除算法实现的。<br>包含四个步骤：<br>1）初始标记<br>2）并发标记<br>3）重新标记<br>4）并发清除</p><p>其中初始标记和重新标记这两个步骤仍需要STW。<br>初始标记仅仅只是标记一下GC Roots能直接关联到的对象、速度很快；<br>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长，但不需要停顿用户线程，可以与垃圾收集线程一起并发运行；<br>重新标记为了修正并发标记期间因为用户程序继续运行导致标记产生变动的部分，这个阶段比初始标记耗时稍长；<br>并发清除，清理删除掉标记阶段判断已经死亡的对象，不需要移动哦存活对象，因此这个阶段也是与用户线程同时并发。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/cms.jpeg" alt="CMS"></p><p>CMS缺点：<br>1） 耗CPU资源<br>2） 无法处理浮动垃圾，由于预留的内存无法分配新对象时，有可能出现回收失败而导致退化到Serial Old的模式收集。<br>3）分配占用大空间的对象时，会出现老年代还有很多剩余空间，但是无法找到足够大的连续空间分配对象，不得不提前触发FullGC。<br>提供了两个参数优化，但是JDK1.9之后已经废弃：<br>-XX:UseCMS-CompactAtFullCollection 不得不进行FullGC时开启内存碎片的合并整理。<br>-XX:CMSFullGCsBefore-Compaction，要求CMS收集器在执行过若干次不整理空间的FullGC之后，下一次进入FullGC前进行碎片整理。</p><h4 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h4><p>G1时一款主要面向服务端应用的垃圾收集器。</p><p>在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p><p>G1面向堆内存任何部分来组成回收集（CollectionSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的MixedGC模式。</p><p>G1把连续的Java堆内存划分为多个大小相等的独立区域（Region），每个Region都可以根据需要扮演 新生代的Eden空间Survivor空间，或者老年代空间。收集器能够对不同角色的Region采用不同的=策略取处理，这样无论是新创建的对象还是存活了一段时间、经过多次收集的旧对象都能获得很好的收集再熬过。</p><p>Region中有一类Humongous区域专门存放大对象。 G1认为只要大小超过了一个Region容量的一般的对象就可以判定为大对象。每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围1MB～32MB，且应为2的N次幂。那些超过了整个Region容量的超级大对象，会被存放在N个连续的HumongousRegion之中，G1的大多数行为都把HumongousRegion作为老年代的一部分进行看待。</p><p>G因为将Region作为单词回收的最小单元，所以可以建立可预测的停顿时间模型。<br>每次根据用户设置的停顿时间-XX:MaxGCPauseMillis， 优先处理回收价值收益最大的那些Region。<br>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在悠闲的时间内获取尽可能高的收集效率。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/G1Region.jpeg" alt="G1 Region"></p><h5 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h5><p>1）跨Region引用的对象： 每个Region都维护自己的记忆集避免全堆作为GCRoots扫描， 这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。<br>G1的记忆集是一种Hash表，Key时别的Region的起始地址，Value时一个集合，里面存储的元素时卡表的索引号。这种双向的卡表结构记录了我指向谁和谁指向了我，因此G1只少需要耗费大约10%～20%的额外内存来维持收集工作。</p><p>2）在并发阶段如何保证收集线程与用户线程互不干扰地运行？<br>用户线程在改变对象引用关系的时候，必须保证不能打破原本的对象图结构，导致比阿吉结果出现错误，<br>CMS使用增量更新算法，G1使用原始快照算法来实现。</p><p>垃圾收集对用户线程的影响还体现在回收过程中心窗卷对象的内存分配上，程序要继续运行就肯定会持续有新对象呗创建，G1位每个Region设计了两个名为TAMS（TOp at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时心分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象时被隐式标记过的，不纳入回收范围。如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致FullGC而产生长时间的STW。</p><p>3）如何建立可靠的停顿模型<br>G1的停顿预测模型时以衰减均值为理论基础实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可以测量的步骤话费的成本，并分析得出平均值，标准偏差、可行度等统计信息，衰减平均值时比普通的平均值更容易受到新数据的影响，平均值更容易受到新数据的影响，平均值代表整体平均状态，衰减均值代表最近的平均状态。 Region的统计状态越新越能决定器回收的价值。通过这些信息预测现在开始回收的话，哪些region组成回收集采可以在不超过期望停顿时间的约束下获得最高的收益。</p><h4 id="G1的回收步骤"><a href="#G1的回收步骤" class="headerlink" title="G1的回收步骤"></a>G1的回收步骤</h4><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p> 只标记一下GCRoots能直接关联到的对象，并且修改TAMS指针的值，让下一个阶段的用户线程并发运行时，能正确滴在可用的Region中分配新对象。这个阶段需要停顿线程，但是耗时短，而且是借用进行MinorGC的时候同步完成，所以G1收集器在这个阶段实际并没有额外的停顿。</p><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>从GCRoots开始对对子红对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但是可以和用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p><h5 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h5><p>对用户线程做另外一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p><h5 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a>筛选回收</h5><p>负责更新Region的统计数据，对哥哥Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间，对存活对象移动时必须暂停用户线程，但是由多条线程完成的。</p><p><img src="/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/g1.jpeg" alt="G1"></p><p>G1从整体上来看是基于标记整理算法，但从局部来看时基于标记复制算法。无论如何，这两种算法意味着G1再与性期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发限一次收集。</p><p>G1位了垃圾收集产生的内存占用以及额外的执行副在都比CMS搞。<br>内存占用是由于双向卡表占用空间大。CMs只记录了老年代到新生代的卡表记录。</p><p>负载：CMS用写后屏障维护更新卡表；<br>G1除了使用写后屏障维护卡表外，位了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发前的指针变化。 原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点。</p><p>CMS的写屏障是同步操作，G1使用的是消息队列，把写前屏障和写后屏障中要做的事情都放在队列里，再异步处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存分配 </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程和并发</title>
      <link href="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>目前线程是java中进行处理器资源调度的最基本单位。（Loom项目正在尝试改变线程这一重量级的实现）</p><p>实现线程的方式主要有三种：</p><ol><li>使用内核线程1:1实现；<br>内核系统就是由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</li></ol><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/1.1.jpeg" alt="内核线程"></p><ol start="2"><li>使用用户线程1:n实现；</li></ol><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/1.n.jpeg" alt="用户线程"></p><ol start="3"><li>使用用户线程价轻量级进程混合实现（n：M实现）</li></ol><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/m.n.jpeg" alt="混合实现"></p><h2 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h2><p>《Java虚拟机规范》中没有限定使用哪种线程模型来实现，主流平台上的主流商用Java虚拟机线程模型普遍都给予操作系统原生线程模型来实现（1:1的线程模型）</p><h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，调度方式分为两种：</p><ul><li>协同式线程调度<br>线程的执行时间由线程本身来控制，线程把自己的工作执行完之后，同志系统切换到另外一个线程。</li><li>抢占式线程调度<br>每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。<br>Java可以使用thread.yield()方法主动让出执行时间，但是并不能主动获取执行时间。</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>我们并不能在程序中通过优先级来完全准确判断一组状态都为Ready的线程先执行哪一个？</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>Java语言定义了6中线程状态，在任意一个时间点中， 一个线程只能有且只有一种状态，并且可以通过特定的方法在不同状态之间转换。</p><ul><li>新建：new，创建后尚未启动的线程处于新建状态；</li><li>运行：runnable，包括操作系统线程状态中的Running和Ready，</li><li>等待：Waiting，处于这种状态的线程不会被分配处理器执行时间，它们需要被其他线程显示唤醒。<br>以下方法可以让线程无限期等待：<ul><li>没有设置timeout参数的Object.wait()方法；</li><li>没有设置timeout参数的Thread.join()方法；</li><li>LockSupport.part()方法；</li></ul></li><li>限期等待：处于这种状态的线程也不会被分配处理器执行时间，在一定时间后会有系统自动唤醒。<ul><li>Thread.sleep()</li><li>设置了Timeout的Object.wait()</li><li>设置了Timeout的Thread.join()</li><li>LockSupport.parkNanos();</li><li>LockSupport.parkUntil();</li></ul></li><li>阻塞：Blocked，在程序等待进入同步区域的时候，线程将进入阻塞状态。</li><li>结束: Terminated，已终止线程的线程状态，线程已经结束执行。</li></ul><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/ThreadState.jpeg" alt="线程状态图"></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要执行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><p>也就是代码本身封装了所有必要的正确性保障手段，令调用者无序关心多线程下的调用问题，更无需自己实现任何措施来保证多线程环境下的正确调用。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>在Java语言中，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。</p><p>只要一个不可变的对象被正确的构建出来，那其外部的可见状态永远都不会改变，永远都不会看到他在多个线程之中处于不一致的状态。</p><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对的线程安全除了对象本身外， 还需要在调用端做相应的同步措施。</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>保证这个对象在单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。在Java中，相对线程安全的类型有Vector、HashTable、Collections.synchronizedCollection();</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>对象本身并不是线程安全的， 但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全使用。<br>Vector、HashTable、ArrayList、HashMap等都是线程兼容的。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>如果两个线程同时持有一个线程对象，一个尝试去中断线程、一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在思索的风险。（Thread类的suspend和resume方法），常见的对立操作还有System.in() System.out()和System.runFinalizersOnExit();</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>用互斥来实现同步。<br>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。<br>互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。<br>因此它面临的问题是进行线程阻塞和唤醒所带来的性能开销，因此也叫阻塞同步。<br>属于一种悲观的并发策略。</p><h5 id="synchronized（非公平锁）"><a href="#synchronized（非公平锁）" class="headerlink" title="synchronized（非公平锁）"></a>synchronized（非公平锁）</h5><h5 id="java-util-concurrent-locks-Lock"><a href="#java-util-concurrent-locks-Lock" class="headerlink" title="java.util.concurrent.locks.Lock"></a>java.util.concurrent.locks.Lock</h5><h5 id="ReentrantLock（非公平锁）"><a href="#ReentrantLock（非公平锁）" class="headerlink" title="ReentrantLock（非公平锁）"></a>ReentrantLock（非公平锁）</h5><p>  可重入锁比synchronized增加了一些高级功能：</p><ul><li>等待可中断<br>当持有锁的线程长期不释放所得时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li>公平锁<br>多个线程在等待同一个锁的时候，必须按照申请锁的时间顺序依次获得锁。</li><li>锁绑定多个条件<br>一个ReentrantLock对象可以同时绑定多个Condition对象， 多次调用newCondition()即可。</li></ul><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>基于硬件冲突检测的乐观并发策略，也就是说先进性操作，如果没有其他线程争用共享数据，操作成功；<br>如果共享数据被争用，产生冲突，那么再进行其他的补偿措施，最常用的补偿措施就是不断重试，直到成功。<br>这种方式不需要阻塞线程，因此也叫无锁编程。<br>常用的具有原子性的硬件操作和冲突检测指令有：</p><ul><li>测试并设置（Test-And-Set）</li><li>获取并增加（Fetch-And-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare And Swap）</li><li>加载链接/条件存储（Load-Linked/ Store-Conditional）</li></ul><p>Java中暴露出来的是CAS指令，当CAS指令执行时，当且仅当内存地址V的值符合预期值A时，处理器才会用新的值B更新内存地址V的值，该过程是一个原子操作，执行期间不会被其他线程中断。</p><p>CAS存在的ABA问题，大部分情况下不会影响程序并发的正确性，如果需要解决该问题，传统的互斥同步可能会比原子类更为高效。</p><h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>如果可以让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的。</p><ul><li>可重入代码<br>如果一个方法的返回结果是可预测的，只要输入了相同的数据，就就能返回相同的结果，那么它就满足可重入性的要求，当然他就是线程安全的。<br>可重入代码不依赖于全局变量、存储在队上的数据和公用的系统资源，用到的状态量都由参数重传入，比调用非可重入的方法等。</li><li>线程本地存储<br>如果一段代码中使用的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。这样就可以把共享数据的可见范围限制在一个线程之内。<br>常见的有生产者消费者模式（Web交互模型）。<br>ThreadLocal的使用。</li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h4 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h4><p>互斥同步的时候需要对线程进行挂起和恢复，但是挂起和恢复需要陷入内核态来完成。<br>因此当一个线程获取锁的时候，如果暂时没有获取到，那么让他稍微等一会儿，但不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁。</p><p>如果锁被占用很长的时间，那么自旋的线程只会白白消耗处理器资源。因此自旋等待时间必须有一定的限度。<br>如果自旋超过了限定的次数，仍然没有成功获得锁，就应当使用传统方式去挂起线程。</p><h5 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h5><p><a href="https://www.jianshu.com/p/824b2e4f1eed" target="_blank" rel="noopener">几种自旋锁的java实现</a><br><a href="https://www.jianshu.com/p/9d3660ad4358?utm_source=oschina-app" target="_blank" rel="noopener">认真的讲一讲：自旋锁到底是什么</a><br><a href="https://www.cnblogs.com/cxuanBlog/p/11679883.html" target="_blank" rel="noopener">看完你就明白的锁系列之自旋锁</a></p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>虚拟机即使编译器在运行时，判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当作栈上的数据对待，认为他们是线程私有的，消除同步锁的过程。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的， 可以把加锁同步的范围扩展到整个操作序列的外部。 </p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>Hotspot对象头分为两部分：<br>1）用于存储对象自身运行的数据，如哈希吗，GC分代年龄。这部分数据的长度在32位和64位的Java虚拟机中分别占用32个或者64比特。这部分是实现轻量级锁和偏向锁的关键。<br>2）用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分存储数组长度。</p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，MarkWord被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。<br>它会根据对象的状态服用自己的存储空间。<br>在32位的Hotspot虚拟机中，对象未被锁定的状态下，MarkWord的32个比特空间有25个比特用于存储对象的哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特股定位0（表示未进入偏向模式）。对象除了违背锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种状态。</p><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/light_.jpeg" alt></p><p>如果代码即将进入同步块的时候，如果此同步对象没有被锁定（标志位位01），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（LockRecord）的空间,用于存储锁对象目前的MarkWord的拷贝。</p><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/markword.jpeg" alt></p><p>然后虚拟机将使用CAS操作尝试把对象的markword更新为指向LockRecord的指针。如果这个更新成功，那么代表该线程拥有了这个对象的锁，并且对像MarkWord的锁标志位将转变为00，表示此对象处于轻量级锁定状态。</p><p>如果更新操作失败，意味着至少存在一个线程与当前线程竞争获取该对象的锁。虚拟机首先检查对象的MarkWord是否只想当前线程的栈帧，如果是，说明线程已经拥有了这个对象的锁，那么直接进入同步块继续执行，否则说明这个对象已经被其他线程抢占了。<br>如果出现两条以上的线程争用同一个锁的情况，那么轻量级锁不再有效，必须要膨胀为重量级锁，锁标志的状态变为10， 此时Markword中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。</p><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/light_lock.jpeg" alt></p><p>它的解锁过程也是通过CAS来进行的，如果对象的MarkWord仍然指向线程的锁记录，那就用CAS操作把对象当前的MarkWord和线程中复制的DisplacedMarkWord替换回来，如果替换成功，说明解锁成功。<br>替换失败，说明有其他线程尝试过获取该锁，需要在释放锁的同时唤醒被挂起的线程。</p><p>如果没有竞争，轻量级锁能通过CAS操作成功避免使用互斥量的开销；<br>如果存在竞争，除了互斥量本身开销外，还额外发生了CAS操作的开销，因此性能更差。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>用于消除数据在无竞争情况下的同步，连CAS都去掉了，进一步提高程序的运行性能。<br>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一致没有被其他的线程获取，则持有偏向锁的线程永远不需要再同步。</p><p>如果当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式。<br>同时使用CAS操作把获取到这个锁的线程ID记录在对象的MarkWord中。<br>如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块是，虚拟机都可以不再进行任何同步操作。</p><p>一旦出现另外一个线程尝试获取这个锁的情况，偏向模式马上宣告结束。<br>根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（把偏向模式设置为0），撤销后标志位恢复到为锁定或者轻量级锁定的轧辊台，后续的同步操作按照轻量级锁执行。</p><p><img src="/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/pian.jpeg" alt="偏向锁"></p><p>当进入偏向状态是，MarkWord大部分的空间都用于存储持有锁的线程ID，这部分空间占用了原有存储对象Hash码的位置。当一个对象已经计算过一次一致性哈希码后，它就再也无法进入偏向锁状态。<br>当一个对象正在处于偏向锁状态时，受到计算hash码的请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。</p><p>在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态下的MarkWork，其中自然可以存储原来的哈希码。</p><p>偏向锁可以提高带有同步但无竞争的程序性能，但如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO-2</title>
      <link href="/2020/06/07/IO-2/"/>
      <url>/2020/06/07/IO-2/</url>
      
        <content type="html"><![CDATA[<p>多路复用器：<br>select/poll/epoll</p><p>man 2 select </p><p>man 2 poll</p><p>2.链路层，3网络层，4传输层<br>封存あ记忆</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2020/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>1) 可重入锁<br>CAS<br>2）同步：<br>3）信号量<br>公平锁、非公平锁、读写锁、自旋锁<br>分布式锁， 悲观锁、乐观锁, 锁续租</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节码执行引擎</title>
      <link href="/2020/06/05/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2020/06/05/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>当代码被编译成二进制字节码，由Classloader加载到内存，经过加载、验证、准备、解释后将数据转化为JVM可以接受的格式存储到方法区，并在堆内存中创建一个Class对象，作为外部访问的入口。<br>接下来就由字节码执行引擎来解释执行代码。</p><p>《Java》虚拟机规范中规定了Java虚拟机字节码执行引擎的概念模型，输入字节码二进制流，输出执行结果。</p><p>在不同的虚拟机实现中，执行引擎在执行字节码的时候会有两种：</p><ul><li>解释执行（Sun Classic 虚拟机）</li><li>编译执行（Jrockit）</li><li>两种兼备 (HotSpot)</li></ul><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机方法进行调用和执行的数据结构，每个方法从调用开始到执行结束的过程，都对应一个栈帧从虚拟机栈中入栈到出栈的过程。</p><p>栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p><p><img src="/2020/06/05/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/stackframe.jpeg" alt="栈帧"></p><p>栈帧中需要多大的局部变量表、多深的操作数栈在编译Java的时候就已经计算出来存放在方法表的Code属性中。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>用于存放方法参数和方法内部定义的局部变量。</p><p>在代码被编译成Class文件时，在方法的Code属性中max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽应该可以存放一个boolean、byte、char、short、int、float、reference、returnAddress这8种不超过32位数据类型（对于超过32位的long和double，则使用两个32位的变量槽）。</p><p>引用类型：</p><ul><li>通过引用可以找到这个对象在堆中的数据存放的起始地址或者索引；</li><li>找到对象所属类型在方法区中的存储类型；</li></ul><p>returnAddress是为字节码指令jsr、jsr_w 和ret服务，指向了一条字节码指令的地址，一些jvm使用这几条指令来实现异常处理时的跳转。<br>现在全部改为采用异常表来代替。</p><p>当一个方法被调用的时候，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，如果是实例方法局部变量表第0位索引的变量槽存放的是this。</p><blockquote><p>以恰当的变量作用域来控制变量的回收时间才是最优雅的解决方法，而不是使用完后就将其引用赋予null， 因为这仅仅是基于虚拟机的概念模型层面作出的优化，虚拟机的具体实现不同，解释执行与编译执行结果都不同。</p></blockquote><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>一个后入先出的栈，同局部变量表一样，操作数栈的最大深度也在编译的时候就被写入到Code属性的max_stacks数据项中。32位数据类型所占用的栈容量是1， 64位数据类型所占的栈容量是2.</p><p>通过将操作数入栈出栈来进行算术运算；<br>通过操作数栈将方法的参数进行传递；</p><h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用时为了支持方法调用过程中的动态连接。</p><p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令以常量池指向方法的符号引用作为参数。</p><p>这些符号引用一部分在类加载阶段或者第一次使用会被转化为直接引用；<br>另一部分在每次运行期间都转化为直接引用，这部分称为动态连接；</p><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>当一个方法退出以后，必须返回到最初方法被调用时的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，来帮助恢复主调方法的执行状态。</p><p>一个方法的退出有两种方式：<br>第一种是执行引擎遇到方法返回的字节码指令；主调方法的PC计数器的值就可以作为返回地址。<br>另一种是遇到了异常，并且在本方法的异常表中没有搜索到匹配的异常处理器导致方法退出；</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用阶段的任务是确认被调用方法的版本。<br>Class文件的编译过程不包含传统程序语言的连接步骤，一切方法调用在Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址。因此一些调用需要在加载期间，甚至到运行期间才能确定目标方法的直接引用。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>在类加载的解析阶段，将静态方法和私有方法对应的符号引用转化为直接引用。因为静态方法与类关联，私有方法不可能被继承或者重写，在编译阶段即可确定。</p><p>字节码指令集设计了不同的指令调用不同类型的方法：</p><ul><li>invokestatic, 调用静态方法</li><li>invokespecial, 调用实例构造器方法，私有方法，父类中的方法。</li><li>invokevirtual, 用于调用所有的虚方法（被final修饰的方法）</li><li>invokeinterface,用于调用接口方法，会在运行时再确定一个实现接口的对象</li><li>invokedynamic, 在运行时动态解析出调用点限定符引用的方法。</li></ul><p>前四条指令，分派逻辑都固化在Java虚拟机内部，invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</p><p>只要能被invokestatic 和 invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本。Java语言中符合这个条件的方法有静态方法、构造方法、私有方法、父类方法和被final修饰的方法,这五种方法被称为非虚方法，其他的被称为虚方法。</p><p>解析调用是一个静态的过程， 在类加载的解析阶段就把涉及的符号引用转换为明确的直接引用，不必延迟到运行期再去完成。</p><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><ul><li><p>静态分派<br>所有依赖静态类型来决定方法执行版本的分派叫做静态分派。静态分派的典型应用表现是方法重载。<br>方法重载发生在同一个类中，方法名称相同，参数列表不同。</p></li><li><p>动态分派与实现<br>在运行期根据时机类型确定方法执行版本的分派过程叫动态分派，它就是Java语言中方法重写的本质。多态的根源在于虚方法调用指令invokevirtual的执行逻辑，因此多态只对方法有效，对字段无效（字段永远不参与多态）。</p><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接受着类型方法元数据中搜索合适的目标方法，</p></li><li><p>单分派和多分派<br>方法的接收者（要被执行的方法的所有者叫接收者）与参数统称为方法的宗量。<br>单分派是根据一个宗量对目标方法进行选择；<br>多分派是根据多个宗量对目标方法进行选择；</p></li></ul><h4 id="Java中的解释执行与编译执行"><a href="#Java中的解释执行与编译执行" class="headerlink" title="Java中的解释执行与编译执行"></a>Java中的解释执行与编译执行</h4><p><img src="/2020/06/05/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpeg" alt="编译过程"></p><p>在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树。</p><p>对于C/C++来说，词法、语法分析以后到后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整有意义的编译器去实现，这类就是编译执行。</p><p>对于Java来说，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再便利语法树生成线性的字节码指令流的过程。</p><h4 id="基于栈的指令集与给予寄存器的指令集"><a href="#基于栈的指令集与给予寄存器的指令集" class="headerlink" title="基于栈的指令集与给予寄存器的指令集"></a>基于栈的指令集与给予寄存器的指令集</h4><ul><li>基于栈的指令集<br>零地址指令，依赖操作数栈进行工作，<br>优点是可移植性高，不与具体的硬件绑定。编译器实现简单。<br>缺点是速度慢。</li><li>给予寄存器的指令集<br>而地址指令集，物理硬件直接支持的指令集架构，依赖寄存器工作。</li></ul><blockquote><p>虚拟机最终会对执行过程作出一系列优化来提高性能， 实际的情况会和盖面模型差距非常大，差距产生的根本原因是虚拟机中解析起和即时编译起都会对输入的字节码进行优化，即使解释其中也不是按照字节码指令去逐条执行的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节码执行引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd</title>
      <link href="/2020/06/04/etcd/"/>
      <url>/2020/06/04/etcd/</url>
      
        <content type="html"><![CDATA[<p>培养良好的生活、学习、工作习惯。</p><p>相关概念：</p><ul><li>Etcd</li><li>coreOS</li><li>RancherOS</li></ul><h3 id="主机规划："><a href="#主机规划：" class="headerlink" title="主机规划："></a>主机规划：</h3><blockquote><p>要求：主机名称规范、IP段相邻、备注明确</p></blockquote><table><thead><tr><th>主机序号</th><th>名称</th><th>内网IP</th><th>外网IP</th><th>CPU核数</th><th>内存大小</th><th>备注</th></tr></thead><tbody><tr><td>01</td><td>etcd-node-master-01</td><td>10.0.0.1</td><td>外网IP</td><td>2</td><td>4G</td><td>备注</td></tr><tr><td>02</td><td>etcd-node-slave-02</td><td>10.0.0.2</td><td>外网IP</td><td>2</td><td>4G</td><td>备注</td></tr><tr><td>03</td><td>etcd-node-slave-03</td><td>10.0.0.3</td><td>外网IP</td><td>2</td><td>4G</td><td>备注</td></tr></tbody></table><h3 id="设置主机名称"><a href="#设置主机名称" class="headerlink" title="设置主机名称"></a>设置主机名称</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname etcd-node-master-01</span><br><span class="line">hostnamectl set-hostname etcd-node-slave-02</span><br><span class="line">hostnamectl set-hostname etcd-node-slave-03</span><br></pre></td></tr></table></figure><h3 id="修改内网IP地址："><a href="#修改内网IP地址：" class="headerlink" title="修改内网IP地址："></a>修改内网IP地址：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure><h3 id="重启网关："><a href="#重启网关：" class="headerlink" title="重启网关："></a>重启网关：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h3 id="防火墙设置："><a href="#防火墙设置：" class="headerlink" title="防火墙设置："></a>防火墙设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;2379&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="YUM安装："><a href="#YUM安装：" class="headerlink" title="YUM安装："></a>YUM安装：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y etcd</span><br></pre></td></tr></table></figure><h4 id="验证-amp-查看版本"><a href="#验证-amp-查看版本" class="headerlink" title="验证&amp;查看版本"></a>验证&amp;查看版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa etcd</span><br><span class="line">etcdctl -v</span><br></pre></td></tr></table></figure><h3 id="修改配置："><a href="#修改配置：" class="headerlink" title="修改配置："></a>修改配置：</h3><p>分别修改3个主机的配置文件/etc/etcd/etcd.conf</p><blockquote><p>注意！修改前一定要备份！<br>   cp /etc/etcd/etcd.conf /etc/etcd/etcd.conf.bak</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ETCD_LISTEN_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2379,http:&#x2F;&#x2F;127.0.0.1:2379&quot;</span><br><span class="line">ETCD_NAME&#x3D;Master</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER&#x3D;“Master&#x3D;http:&#x2F;&#x2F;10.0.0.1:2380,Node02&#x3D;http:&#x2F;&#x2F;10.0.0.2:2380,Node03&#x3D;http:&#x2F;&#x2F;10.0.0.3:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN&#x3D;&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE&#x3D;&quot;new&quot;</span><br></pre></td></tr></table></figure><h4 id="重启etcd服务"><a href="#重启etcd服务" class="headerlink" title="重启etcd服务"></a>重启etcd服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart etcd</span><br></pre></td></tr></table></figure><h4 id="查看Etcd集群"><a href="#查看Etcd集群" class="headerlink" title="查看Etcd集群"></a>查看Etcd集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member list</span><br></pre></td></tr></table></figure><h4 id="Etcd-测试"><a href="#Etcd-测试" class="headerlink" title="Etcd 测试"></a>Etcd 测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcdctl set name test</span><br><span class="line">etcdctl get name</span><br></pre></td></tr></table></figure><h5 id="扩展概念"><a href="#扩展概念" class="headerlink" title="扩展概念"></a>扩展概念</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">负载均衡：</span><br><span class="line">区域负载均衡：DNS</span><br><span class="line">硬件负载均衡：F5&#x2F;A10</span><br><span class="line">软件负载均衡：Nginx&#x2F;LVS&#x2F;HAProxy</span><br><span class="line"></span><br><span class="line">磁盘阵列：raid</span><br><span class="line">防火墙技术：硬件&#x2F;软件</span><br><span class="line"></span><br><span class="line">NTP（Network Time Protocal）是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化tongbuwang。</span><br><span class="line"></span><br><span class="line">Radis的分布式缓存;</span><br><span class="line">mysql主从、读写分离、高可用、分库分表；</span><br><span class="line"></span><br><span class="line">MHA</span><br><span class="line">备份</span><br><span class="line">elk </span><br><span class="line">ci&#x2F;cd</span><br><span class="line">centos8 &#x2F; podman</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Etcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时数据区域</title>
      <link href="/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>当一个类加载到内存后，JVM运行时数据区域都需要存储什么东西呢？</p><p>1）类的格式信息、主次版本号、 常量池、字段、方法、属性信息需要存储，这部分数据需要每个线程共享；<br>   当类加载器将静态的二进制字节码从类文件加载到内存后，对内容进行验证、解析转换为符合JVM存储的数据格式。</p><p>2）生成的Class类对象和代码运行时动态创建的对象和数组需要存储；<br>   通过loading、linking、initializing后生成的Class对象，做为程序访问这个类的入口，<br>   以及程序运行时产生的对象和数组，都有可能会被不同的线程引用和访问，因此这部分区域的数据也需要线程共享。<br>3）每个线程的线程数据需要存储和每个线程下方法的方法数据需要存储；<br>   当线程创建的时候需要有一个线程栈来存放线程信息，以及PC计数器记录当前线程正在执行的代码行号。<br>   还有JVM本地线程执行时需要的本地线程栈存放本地线程的执行情况。</p><p>《Java虚拟机规范》规定了如下内存区域来存储数据</p><blockquote><ul><li>共享区域</li></ul></blockquote><ul><li>堆区</li><li>方法区<ul><li>运行时常量池</li><li>线程私有区域</li></ul></li><li>JVM线程栈</li><li>本地方法栈</li><li>PC计数器</li></ul><p><img src="/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/runtime_dataarea.webp" alt="Runtime DataArea"></p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>  几乎所有的对象以及数组都存放在堆区。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>  用于存储已经被虚拟机加载的类型信息、常量、静态变量、及时编译器变异后的代码缓存等数据。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>  运行时常量池是方法区的一部分，用于存放编译期或者运行期生成的各种字面量和符号引用。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>   每个线程会生成一个线程栈，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口信息。</p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、long 、float、double）、引用类型、returnAddress类型。<br>      这些数据类型在局部变量表中的存储空间以局部变量槽来表示（64位的long和double占用2个变量槽，其余数据类型占用1个变量槽）。局部变量表所需的内存空间在编译期完成分配，因此当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是确定的。在运行期间是不会改变局部变量表的大小（槽的多少）。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈作用类似，为虚拟机使用到的本地方法服务。</p><h3 id="PC计数器"><a href="#PC计数器" class="headerlink" title="PC计数器"></a>PC计数器</h3><p>   当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>对于JDK1.8以后HotSpot虚拟机改用与Jrokit、J9一样与本地内存中实现的元空间（Meta-space）来实现方法区。无论是原空间还是永久代，他们只是方法区的实现，字符串常量池和静态变量的存储逻辑上仍然属于方法区。元空间使用的是物理内存、永久代使用的是JVM内存。因此元空间的大小只受限于物理内存。</p><p><img src="/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/hotspot_runtimearea.png" alt="HotSpot 虚拟机实现"></p><h2 id="HotSpot-虚拟机对象的创建与引用"><a href="#HotSpot-虚拟机对象的创建与引用" class="headerlink" title="HotSpot 虚拟机对象的创建与引用"></a>HotSpot 虚拟机对象的创建与引用</h2><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>1） 在new一个对象的时候，先需要通过类加载检查，然后虚拟机为新生对象分配内存。</p><p>对象所需要的内存大小在类加载完成后便可以完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p><ul><li>指针碰撞<br>假设内存规整，将使用过的在一边，空闲的在一边，中间放一个指针作为分界点的指示器，所分配内存就是把指针向空闲空间方向挪动一段与对象相等的距离。<br>使用Serial、ParNew带压缩整理过程的GC收集器时，采用指针碰撞，简单高效；</li><li>空闲列表<br>假设内存不规整，是一块块不连续的，那么就需要维护一个列表记录哪块内存可用，哪块内存不可用，在分配的时候在列表中找一块足够大的空间划分给对象实例，并更新列表上的记录。<br>使用CMS基于清除算法的收集器时，理论上只能采用复杂的空闲列表来分配内存。</li></ul><h5 id="Thread-Local-Allocation-Buffer"><a href="#Thread-Local-Allocation-Buffer" class="headerlink" title="Thread Local Allocation Buffer"></a>Thread Local Allocation Buffer</h5><p>在堆中创建对象是特别频繁的事情，并且涉及到多线程的访问。如何保证高效且安全的申请空间？</p><ul><li>同步或者CAS+失败重试的方式保证更新操作的原子性；</li><li>为每个线程在堆中预先分配一小块内存，通过-XX:+/-UseTLAB 设定；</li></ul><p>2）分配完内存后，为内存空间初始化零值以及必要的设置。<br>初始化零值可以保证对象实例字段在Java对象中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。<br>之后设置这个对象的类型、关联类的元数据信息、GC分代年龄信息等。</p><p>3）执行 &lt;init&gt;() 方法，将对象进行初始化。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在Hotspot虚拟机中，对象在内存中的存储布局划分为三个部分</p><ul><li>对象头（Header）<ul><li>一部分是对象自身运行时数据，HashCode, GC分代年龄，锁状态标志，线程持有锁，偏向线程ID,偏向时间戳（数组长度）。</li><li>一部分是类型指针，指向它的类型元数据的指针，用来确定是哪个类的实例。</li></ul></li><li>实例数据（Instance Data）<br>字段的存储顺序受到虚拟机分配策略（-XX:FieldsAllocationStyle）和字段在源码中的顺序影响。<br>默认相同宽度的字段被分配到一起存放，父类中定义的变量会出现在子类之前。<br>使用+XX:CompactFields=true字类中较窄的变量也会插入到父类变量的空隙之中。</li><li>填充（Padding）<br>为了满足硬件的性能需求和提高垃圾回收时指针扫描的方便性。HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8个字节的整数倍（任何对象的大小必须是8个字节的整数倍）。</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>对象在堆中创建好了，Java程序会通过栈上局部变量表中的reference字段来引用堆上的对象。</p><ul><li>句柄访问<br>Java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自具体的地址信息。<br>好处：reference中存储的事稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针。<br><img src="/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/jubing.jpeg" alt="句柄访问"></li><li>直接指针<br>reference中存储的是对象的地址。好处是速度快，节约了指针定位的时间开销。<br><img src="/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/direct.jpeg" alt="直接指针"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 运行时区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/2020/06/02/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/06/02/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>计算机为了提升效率，增加了多内核，并且为每个内核增加了自己的高速缓存，而他们又共享同一个主内存。</p><p><img src="/2020/06/02/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/jmm01.jpeg" alt="计算机处理器、高速缓存、主内存之间的交互关系"></p><p>除了增加高速缓存外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，但保证结果与顺序执行的结果一致。</p><p>与处理器的乱序执行优化类似，Java虚拟机的即时编译器也有指令重排序优化。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>《Java虚拟机规范》中曾试图定义一种Java内存模型来屏蔽各种硬件和操作系统的内存访问差异。</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java内存模型的主要目的是定义程序中各种变量的访问规则（关注虚拟机中把变量存储到内存和从内存中取出变量的底层细节。）<br>Java内存模型规定了所有的变量都存储在主内存（除线程私有的以外）。<br>线程的工作内存保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存的数据。不同的线程之间也无法直接访问对方工作内存的变量，线程之间变量值的传递均需要通过主内存来完成。</p><p><img src="/2020/06/02/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/jmm02.jpeg" alt></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间的交互协议，Java内存模型中定义了8种的操作。</p><p>Java虚拟机实现时必须保证每种操作都是原子的，不可再分的（对于double和long来讲，load、store、、read、write允许有例外）。</p><ul><li><p>lock ： 锁定，作用于主内存的变量，把一个变量标识为一条线程独占的状态。</p></li><li><p>unlock: 解锁，作用于主内存的变量，把一个处于锁定状体的变量释放出来，释放后的变量才可以被其他线程锁定。</p></li><li><p>read: 读取，作用于主内存的变量，把一个变量的值从主内存传输到工作内存，以便随后的load动作使用。</p></li><li><p>write: 写入，作用于主内存的变量，把store操作从工作内存中得到的变量值存放到主内存变量中。</p></li><li><p>load: 载入，作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p>use：使用，作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p></li><li><p>assign: 赋值，作用于工作变量，把一个从执行引擎接收的值赋给工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p></li><li><p>store: 存储，把工作内存中一个变量的值传送到内存中，以便随后的write操作使用。</p></li></ul><p>Java内存模型规定必须满足如下规则：</p><blockquote><p>1) 不允许read 和 load、store和write操作单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写单主内存不接受<br>2）不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。<br>3）不允许一个线程在没有发生assign操作就把数据从线程的工作内存同步回主内存中。<br>4) 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load\assign）的变量,即对一个变量进行use之前必须使用load， 使用store之前必须使用assign。。<br>5）一个变量在同一个时刻内只允许一个线程对其进行lock操作， 但lock操作可以被同一个线程重复执行多次， 多次执行lock后， 只有执行相同次数的unlock操作，变量才会被解锁。<br>6)对一个变量执行unlock之前， 必须先把此变量同步回主内存中（执行store、write操作）</p></blockquote><h3 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h3><p>volatile是Java虚拟机最轻量级的同步机制。它有两个特性：<br>1）保证此变量对于所有线程的可见性（一个线程修改了这个变量的值，其他线程立即可见，也就是每个线程在使用被volatile修饰的变量时，都会强制从主内存中同步该变量的值到工作内存中）<br> 在不符合以下两条规则的场景中，仍然需要通过加锁来保证原子性（synchronized、java.util.concurrent中的锁或者原子类）：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；</li><li>变量不需要与其他状态变量共同参与不变约束；</li></ul><p>2） 禁止指令重排序优化</p><p>volatile变量读操作的性能与普通变量几乎没有差别，但是写操作会慢些， 因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><h4 id="Singleton-DoubleCheck"><a href="#Singleton-DoubleCheck" class="headerlink" title="Singleton DoubleCheck"></a>Singleton DoubleCheck</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private volatile static Singleton instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    instance &#x3D; new Singleton(); &#x2F;&#x2F;warning</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，instance = new Singleton()最终会被编译成多条汇编指令。<br>（1）为Singleton的实例分配内存。<br>（2）调用Singleton的构造函数，初始化成员变量<br>（3）将instance对象指向分配的内存空间。</p><p>或者可能被重排序为(1)、(3)、（2）， 也就是当分配内存后，如果没有对instance 加volatile，将instance对象指向分配的内存空间后，另外一个线程可以读到未被初始化的对象。</p><h3 id="针对long和double类型变量的特殊规则"><a href="#针对long和double类型变量的特殊规则" class="headerlink" title="针对long和double类型变量的特殊规则"></a>针对long和double类型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、write、 load、assign、use、store这8种操作都具有原子性，但是对于64位数据类型的long 和double, 在模型中定义了一条宽松的规定， 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为2次32为的操作来执行，也就是虚拟机自己选择是否要保证64位数据类型的load、store、read、write这四个操作的原子性。</p><p>经过实际的测试，在目前的主流平台下商用的64位Java虚拟机中并不会出现非原子性访问行为，但是对于32位的Java虚拟机（如32位的X86Hotspot）存在非原子性访问的风险。</p><p>因此，在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码的时候一般不需要因为这个原因刻意把用到的long和double变量专门声明位volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><h5 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h5><p>有Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write。因此基本数据类型的访问都是具备原子性的。</p><p>如果应用场景需要一个更大范围的保证，需要使用锁、或者synchronized关键字来保证原子性。<br>（lock、unlock并没有直接开放给用户使用）。</p><h5 id="可见性（visibility）"><a href="#可见性（visibility）" class="headerlink" title="可见性（visibility）"></a>可见性（visibility）</h5><p>可见性就是当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p><h6 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h6><p>volatile的特殊规则保证了新值立即能同步到主内存，以及每次使用前都立即从主内存刷新。而普通变量则不能保证“立即”。</p><h6 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h6><p>同步块的可见性时由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得。</p><h6 id="final"><a href="#final" class="headerlink" title="final"></a>final</h6><p>被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么在其他线程中就能看见final字段的值。</p><blockquote><p>this引用逃逸，其他线程有可能通过这个引用访问到“初始化了一般”的对象。</p></blockquote><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>如果在本线程中观察，所有的操作都是有序的（线程内似表现为串行的语义）；<br>如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟现象）；</p><p>Java语言提供了volatile和sychronized两个关键字来保证线程之间的有序性。<br>volatile：本身包含了禁用指令重排序的语义；<br>synchronized：一个变量在同一时刻只允许一个线程对其进行lock操作；</p><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生原则：判断数据是否存在竞争，线程是否安全的重要手段。</p><p>程序次序规则：在一个线程内，按照控制流顺序（分支、循环等），书写在前面的操作先行发生在书写在后面的操作；</p><p>管程锁定规则：一个unlock的操作先行发生在后面对同一个锁的操作。</p><p>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作；</p><p>线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作；</p><p>线程的中止规则：线程中所有的操作都先行发生于此线程的终止检测，可以通过thread.join()方法是否结束、thread.isAlive()返回值来检测线程是否已经停止；</p><p>线程的终端规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过thread.interrupted()检测是否有中断发生；</p><p>对象终结规则：一个对象初始化完成（构造函数执行结束）先行发生于他的finalize()方法的开始；</p><p>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出，操作A先行发生于操作C。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器和类加载机制</title>
      <link href="/2020/06/01/ClassLoader/"/>
      <url>/2020/06/01/ClassLoader/</url>
      
        <content type="html"><![CDATA[<p>Java代码要在JVM中正常运行，首先要先编译成.class文件，由类加载器将其加载到内存中。之后由类编译器来编译执行。<br>在加载的过程中需要注意什么呢？<br>1）什么时候需要加载一个类呢？<br>2）随便任何一个文件都是否可以被加载呢，它的加载过程是什么样的？<br>3）类加载器需要对内存中的内容做什么工作才可以被JVM直接使用？</p><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Class类型，这就是虚拟机的类加载机制。—《深入理解Java虚拟机》</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型的加载、链接和初始化过程都是在程序运行期间完成的。</span><br><span class="line">Java可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</span><br></pre></td></tr></table></figure><h1 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h1><p>  Java虚拟机规范并没有规定什么时候加载类，但是规定了什么时候初始化一个类。</p><p>  虚拟机规范严格规定了有且只有5中情况必须立即对类进行“初始化”。<br>  1）遇到new、getstatic、putstatic、invokestatic；<br>  2）初始化类的时候，对父类进行初始化；<br>  3）JVM执行的时候，对主类进行初始化；<br>  4）使用java.lang.reflect包的方法对类进行反射调用时；<br>  5）使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandler实例最后解析结果是REF_getstatic, REF_putstatic, REF_invokestatic时，对该类进行初始化；<br>  6) jdk1.8中子类实现的接口中定义了default方法时；</p><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p>类的加载过程总共分为：Loading（加载）、Linking（连接）、Initializing（初始化）、Using（使用）、Unloading（卸载）。<br>其中 Linking阶段 分为 Verification（验证）、Preparation（准备）、Resolution（解析）。</p><p><img src="/2020/06/01/ClassLoader/ClassLoader.jpeg" alt="ClassLoader"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段的成果是生成Class类对象，并将该对象存储在堆中。Class对象作为访问该对象数据的访问入口。<br>加载的步骤：<br>1） 根据类的全限定名读取类的二进制字节流；<br>2） 对二进制字节流进行解析转换，并将类信息存储在方法区中；<br>3） 堆中生成Class类对象，作为程序访问方法区中的类型数据的外部接口；</p><blockquote><p>注意：<br>数组类不通过类加载器创建，由java虚拟机直接在内存中动态构造出来的。<br>数组的元素类型（去掉所有维度）要靠类加载器加载完成。<br>数组的组件类型（去掉一个维度）是引用类型，数组将被标识在加载该组建类型的类加载器的类名称空间上。<br>如果数组的组件类型不是引用类型，Java虚拟机会把数组标记为与引导类加载器关联。</p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证加载的类信息是否符合Java虚拟机规范，类的实现和继承、方法的执行、对象和方法的可访问性等等，主要分为四个阶段：</p><p>1）文件格式的验证<br>   主要对Class文件中内容进行验证，是否符合Java虚拟机规范。<br>   比如魔数、常量池的类型、指向常量的索引值是否存在或者类型是否正确等等；</p><blockquote><p>这个阶段的验证是基于二进制字节流进行的，只有通过了验证才会被允许进入Java虚拟机的内存方法区存储。</p></blockquote><p>2）元数据验证<br>   对字节码描述信息进行语义分析，保证描述信息符合《Java语言规范》比如:</p><ul><li>这个类是否有父类、父类是否允许继承（被final修饰）；</li><li>这个类是否实现了父类所要求实现的所有方法；</li><li>类中的字段、方法是否与父类产生矛盾；</li></ul><p>3）字节码验证<br>   对类的方法体进行验证，保证任何跳转指令都不会跳转到方法体以外的字节码指令上；<br>   保证类型转化都是有效的.</p><p>4）符号引用验证</p><blockquote><p>虚拟机在解析阶段将符号引用转化为直接引用的时候，对符号引用进行验证；</p></blockquote><ul><li>符号引用中通过字符串描述的全限定名能否找到对应的类；</li><li>在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段；</li><li>符号引用中的类、字段、方法的可访问性是否可以被当前类访问；</li></ul><p>符号引用阶段抛出的异常有：IllegalAccessError、NoSuchFieldError、NoSuchMethodError；</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量分配内存并设置类变量初始值的阶段；</p><p>对于类变量（静态属性），设置的是“零值”，真正赋值是在初始化阶段；<br>对于常量（final static），会被设置为ConstantValue属性所指定的初始值。</p><blockquote><p>对于常量，Javac时会为value生成ConstantValue属性。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池的符号引用替换为直接引用的过程。《Java虚拟机规范》并没有规定何时进行解析。</p><ul><li>符号引用：可以无歧义的定位到目标即可；与虚拟机的内存布局无关；引用的目标不一定已经加载到虚拟机中；必须遵循《Java虚拟机规范》；</li><li>直接引用：直接可以指向目标的指针、偏移量，或者可以间接定位到目标的句柄；与虚拟机的内存布局直接相关；直接引用的目标一定已经加载到虚拟机内存中；</li></ul><p>解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符号引用进行。</p><h5 id="类、接口解析："><a href="#类、接口解析：" class="headerlink" title="类、接口解析："></a>类、接口解析：</h5><p>虚拟机的完整解析过程：<br>1）如果不是一个数组类型，虚拟机将会把全限定名传给当前类的加载器去加载，在加载的过程中，由于元数据验证、字节码验证的需要，又可能出发其他相关类的加载动作。<br>2）如果是一个数组类型，并且数组的元素类型为对象，那么会按照第一点的规则加载数组元素类型。如果是基础数据类型包装类，那么由虚拟机生成一个代表该数组唯独和元素的数组对象；<br>3）前面两部解析OK后进行符号引用验证，确定当前类是否有加载类的访问权限。</p><p>如果一个类拥有另外一个类的访问权限，那么至少有一条是成立的：<br>1）被访问类是public的，并且与访问类处于同一个模块；<br>2）被访问类是public的，不与访问类处于同一个模块，但是被访问类的模块允许访问类访问；<br>3）被访问类不是public的，但是与访问类处于同一个包中</p><h5 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h5><p>对字段表内class_index项中索引的CONSTANT_Class_Info符号引用进行解析（即字段所属类）</p><p>1）先查找当前类是否包含了简单名称与描述符与目标相匹配<br>2）从下往上的顺序查找实现的接口类<br>3）从下往上的顺序查找父类<br>4）都无法查找到，抛出java.lang.NoSuchFieldError.</p><p>如果查找成果返回了引用，将会对这个字段进行权限验证，对于不具备权限的访问会抛出IllegalAccessError；</p><h5 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h5><p>解析出方法表class_index项中索引的方法所属的类或者接口的符号引用。<br>具体的解析过程与字段解析类似。</p><h5 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h5><p>与方法解析类似。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这个阶段Java虚拟机才真正开始执行类中编写的程序代码。程序在这个阶段初始化类变量和其他资源。</p><p>初始化阶段也是执行&lt;clinit&gt;()的过程。<br>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的；<br>编译器收集顺序是由语句在源文件中出现的顺序决定的；<br>静态语句块中智能访问到定义在静态语句块之前的变量；<br>定义在静态语句块后的变量，静态语句块可以赋值，但是不能访问；<br>Java虚拟机保证父类的&lt;clinit&gt;() 总是优先于子类的&lt;clinit&gt;()执行；</p><blockquote><p>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器可以不为这个类生成clinit()方法。</p></blockquote><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器主要通过一个类的全限定名来获取描述该类的二进制字节流，它处于Java虚拟机的外部，方便让应用程序自己决定如何获取所需的类。</p><p>对于任意一个类，必须由加载它的类加载器与类本身来确定在Java虚拟机中的唯一性。<br>每个类加载器都拥有一个独立的类名称空间。</p><h3 id="类加载器的双亲委派模型"><a href="#类加载器的双亲委派模型" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h3><p><img src="/2020/06/01/ClassLoader/ClassLoader02.webp" alt="双亲委派模型"></p><p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应有自己的父“类加载器”。<br>当类加载器需要加载一个类的时候，首先看该类是否已经被加载，如果没有被加载则尝试着让父“类加载器”去加载，如果没有父“类加载器”则让bootstrapClassLoader作为父“类加载器”，如果父“类加载器”加载失败，则使用自己的find_class方法去加载。</p><ul><li>启动类加载器（Bootstrap Class Loader）<br>启动类加载器负责加载&lt;JAVA_HOME&gt;\lib 目录下的jar包（按名字识别，名字不符合的类库存放在lib目录下也不会被加载），也可以指定 -Xbootclasspath参数指定加载目录。启动类加载器无法被java程序直接引用。</li><li>扩展类加载器（Extension Class Loader）<br>扩展类加载器负责加载&lt;JAVA_HOME&gt;\lib\ext目录下的jar包，或者被java.ext.dirs指定的路径这种的所有类库。这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码实现的。</li><li>应用程序类加载器（Application Class Loader）<br>负责加载用户类路径上的所有类库。这个类加载器是在sun.misc.Launcher$AppClassLoader实现。</li></ul><h5 id="定制自己的类加载器"><a href="#定制自己的类加载器" class="headerlink" title="定制自己的类加载器"></a>定制自己的类加载器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        String path = <span class="string">"/classes/"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path + name.replace(<span class="string">"."</span>, File.separator) + <span class="string">".class"</span>);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] classData = baos.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(<span class="keyword">null</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">"com.*.ClassLoader"</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        System.out.println(clazz.getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> ClassLoader </tag>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构</title>
      <link href="/2020/05/29/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2020/05/29/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机规范规定Class文件格式统一采用一种类似于C语言结构体的伪结构体来存储数据，<br>这种伪结构体存储两种数据类型：无符号数和表。</p><p>无符号数：属于基本的数据类型，以u1、u2、u4、u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码结构构成的字符串值。</p><p>表：由多个无符号数或者其他表作为数据项构成的符合数据类型，所以表都习惯性地以_info结尾。<br>表用于描述有层次关系的符合结构的数据，整个Class文件就是一张表，由下表中数据项构成。</p><table><thead><tr><th>类型</th><th>名称</th><th>个数</th></tr></thead><tbody><tr><td>u4</td><td>Magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flag</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interface_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interface_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>method_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>每个Class文件的头四个字节称为魔数，其值的16进制表示为0xCAFEBABE（换算为二进制为1100 1010 1111 1110 1011 1010 1011 1110），虚拟机在加载类时分析该文件是否为Class文件。</p><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>第5、6个字节表示次版本号。第7、8个字节表示主版本号。<br>高版本的JDK能够向下兼容低版本的Class文件，虚拟机会拒绝执行超过其版本的Class文件。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>常量池中存放两大类常量：</p><ul><li>字面量常量：<br>比较接近Java语言层面的常量概念，比如字符串和被声明为final的常量值。对于范围在-127～128之间的包装类型也是常量。</li><li>符号引用常量：属于编译原理方面的概念，包含<ol><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol></li></ul><p>常量池的大小不固定，用两个字节表示，第零项空出来，为了满足某些指向常量池的索引值的数据“不引用任何一个常量池项目”。</p><p>常量池的每一项常量都是一个表，这个表的第一位都是一个u1类型的标识位。</p><p>下面是常量池中的14种项目类型：<br><img src="/2020/05/29/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/14kindsofconstants.webp" alt="常量池中的14种项目类型"></p><p>下面是常量池中的14种项目类型的结构表：</p><p><img src="/2020/05/29/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/14kindsofconstantsdetail1.webp" alt="常量池中的表类型"></p><p><img src="/2020/05/29/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/14kindsofconstantsdetail2.webp" alt="常量池中的表类型"></p><table><thead><tr><th>常量池中数据项类型</th><th>类型标志</th><th>类型描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8</td><td>1</td><td>UTF-8编码的Unicode字符串</td></tr><tr><td>CONSTANT_Integer</td><td>3</td><td>int类型字面值</td></tr><tr><td>CONSTANT_Float</td><td>4</td><td>float类型字面值</td></tr><tr><td>CONSTANT_Long</td><td>5</td><td>long类型字面值</td></tr><tr><td>CONSTANT_Double</td><td>6</td><td>double类型字面值</td></tr><tr><td>CONSTANT_Class</td><td>7</td><td>对一个类或接口的符号引用</td></tr><tr><td>CONSTANT_String</td><td>8</td><td>String类型字面值</td></tr><tr><td>CONSTANT_Fieldref</td><td>9</td><td>对一个字段的符号引用</td></tr><tr><td>CONSTANT_Methodref</td><td>10</td><td>对一个类中声明的方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref</td><td>11</td><td>对一个接口中声明的方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType</td><td>12</td><td>对一个字段或方法的部分符号引用</td></tr></tbody></table><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>访问标志标示了当前类的修饰符，比如 public / final / super / interface /  enum / abstract / annotation / synthetic</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x00 01</td><td>是否为Public类型</td></tr><tr><td>ACC_FINAL</td><td>0x00 10</td><td>是否被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x00 20</td><td>是否允许使用invokespecial字节码指令的新语义．</td></tr><tr><td>ACC_INTERFACE</td><td>0x02 00</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x04 00</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x10 00</td><td>标志这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x20 00</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>０x40 00</td><td>标志这是一个枚举</td></tr></tbody></table><h4 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h4><ul><li>类索引：this_class, 用于确定这个类的全限定名</li><li>父类索引：super_class, 父类索引用于确定这个类的父类的全限定名</li><li>接口索引集合：interfaces, 用于描述这个类实现了哪些接口</li></ul><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>字段表集合（field_info）用于描述接口或者类中声明的变量，包含类变量和实例变量，但不包含方法内部声明的局部变量。</p><p>|类型|名称|数量|<br>|—-|—-|—-|—-|<br>|u2 |access_flag|1|访问修饰符|<br>|u2 |name_index | 1| 字段的简单名称,如String str = “123”, str就是简单名称|<br>|u2 |descritpor_index|1| 字段或者方法的描述符|<br>|u2 |attributes_count |1 |  |<br>|attribute_info | attributes | attributes_count| |</p><p>访问修饰符</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><p>描述符：<br>描述符的作用是用来描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。<br>根据描述符的规则：基本数据类型以及代表无返回值的void类型都用一个大写的字符来表示;<br>而对象类型则用字符L加对象的全限定名来描述;</p><table><thead><tr><th>标志符号</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>void 按照先参数列表后返回值的顺序描述，参数列表按照顺序放在”()”内部，String toString()描述为V()java.lang.String</td></tr><tr><td>L</td><td>对象类型</td></tr><tr><td>[</td><td>数组类型 [I: 代表int[], [[I:代表int[][]</td></tr></tbody></table><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class 文件中对方法的描述和对字段的描述完全是一致的， 方法表中的结构和字段表中的接口一样。</p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有ACC_VOLATILE和ACC_TRANSIENT。 但是增加了synchronized,native,abstract,strictfp(strict float point, 精确的浮点数)关键字的修饰符。<br>对于方法里的代码，经过编译器变异常字节码指令后，存放在方法属性表中一个名为code的属性里。</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x00 01</td><td>方法是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x00 02</td><td>方法是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x00 04</td><td>方法是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x00 08</td><td>方法是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x00 10</td><td>方法是否为final</td></tr><tr><td>ACC_SYHCHRONRIZED</td><td>0x00 20</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x00 40</td><td>方法是否是有编译器产生的方法</td></tr><tr><td>ACC_VARARGS</td><td>0x00 80</td><td>方法是否接受参数</td></tr><tr><td>ACC_NATIVE</td><td>0x01 00</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x04 00</td><td>方法是否为abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x08 00</td><td>方法是否为strictfp （strict-float-point,精准的浮点数）</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x10 00</td><td>方法是否是有编译器自动产生的</td></tr></tbody></table><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>在Class文件、字段表、方法表中都可以携带自己的属性表集合（attribute_info）,用于描述某些场景的专有信息。</p><p>不强制要求各属性表的顺序，只要不与已有属性表重名即可。<br>任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机在运行时会忽略不认识的属性。</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类，方法，字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Synthetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>表，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td></tr><tr><td>RuntimeInvisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存invokeddynamic指令引用的引导方式限定符</td></tr></tbody></table><p>对于看了文章还有点懵的同学，看这里的视频讲解，忽略广告。《<a href="https://www.bilibili.com/video/BV1xJ41167VH?p=1" target="_blank" rel="noopener">全网最牛JVM字节码结构分析、Class类文件核心结构</a>》。</p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Class结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2020/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2020/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本系列为《深入理解Java虚拟机》的读书笔记。<br>少量来源于网络，视频教材。</p></blockquote><h3 id="如何设计一个虚拟机"><a href="#如何设计一个虚拟机" class="headerlink" title="如何设计一个虚拟机"></a>如何设计一个虚拟机</h3><p>假设自己要写一个虚拟机，应该考虑什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虚拟机要运行什么？</span><br><span class="line">如何把规范的文件内容读取到内存中？</span><br><span class="line">读取到内存中的数据如何存储？</span><br><span class="line">如何执行这些规范文件中的数据翻译成操作系统认识的指令？</span><br><span class="line">执行完成后如何清理？</span><br></pre></td></tr></table></figure><h3 id="虚拟机的主要功能以及组成"><a href="#虚拟机的主要功能以及组成" class="headerlink" title="虚拟机的主要功能以及组成"></a>虚拟机的主要功能以及组成</h3><p>虚拟机要运行代码，这些代码要定制一个规范，这样虚拟机才可以根据制定好的规范去解析和执行。对于Java虚拟机来讲，它要读取的文件就是Class类文件。<br>我们需要一段代码把Class类文件内容读取到内存中，同时要注意判断，读取的文件内容是否符合Class类文件的规范，同时文件内容是否会危害到虚拟机。<br>把文件内容读取到内存中后，如何存放、方便管理和使用，同时要保证性能、安全性。<br>把这些文件内容“翻译”为操作系统认识的指令，并且操控这些指令按照预定的“规则”运行，达到可预期的结果。为了提升效率需要考虑多线程和并发。<br>执行完成后，清理不需要的内存空间，以便其他程序使用(JVM规范中并没有规定垃圾回收部分)。</p><blockquote><p>JVM虚拟机不包含ClassLoader部分</p></blockquote><p><img src="/2020/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm.jpg" alt="jvm"></p><h3 id="虚拟机相关知识传送门"><a href="#虚拟机相关知识传送门" class="headerlink" title="虚拟机相关知识传送门"></a>虚拟机相关知识传送门</h3><ul><li><input checked disabled type="checkbox"> <a href="/2020/05/29/类文件结构">类文件结构</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/01/ClassLoader">类加载器和类加载机制</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/02/JVM运行时数据区域">JVM运行时数据区域</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/05/字节码执行引擎">字节码执行引擎</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/02/JVM内存模型">JVM 内存模型</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/08/线程和并发">线程和并发</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/10/内存分配与回收">内存分配与回收</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/11/编译与优化">编译与编译优化技术</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/16/常用监控与故障处理工具">常用监控与故障处理工具</a></li><li><input checked disabled type="checkbox"> <a href="/2020/06/17/常用JVM参数">常用的JVM参数</a></li></ul><p>扩展阅读：<a href="https://blog.csdn.net/brave2211/article/details/20380971" target="_blank" rel="noopener">深入理解Java虚拟机到底是什么</a></p><p>Java虚拟机是一种抽象的计算机，它模拟了一套自己的硬件体系结构（处理器、堆栈、指令集和寄存器）。<br>不同的平台有着不同的实现版本，屏蔽了平台的差异性。使得不同平台上的虚拟机可以运行被javac编译的同一份.class文件。</p><p>关于JVM的面试题：<br><a href="https://juejin.im/post/5d22f4e8e51d455a68490bf4" target="_blank" rel="noopener">24个Jvm面试题总结及答案</a><br><a href="https://blog.csdn.net/qq_41701956/article/details/100074023" target="_blank" rel="noopener">常见JVM面试题及答案整理</a><br><a href="https://blog.csdn.net/HarderXin/article/details/104066411" target="_blank" rel="noopener">2020年JVM面试题吐血整理【过年必看】</a><br><a href="https://www.jianshu.com/p/54eb60cfa7bd" target="_blank" rel="noopener">总结的JVM面试题</a><br><a href="https://zhuanlan.zhihu.com/p/56903960" target="_blank" rel="noopener">面试必问的JVM应该怎么学（面试题含答案）</a><br><a href="http://www.spring4all.com/article/18645" target="_blank" rel="noopener">大厂面试经：高频率JVM面试问题整理！</a><br><a href="https://www.bilibili.com/read/cv4094201/" target="_blank" rel="noopener">2019年JVM面试都问了什么？快看看这22道面试题！（附答案解析）</a><br><a href="https://xie.infoq.cn/article/b783efac59c5817b886329321" target="_blank" rel="noopener">JVM 面试题 68 问，面试又可以多扯一个小时了！</a><br><a href="https://segmentfault.com/a/1190000021290506" target="_blank" rel="noopener">【搞定Jvm面试】 Java 内存区域揭秘附常见面试题解析</a></p>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime快捷键</title>
      <link href="/2019/05/29/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/05/29/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h4><p>cmd + [ | Left Indent<br>cmd + ] | Right Indent<br>cmd + ctrl + up | Swap line up<br>cmd + ctrl + down | swap line down<br>cmd + shift + d | Duplicate line<br>cmd + J | Jone Lines.<br>cmd + Left | Beginning Of Line<br>cmd + Right | End of Line<br>cmd + ctrl + / | Toggle comment block<br>ctrl + K | Delete To End.<br>ctrl + shift + K | Delete Line<br>ctrl + T | swap words.<br>cmd + shift + Enter | Insert line before<br>cmd + Enter | insert line after<br>cmd + option + T | Special characters<br>ctrl + D | delete word after</p><h4 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h4><p>cmd + D | Expand selection to words.<br>ctrl + cmd + G | Expand all selection to words<br>cmd + L | expand selection to line<br>Esc | Single selection , cancle multiple selection.<br>ctrl + shift + up | add previous line<br>ctrl + shift + down | add next line.<br>cmd + shift + L | 将选中的区域分割成多行选中状态(多光标操作状态)|Split into lines<br>option + mouse | 多重光标选中<br>cmd + shift + J | 已缩进层级为依据，一层层向外选中|Expand selection to indentation.<br>ctrl + shift + M 将匹配括号中的内容选中|。</p><h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><p>cmd + F | find<br>cmd + G | find next<br>cmd + shift + F | find in files<br>cmd + shift + E | 缓存用于替换的内容，方便之后的替换<br>cmd + E | 缓存用于查找的内容，方便之后的查找。<br>cmd + option + E | replace Next</p><h4 id="Go-To"><a href="#Go-To" class="headerlink" title="Go To"></a>Go To</h4><p>cmd + P | go to Anything<br>cmd + R | go to Symbol<br>cmd + G | Go to line.<br>ctrl + M | jump to matching bracket()<br>cmd + F2 | Toggle bookmark<br>F2. | Jump to Next bookmark.<br>cmd + shift + F2 | clear all bookmarks.<br>cmd + option + right | Next File</p>]]></content>
      
      
      <categories>
          
          <category> 生产力 </category>
          
          <category> sublime快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产力 </tag>
            
            <tag> sublime </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-交集、并集、差集</title>
      <link href="/2019/05/29/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/"/>
      <url>/2019/05/29/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Linux 命令</p><p>两个文件比对，求交集，并集，差集。</p><h6 id="a-txt"><a href="#a-txt" class="headerlink" title="a.txt"></a>a.txt</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">bbbbb</span><br><span class="line">ccccc</span><br><span class="line">ddddd</span><br><span class="line">eeeee</span><br><span class="line">fffff</span><br><span class="line">ggggg</span><br></pre></td></tr></table></figure><h6 id="b-txt"><a href="#b-txt" class="headerlink" title="b.txt"></a>b.txt</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">ccccc</span><br><span class="line">eeeee</span><br><span class="line">ggggg</span><br><span class="line">iiiii</span><br><span class="line">jjjjj</span><br><span class="line">kkkkk</span><br><span class="line">lllll</span><br></pre></td></tr></table></figure><h2 id="方法1-sort"><a href="#方法1-sort" class="headerlink" title="方法1: sort"></a>方法1: sort</h2><h3 id="交集："><a href="#交集：" class="headerlink" title="交集："></a>交集：</h3><blockquote><p>$sort a.txt b.txt | uniq -d</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">ccccc</span><br><span class="line">eeeee</span><br><span class="line">ggggg</span><br></pre></td></tr></table></figure><h3 id="并集："><a href="#并集：" class="headerlink" title="并集："></a>并集：</h3><blockquote><p>sort a.txt b.txt | uniq</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">bbbbb</span><br><span class="line">ccccc</span><br><span class="line">ddddd</span><br><span class="line">eeeee</span><br><span class="line">fffff</span><br><span class="line">ggggg</span><br><span class="line">iiiii</span><br><span class="line">jjjjj</span><br><span class="line">kkkkk</span><br><span class="line">lllll</span><br></pre></td></tr></table></figure><h3 id="差集："><a href="#差集：" class="headerlink" title="差集："></a>差集：</h3><blockquote><p>sort a.txt b.txt b.txt | uniq -u</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bbbbb</span><br><span class="line">ddddd</span><br><span class="line">fffff</span><br></pre></td></tr></table></figure><p>说明： sort 先给文件排序。<br>-d 显示次数大于一次的行<br>-u 显示次数仅为一次的行</p><h2 id="方法2-comm"><a href="#方法2-comm" class="headerlink" title="方法2: comm"></a>方法2: comm</h2><blockquote><p>comm a.txt b.txt</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        aaaaa</span><br><span class="line">bbbbb</span><br><span class="line">        ccccc</span><br><span class="line">ddddd</span><br><span class="line">        eeeee</span><br><span class="line">fffff</span><br><span class="line">        ggggg</span><br><span class="line">    iiiii</span><br><span class="line">    jjjjj</span><br><span class="line">    kkkkk</span><br><span class="line">    lllll</span><br></pre></td></tr></table></figure><p>显示三列：<br>第一列：a中有，b没有。a差b comm -2 -3 a.txt b.txt<br>第二列：a没有，b有。 b差a comm -1 -3 a.txt b.txt<br>第三列：ab都有 a交b comm -1 -2 a.txt b.txt</p><h3 id="大小写互转"><a href="#大小写互转" class="headerlink" title="大小写互转"></a>大小写互转</h3><p>注意： 以下命令Mac OS无效</p><p>sed ‘s/[a-z]/\u&amp;/g’<br>sed ‘s/[A-Z]/\l&amp;/g’</p><h3 id="拆解每一行中固定关键字的列"><a href="#拆解每一行中固定关键字的列" class="headerlink" title="拆解每一行中固定关键字的列"></a>拆解每一行中固定关键字的列</h3><p>sed ‘s/.(action=[a-zA-Z]{1,}).(cmd=[_a-zA-Z-]{1,})./\1 \2/‘<br>注意：在次数匹配时：<br>1）圆括号必须转义<br>2）花括号必须转义</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令 - 交集、并集、差集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> comm </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM命令整理</title>
      <link href="/2019/05/29/VIM%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2019/05/29/VIM%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="Alive"><a href="#Alive" class="headerlink" title="Alive"></a>Alive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I: Insert Mode</span><br><span class="line">Esc: Nomal Mode</span><br><span class="line">Q : Quite With Out Save.</span><br><span class="line">WQ : Write And Quite</span><br><span class="line">HJKL: Left Down Up Right.</span><br><span class="line">X: Cut Character</span><br><span class="line">DD: Delete Line</span><br><span class="line">P: Pesta Character</span><br></pre></td></tr></table></figure><h4 id="Felling-Better"><a href="#Felling-Better" class="headerlink" title="Felling Better"></a>Felling Better</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a: 在光标后插入</span><br><span class="line">o: 在当前行后插入一个新行</span><br><span class="line">O: 在当前行前插入一个新行</span><br><span class="line">cw: 删除从光标所在位置后到一个单词结尾的字符 c2w, c3w.</span><br><span class="line">Moving</span><br><span class="line">0 &#x2F; ^ 光标移动到行首（不是blank的位置）</span><br><span class="line">$ &#x2F; g_ 光标移动到行尾（不是blank的位置）</span><br><span class="line">&#x2F;pattern 定位到pattern的区域</span><br><span class="line">Pesta</span><br><span class="line">p: pesta</span><br><span class="line">u : undo</span><br><span class="line">ctrl+r : redo</span><br></pre></td></tr></table></figure><h4 id="Better-Faster-Stronger"><a href="#Better-Faster-Stronger" class="headerlink" title="Better,Faster,Stronger"></a>Better,Faster,Stronger</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2d : delete two lines.</span><br><span class="line">100idesu[Esc]: insert 100 times desu.</span><br><span class="line">4p : pesta 4 times.</span><br><span class="line">% : swap &#123;&#125;</span><br><span class="line">#&#x2F;* : 向上／下搜索当前光标所在的单词</span><br><span class="line"></span><br><span class="line">0y$ ：移动到行首，开始copy，一直到本行最后一个字符。</span><br><span class="line">d: delete and copy</span><br><span class="line">v: select and copy</span><br><span class="line">gU: 变大写 and copy</span><br><span class="line">gu: 变小写 And copy</span><br></pre></td></tr></table></figure><h4 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^ -&gt; 到开头</span><br><span class="line">Ctrl-v -&gt; 开始块操作</span><br><span class="line">Ctrl-d -&gt; 向下移动</span><br><span class="line">I– [Esc]-&gt; 插入–</span><br></pre></td></tr></table></figure><h4 id="vim超能力"><a href="#vim超能力" class="headerlink" title="vim超能力"></a>vim超能力</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在当前行移动光标：</span><br><span class="line">0: 到行首</span><br><span class="line">^: 到本行的第一个非blank字符</span><br><span class="line">$: 到行尾</span><br><span class="line">g_：到本行最后一个非blank字符</span><br><span class="line">fa：到下一个为a的字符处， fs到下一个为s的字符处</span><br><span class="line">t，；到逗号前的第一个字符，ta到a前的第一个字符</span><br><span class="line">3fa：当前行查找第三个出现的a</span><br><span class="line">dt，：删除多有的内容，一直到逗号出现。</span><br></pre></td></tr></table></figure><h4 id="区域选择"><a href="#区域选择" class="headerlink" title="区域选择"></a>区域选择</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a 和 i</span><br><span class="line">action 可以是任何命令，d：delete， y：copy， v：view mode</span><br><span class="line">object 可以是：w：word， s：statement， p：paragraph，也可以是特殊的字符。</span><br><span class="line">例如字符串：(map (+) (&quot;foo&quot;)),光标在o上。</span><br><span class="line">vi” : foo</span><br><span class="line">va” : “foo”</span><br><span class="line">vi) : “foo”</span><br><span class="line">va) : (“foo”)</span><br><span class="line">v2i): map (+) (“foo”)</span><br><span class="line">v2a): (map (+) (“foo”))</span><br></pre></td></tr></table></figure><h4 id="可视化选择"><a href="#可视化选择" class="headerlink" title="可视化选择"></a>可视化选择</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">######缩进######</span><br><span class="line">使用v／V进入可视化模式</span><br><span class="line">J ： 把所有的行链接起来变成一行</span><br><span class="line">&lt;&#x2F;&gt;：左右缩进</span><br><span class="line">&#x3D; ：自动缩进</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">######行后追加######</span><br><span class="line">ctrl+v ： 进入可视化编辑模式</span><br><span class="line">选中相应的行（j或者ctrl+d 或者／pattern 或者%）</span><br><span class="line">$到行最后</span><br><span class="line">A(append,在行尾追加)， 输入字符串， 按ESC</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> VIM </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
