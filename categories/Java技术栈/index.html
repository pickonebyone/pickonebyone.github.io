<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#®️Jun'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>分类：Java技术栈 - 碎碎念</title>
  
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
	  setTimeout(function() { 
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0b970030787ceb090a4dc46259415a4c";
		hm.defer=true;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
	  }, 5000);
    })();
    </script>
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            JUNE <b><sup style='color:#3AA757'>®️Jun</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>主页
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/books/
                  
                  
                  
                    id="books"
                  >
                  <i class='fas fa-book fa-fw'></i>书单
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/aim/
                  
                  
                  
                    id="aim"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>小目标
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>主页
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/books/
                  
                  
                  
                    id="books"
                  >
                  <i class='fas fa-book fa-fw'></i>书单
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/aim/
                  
                  
                  
                    id="aim"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>小目标
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/">
      Mysql事务
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月10日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存，要么所有修改都不保存。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>InnoDB存储引擎中的事务完全符合ACID的特性（A：Atomic，C：Consistency，I：Isolation，D：Durability）。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL执行失败，已经执行成功的SQL也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务将数据库从一种状态变更为另一种一致的状态。在事务开始前和事务结束后，数据库的完整性约束没有被破坏。事务是一致性的单位，如果事务中某个动作失败了，系统可以自动撤销事务，返回初始化的状态。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>每个读写事务的对象对其他事务的操作对象能相互分离，该事务提交前对其他事务都不可见，通常使用锁来实现。</p>
<p>数据库系统中都提供了一种粒度锁的策略，允许事务仅锁住一个实体对象的子集，来提高事务之间的并发性。</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>事务一旦提交，其结果就是永久性的。即使当数据库崩溃需要恢复时，也能保证恢复后提交的数据都不会丢失</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h4><p>事务类型中最简单，生产环境中使用最为频繁的一种事务类型。<br>在扁平事务中，所有操作都处于同一层次，其由Begin Work开始，有Commit Work或者Rollback work结束，其间操作是原子的，要么都执行，要么都回滚。<br>扁平事务是应用程序成为原子操作的基本组成模块。</p>
<p><img src="/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/bpsw.jpg" alt="扁平事务的三种情况"></p>
<p>缺点：<br>不能提交或者回滚事务的某一部分，或者分几个步骤提交。</p>
<h4 id="带有保存点的扁平事务"><a href="#带有保存点的扁平事务" class="headerlink" title="带有保存点的扁平事务"></a>带有保存点的扁平事务</h4><p>除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。</p>
<p>这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合要求，开销也太大。保存点用来通知系统应该记住事务的当前状态，以便当之后发生错误时，事务能回到保存点当时的状态。</p>
<p>缺点：<br>当系统发生崩溃时，所有的保存点都将消失。因为其保存点事易失的，而非持久的。<br>这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。</p>
<h4 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h4><p>保存点模式的一个变种。在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。其中，提交事务操作和开始下一个事务操作将合并为一个原子操作。下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。</p>
<p>链式事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点。<br>链式事务中的回滚仅限于当前事务，即智能恢复到最近一个的保存点。<br>对于锁的处理，两者也不相同。<br>链式事务在执行commit后就释放了当前事务所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。</p>
<p><img src="/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/qtsw.jpg" alt="链事务"></p>
<h4 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h4><p>一个层次结构框架，由一个顶层事务控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换。</p>
<p><img src="/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/qtsw_2.jpg" alt="嵌套事务"></p>
<p>1）嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务<br>2）处在叶子结点的事务是扁平事务。但是每个子事务从根到叶子结点的距离是可以不同的。<br>3）位于根结点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为父事务，事务的下一层称为子事务。<br>4）子事务既可以提交也可以回滚，但是提交操作并不马上生效，除非其父事务应提交。任何子事务都在顶层事务提交后才真正的提交。<br>5) 树中任意一个事务的回滚回引起它所有子事务一同回滚，子事务仅保留ACI的特性，不具有D的特性。</p>
<p>在Moss理论中，所有的工作都是由叶子结点来完成的，只有叶子结点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责逻辑控制，解决何时调用相关的子事务。</p>
<p>即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务。</p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同结点。</p>
<p>InnoDB存储引擎支持扁平事务、带有保存结点的扁平事务、链事务、分布式事务。并不原生支持嵌套事务。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>事务的隔离性由锁来实现。<br>原子性、一致性、持久性通过数据库的redo log和undo log来完成。<br>redolog 用来保证事务的原子性和持久性。<br>undolog 用来保证事务的一致性。</p>
<h3 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h3><p>Redo 用来实现事务的持久性，是InnoDB存储引擎用来记录对于每个页的修改，它在事务的进行中不断的被写入。<br>由于是物理操作日志，每个事务对应多个日志条目。并且事务的重做日志是并发写入的，因此在文件中记录的顺序并不是事务的顺序。</p>
<p>其由两部分组成：<br>1）易失的内存中的重做日志缓冲 redo log buffer<br>2）持久的重做日志文件 redo log file</p>
<p>InnoDB存储引擎通过Force Log At Commit机制实现事务的持久性，事务提交时必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才完成。<br>redo log都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。</p>
<p>为了确保每次日志都写入redo log file，在每次重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作，由于重做日志文件打开并没有使用O_DIRECT选项，因此重做日志缓冲先写入文件系统缓存。为了确保重做日志写入磁盘，必须进行一次fsync操作。由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交（数据库）的性能。</p>
<p>InnoDB存储引擎允许用户手工设置非持久的情况发生来提高数据库的性能。当事务提交时，日志不写入重做文件，等待一个时间周期后再执行fsync操作。但是当数据库发生宕机时，由于部分日志未刷新到磁盘，因此回丢失最后一段时间的事务。</p>
<p>innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。<br>默认值为1，表示事务提交时必须调用一次fsync操作。<br>值为0:表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，master thread每秒都会进行一次重做日志文件的fsync操作。<br>值为2:表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。<br>当Mysql宕机时并不会发生丢失，但是操作系统宕机时，重起数据库后回丢失未从文件系统缓存刷新到重做日志文件的那部分事务。</p>
<h4 id="日志块"><a href="#日志块" class="headerlink" title="日志块"></a>日志块</h4><p>在InnoDB存储引擎中，重做日志缓存、重做日志文件都是按照512字节大小的块来进行保存的。<br>如果一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储。<br>此外由于重做日志块的大小和磁盘扇区大小一样都是512个字节，因此重做日志的写入可以保证原子性，不需要doublewrite技术。</p>
<h4 id="重做日志块结构"><a href="#重做日志块结构" class="headerlink" title="重做日志块结构"></a>重做日志块结构</h4><h5 id="日志块头"><a href="#日志块头" class="headerlink" title="日志块头"></a>日志块头</h5><p>共占用12个字节，</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用字节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_BLOCK_HDR_NO</td>
<td>4</td>
<td>log buffer 由log block组成，在内部log buffer就像一个数组，log_block_hdr_no来标记这个数据中的位置，它是递增并且循环使用的，占用四个字节。第一位用来判断是否是flush bit，最大的值为2G。</td>
</tr>
<tr>
<td>LOG_BLOCK_HDR_DATA_LEN</td>
<td>2</td>
<td>表示log block锁占用的大小。当log block被写满时，该值为0x200，表示使用全部log block空间，也就是占用512字节。</td>
</tr>
<tr>
<td>LOG_BLOCK_FIRST_REC_GROUP</td>
<td>2</td>
<td>占用两个字节，表示logblock中第一个日志所在的偏移量，如果该值的大小和log_block_hdr_len相同，表示当前logblock 不包含新的日志。</td>
</tr>
<tr>
<td>LOG_BLOCK_CHECKPOINT_NO</td>
<td>4</td>
<td>表示logblock 最后被写入时的检查点的值。</td>
</tr>
</tbody></table>
<h5 id="日志内容"><a href="#日志内容" class="headerlink" title="日志内容"></a>日志内容</h5><p>日志块内容可以占用512 - 12 - 8 = 492个字节。</p>
<h5 id="日志块尾"><a href="#日志块尾" class="headerlink" title="日志块尾"></a>日志块尾</h5><p>共占用8个字节，共有一部分组成，他的值和log_block_hdr_no相同，并在log_block_init中被初始化。</p>
<h4 id="重做日志组"><a href="#重做日志组" class="headerlink" title="重做日志组"></a>重做日志组</h4><p>重做日志组中有多个重做日志文件。InnoDB存储引擎只有一个log group。它是一个逻辑上的概念，并没有实际存储的物理文件来表示log group信息。log group是由多个重做日志文件组成的，每个log group中的日志文件大小是相同的。</p>
<p>重做日志文件中存储的是log buffer中保存的log block，因此它也是根据快的方式进行物理存储的管理，每个块的大小与log block一样都是512个字节。在InnoDB存储引擎中，log buffer根据一定的规则将内存中的 log block刷新到磁盘。</p>
<ul>
<li>事务提交时</li>
<li>log buffer中有一般的内存空间已经被使用时</li>
<li>log checkpoint时</li>
</ul>
<p>对于log block的写入追加在redo log file 的最后部分，当一个redo log file 被写满时，回接着写入下一个redo log file， 其使用方式是round-robin.</p>
<p>对于log group中的第一个redo log file, 其前2KB的部分保存4个512字节大小的块，存放的内容是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>log file header</td>
<td>512</td>
</tr>
<tr>
<td>checkpoint1</td>
<td>512</td>
</tr>
<tr>
<td>空</td>
<td>512</td>
</tr>
<tr>
<td>checkpoint2</td>
<td>512</td>
</tr>
</tbody></table>
<p>对于log group的其他 redo log file ,仅保留这些空间，但不保存这些信息。</p>
<p>redo log file的写入并不是完全顺序的，因为除了log block的写入操作，还需要更新前2KB部分的信息，这些信息对于InnoDB存储引擎的恢复非常重要。</p>
<p><img src="/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/log_group_redo_log_file.jpg" alt="log group &amp; redo log file"></p>
<p>在log file header 后面的部分为InnoDB存储引擎保存的check point值，其设计是交替写入，这样的设计避免了因介质失败而导致无法找到可用的checkpoint情况。</p>
<h4 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h4><p>不同的数据库操作会有丢赢的重做日志格式，由于InnoDB存储引擎的存储管理是基于页的，因此重做日志格式也是基于页的。 </p>
<h5 id="通用的头部格式"><a href="#通用的头部格式" class="headerlink" title="通用的头部格式"></a>通用的头部格式</h5><table>
<thead>
<tr>
<th>redo_log_type</th>
<th>space</th>
<th>page_no</th>
<th>redo log body</th>
</tr>
</thead>
<tbody><tr>
<td>重做日志类型</td>
<td>表空间ID</td>
<td>页偏移量</td>
<td>日志不同，存储内容不同</td>
</tr>
</tbody></table>
<h5 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h5><p>Log Sequence Number代表日志序列号，在INnoDB存储引擎中，LSN占用8个字节，并且单调递增。它的含义是：</p>
<ul>
<li>重做日志写入总量，表示事务写入重做日志的总量，单位是字节。</li>
<li>checkpoint 的位置</li>
<li>页的版本，在每个页头部的fil_page_lsn记录了该页的LSN值，表示LSN最后刷新时的大小。用来判断该页是否需要进行恢复操作。如，页P1的LSN为10000， 而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已经提交，那么数据库需要进行恢复操作，将重做日志应用到P1中。对于重做日志中LSN小于P1页的LSN，不需要进行重做，表示已经被刷新到该位置。</li>
</ul>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>InnoDB存储引擎在启动时不管上次数据哭运行时是否正常关闭，都会尝试进行恢复操作，因为重做日志记录的是物理日志，因此恢复的速度比逻辑日志要快很多。同时InnoDB存储引擎自身对恢复做了优化，如顺序读取和并行应用重做日志，这样可以进一步提高数据库恢复的速度。</p>
<p>由于checkpoint表示应刷新到磁盘页上的LSN，因此恢复过程中仅需要恢复检查点开始的日志部分即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table t(a int, b int, primary key(a), key(b));</span><br><span class="line">insert into t select 1,2;</span><br></pre></td></tr></table></figure>
<p>对于INSERT操作，其记录的是每个页上的变化。由于需要对聚集索引页和辅助索引页进行操作，其记录的重做日志大致为：<br>Page(2,3), offset 32, value 1,2#聚集索引<br>Page(2,4), offset 64, value 2 #辅助索引</p>
<p>如果插入操作涉及到B+树的分裂，则更多的页需要记录日志。此外，重做日志是物理日志，因此其是幂等的。</p>
<h3 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h3><h3 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h3><h3 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h3><h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><h3 id="隐式提交的SQL语句"><a href="#隐式提交的SQL语句" class="headerlink" title="隐式提交的SQL语句"></a>隐式提交的SQL语句</h3><h3 id="对于事务操作的统计"><a href="#对于事务操作的统计" class="headerlink" title="对于事务操作的统计"></a>对于事务操作的统计</h3><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>##分布式事务</p>
<h3 id="Muysql数据库的分布式事务"><a href="#Muysql数据库的分布式事务" class="headerlink" title="Muysql数据库的分布式事务"></a>Muysql数据库的分布式事务</h3><h3 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h3><h2 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h2><h2 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h2>
      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/09/Mysql%E9%94%81/">
      Mysql锁
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月9日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>InnoDB存储引擎锁的实现提供了一致性的非锁定读、行级锁支持。行级锁没有相关的额外开销，并可以同时得到并发性和一致性。</p>
<h2 id="LOCK与LATCH"><a href="#LOCK与LATCH" class="headerlink" title="LOCK与LATCH"></a>LOCK与LATCH</h2><h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><p>轻量级的锁，因为其要求锁定的时间必须非常短，如果持续的时间长，则应用的性能会非常差。InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁），目的就是用来保证并发线程操作临界资源的正确性，通常没有死锁检测机制。</p>
<h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><p>Lock对象是事务，用来锁定数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放（不同的隔离级别释放时间不同）。lock有死锁机制。</p>
<p><img src="/2020/11/09/Mysql%E9%94%81/lock_latch.jpg" alt="lock &amp; latch"></p>
<h3 id="Latch-信息查看"><a href="#Latch-信息查看" class="headerlink" title="Latch 信息查看"></a>Latch 信息查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb mutex;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>mutext被请求的次数</td>
</tr>
<tr>
<td>spin_waits</td>
<td>spin lock 的次数，InnoDB存储引擎latch在不能获得锁时首先进行自旋，若自旋后还不能获得，则进入等待</td>
</tr>
<tr>
<td>spin_rounds</td>
<td>自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin_rounds/spin_waits 表示平均每次自旋所需要的内部循环次数</td>
</tr>
<tr>
<td>os_waits</td>
<td>操作系统等待的次数，当spinlock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒</td>
</tr>
<tr>
<td>os_yields</td>
<td>进行os_thread_yield唤醒操作的次数</td>
</tr>
<tr>
<td>os_wait_times</td>
<td>操作系统等待的时间，单位ms</td>
</tr>
</tbody></table>
<h3 id="Lock信息查看"><a href="#Lock信息查看" class="headerlink" title="Lock信息查看"></a>Lock信息查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line">information_schema 下 innodb_trx、innodb_locks、innodb_lock_waits</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul>
<li>共享锁 S Lock, 允许事务读一行数据</li>
<li>排他锁 X Lock, 允许事务删除或者更新一行数据。</li>
</ul>
<p>InnoDB存储引擎支持多力度锁定，允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，Mysql支持意向锁。</p>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读是InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。<br>如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会u因此去等待行上锁的释放，InnoDB存储引擎会读取行的一个快照数据。快照数据是改行之前的版本数据，通过undo段来完成，undo用来在事务中回滚数据，一次快照数据本身没有额外开销。读取快照数据本身没有额外开销，也不需要上锁。</p>
<p>一个行记录可能有多个快照数据，由此来来的并发控制称为多版本并发控制。<br>在事务隔离级别为READCOMMITED和REPEATABLEREAD下， InnoDB存储引擎使用非锁定一致性读。但是对于快照的定义不同。</p>
<p>在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。<br>在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>
<h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ... for update</span><br><span class="line">select ... lock in share mode</span><br></pre></td></tr></table></figure>

<h3 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h3><p>InnoDB自增长ID的锁机制称为Auto-Inc Locking, 为了提高插入的性能，在完成对自增长值插入的SQL语句后立即释放，而不需要等到事务提交。必须等待前一个插入完成，并且对Inser。。Select的大户巨量的插入会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>轻量级互斥量的自增长实现机制，大大提高了自增长值插入的性能。通过innodb_autoinc_lock_mode来控制自增长的模式。默认值为1.</p>
<ul>
<li>insert-like : 所有的插入语句，insert/replace/insert-select, replace-select, load data.</li>
<li>simple-inserts: 插入之前就确定插入行数的语句，如insert/replace。</li>
<li>bulk inserts: 插入前不能确定得到插入行数的语句。</li>
<li>mixed-mode inserts: 插入中有一部分的数据是自增长的， 一部分是确定的。</li>
</ul>
<p>innodb_autoinc_lock_mode: 0, auto-inc locking 的方式，<br>innodb_autoinc_lock_mode: 1, 默认值，<br>                  对于imple inserts, 该值会用互斥量去对内存中的计数器进行累加操作，<br>                  对于bulk inserts,使用auto-inc locking 方式，不考虑回滚操作时，对于自增值列的增长是连续的，statement-based方式的replication可以很好的工作。<br>innodb_autoinc_lock_mode: 2, 所有的insert-like自增长的值产生的都是通过互斥量。性能最高。出现的问题是增长的值不连续， 基于statement-based replication 会出现问题。所以在使用当前模式时，任何时候都应该使用 row-based replalication, 这样才能保证最大的并发性能以及replication主从数据的一致。</p>
<p>MyISAM自增主键是表锁设计，自增长不用考虑并发插入的问题， 因此在Master傻姑娘使用InnoDB存储引擎，slave上使用MyISAM存储引擎的replication架构下用户必须考虑这种问题。？？？</p>
<h3 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h3><p>InnoDB引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其家一个索引，这样就可以避免表锁。</p>
<p>对于外键值的插入或者更新，首先要查询父表中的记录，如果以一致性非锁定读的方式读取，会发生数据不一致的问题，此时需要对父表加一个S锁。如果这时父表已经有一个X锁，则子表的操作会被阻塞。</p>
<h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><h3 id="行锁的三种算法"><a href="#行锁的三种算法" class="headerlink" title="行锁的三种算法"></a>行锁的三种算法</h3><ul>
<li>Record Lock: 单行记录上锁，总是会去锁定索引记录，如果InnoDB存储引擎在建立的时候没有设置任何一个索引，那么InnoDB存储引擎会使用隐式的主键来进行锁定。</li>
<li>Gap Lock: 锁定一个范围，不包含记录本身,为了阻止多个事务将记录插入到同一个范围内。但是又导致Phantom Problem（幻读）问题的产生。</li>
<li>Next-Key Lock: Gap Lock + Record Lock, 锁定一个范围，并锁定记录本身， 解决了Phantom Problem。</li>
</ul>
<p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock锁住索引本身而不是范围。</p>
<p>对于辅助所用，加上的是Next-keyLock， 锁定的是范围，并且还会对下一个键值加上Gap Lock.</p>
<p>显示关闭gap_lock后，除了外键约束和唯一性检查依然需要GapLock，其余情况仅需要使用RecordLock进行锁定。</p>
<ul>
<li>将事务的隔离级别设置为READ COMMITTED</li>
<li>设置innodb_locks_unsafe_for_binlog=1</li>
</ul>
<h3 id="解决Phantom-Problem"><a href="#解决Phantom-Problem" class="headerlink" title="解决Phantom Problem"></a>解决Phantom Problem</h3><p>默认的可重复读的事务隔离级别下，InnoDB存储引擎采用Next-Key Locking机制来避免幻读。<br>在ReadCommited模式下，仅采用RecordLock来加锁。</p>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过所及之可以实现事务的隔离性要求，使得事务可以并发地工作。<br>脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交的数据。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>在不同的事务下，当前事务可以读到另外事务未提交的数据（脏数据）。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务内，多次读取同一数据集合，由于当前事务看到了另外的事务提交的数据，两次返回的数据是不一样的。<br>InnoDB存储引擎中，使用Next-Key Lock算法来避免不可重复读的问题（不可重复读也叫幻读）。</p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>一个事务的更新操作会被另一个事务的更新成操作覆盖。 </p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>因为不同锁止键的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁匙放它所占用的资源，就是阻塞，阻塞时为了确保事务可以并发且正常地运行。</p>
<p>innodb_lock_wait_timeout: 等待超时时间<br>innodb_rollback_on_timeout: 等待超时时是否对进行中的事务进行回滚。默认为OFF，默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET @@innodb_lock_wait_timeout&#x3D;60;</span><br></pre></td></tr></table></figure>


<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>两个或者两情歌以上的事务在执行过程中，因为争夺锁资源而造成相互等待的现象。</p>
<h4 id="超时解决"><a href="#超时解决" class="headerlink" title="超时解决"></a>超时解决</h4><p>解决思索最简单的方式是不要有等待，将任何的等待都化为回滚，并且事务重新开始。<br>如果超时的事务更新了很多行，占用了较多的undo log会导致回滚性能差。</p>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>采用 wait-for graph（等待图）的方式进行死锁检测。要求数据库保存两种信息，通过这两种信息构造一张图，如果图中有回路，就代表存在死锁，从而选择回滚undo量最小的事务。</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁升级是指将所得粒度降低。InnoDB存储引擎不存在锁升级的问题。因为不是根据每个记录来产生行锁，而是根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。因此不管是一个事务锁住页中一个记录还是多个记录，开销通常是一样。</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/06/ThreadLocal/">
      ThreadLocal
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Java</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月6日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> ThreadLocal 是JDK包提供的，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的副本，在实际多线程操作的时候，操作的都是自己本地内存中的变量，从而规避了线程安全问题。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadLocal tl = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">tl.set(k);</span><br><span class="line">tl.get();</span><br><span class="line">tl.remove();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment"> * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>


<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Thread 类中有两个变量，一个threadLocals， 一个inheritableThreadLocals。</p>
<h2 id="不支持继承性"><a href="#不支持继承性" class="headerlink" title="不支持继承性"></a>不支持继承性</h2><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2>
      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/06/Mysql%E7%B4%A2%E5%BC%95/">
      Mysql索引
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月6日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="InnoDB存储引擎索引"><a href="#InnoDB存储引擎索引" class="headerlink" title="InnoDB存储引擎索引"></a>InnoDB存储引擎索引</h2><p>InnoDB支持B+树索引、全文索引和哈希索引。</p>
<p>B+树索引就是传统意义上的索引，是目前关系型数据库中查找最为常用和最为有效的索引。<br>InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为敢于是否在一张表中生成哈希索引。</p>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>也叫折半查找，必须是一组有序的记录数组。具体详见《二分查找法》。</p>
<h3 id="二叉查找树与平衡二叉树"><a href="#二叉查找树与平衡二叉树" class="headerlink" title="二叉查找树与平衡二叉树"></a>二叉查找树与平衡二叉树</h3><p>二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。</p>
<p>前序遍历：根 -&gt; 左 -&gt; 右<br>中序遍历: 左 -&gt; 根 -&gt; 右<br>后序遍历: 左 -&gt; 右 -&gt; 根</p>
<p>当一个二叉查找树的每个结点只有左子树或者只有右子树时，该数据结构退化成了链表，查找性能会变低，时间复杂度变成O(n).</p>
<p>平衡二叉树：在二叉树的基础上，必须满足任何结点的两个子树高度最大差1. 平衡二叉树的查询速度极快，但是维护一颗平衡二叉树的代价非常大。 需要经过1次或者多次左旋和右旋来得到插入或者更新后的平衡树。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树由B树和索引顺序访问方法演化而来，为磁盘或者其他直接存取辅助设备设计的一种平衡查找树。<br>在B+树中，所有记录结点都是按照键值的大小顺序存放在同一层的叶子结点上，由各个叶子结点指针进行连接。</p>
<h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>B+树的插入必须保证插入后叶子结点中的记录依然排序，同时要考虑插入到B+树的三种情况，每种情况都可能会导致不同的插入算法。</p>
<p>1）叶子页未满，索引页未满：直接将记录插入到叶子结点。<br>2）叶子页已满，索引页未满：<br>   2.1）拆分LeafPage<br>   2.2) 将中间的结点放入到IndexPage中<br>   2.3）小于中间结点的记录放在左边<br>   2.4) 大于或者等于中间结点的记录放在右边<br>3）叶子页已满，索引页已满：<br>   3.1）拆分LeafPage<br>   3.2) 小于中间结点的记录放左边<br>   3.3) 大于或者等于中间结点的记录放右边<br>   3.4) 拆分索引页IndexPage<br>   4.5) 小于中间结点的记录放左边<br>   4.6) 大于中间结点的记录放右边<br>   4.7) 中间结点放入上一层IndexPage</p>
<p>无论如何变化，B+树总会保持平衡。但是为了保持平衡对于新插入的键值可能需要做大量的拆分页操作。<br>因为B+树结构主要用于磁盘，页的拆分意味着磁盘的额操作，所以在可能的情况下尽量减少页的拆分。<br>B+树提供了类似于平衡二叉树的旋转功能。<br>旋转发生在LeafPage已满，但是其左右兄弟结点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录转移到所在页的兄弟结点上。在通常情况下，左兄弟回被首先检查用来做旋转操作。</p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>B+树删除时根据填充因子的变化来衡量（最小填充因子的值为50%）。<br>删除操作同样必须保证删除后叶子结点中的记录已俨然排序。</p>
<p>叶子结点大于填充因子， 中间结点大于填充因子：直接将记录从叶子结点删除，如果该结点还是IndexPage的结点，用该结点的右结点代替。<br>叶子结点小于填充因子，中间结点大于填充因子：合并叶子结点和它的兄弟结点，同时更新IndexPage<br>叶子结点小于填充因子，中间结点小于填充因子：合并叶子结点和它的兄弟结点，更新IndexPage，合并IndexPage和它的兄弟结点。</p>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>按照每张表的主键构造一颗B+树，同时叶子结点中存放的是张张表的行记录数据，聚集索引的叶子结点称为数据页。<br>由于实际的树叶也只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。大多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子结点上直接找到数据。此外定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围的查询。</p>
<p>数据页存放的是完整的每行的数据，索引页存放的是键值和指向数据页的偏移量Offset。<br>聚集索引是按照主键逻辑顺序在磁盘存储。</p>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>对于辅助索引，叶子结点除了包含键值意外，每个结点中的索引行中包含了聚集索引键。<br>每张表中可以有多个辅助索引，当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历并通过叶子级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p>
<h3 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h3><p>InnoDB存储引擎的PageHeader中包含了Page_Last_Insert、Page_Direction、Page_N_Direction，通过这几个参数来决定向左分裂或者向右分裂。</p>
<p>如果插入是随机的，则取页的中间记录作为分裂点的记录。<br>如果向同一方向进行插入的记录数量是5，并且目前已经定位到的记录之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是待插入的记录。</p>
<h3 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h3><p>只对表中b字段的前100个字符创建索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t  add key idx_b(b(100));</span><br></pre></td></tr></table></figure>

<p>查看t表中的所有索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure>

<p>在非高峰时期执行以下语句，更新索引Cardinality信息，使得优化器和索引可以更好的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure>


<p>生产环境创建索引时遇到的问题：</p>
<h4 id="临时表方式创建索引"><a href="#临时表方式创建索引" class="headerlink" title="临时表方式创建索引"></a>临时表方式创建索引</h4><p>先创建临时表，导入数据，创建索引然后修改临时表名称。</p>
<h4 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h4><p>FIC在辅助索引创建的过程中对表加了S锁，因此在创建的过程中之能对该表进行读操作，如果有大量的食物需要对目标表进行写操作，那么数据库的服务同样不可用。<br>FIC方式只限于辅助索引，对于主键的创建和删除需要重建一张表。</p>
<h4 id="Online-Schema-Change"><a href="#Online-Schema-Change" class="headerlink" title="Online Schema Change"></a>Online Schema Change</h4><p>PHP脚本维护，且在进行OSC过程中，允许SET sql_bin_log=0， 因此所做的操作不会同步到slave服务器，可能导致主从不一致的情况。</p>
<h4 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h4><p>允许辅助索引创建的同时，还允许Insert、UPdate、Delete等DML操作，极大地提高了Mysql数据库在生产环境的可用性。<br>还可以在线的操作以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">辅助索引的创建与删除</span><br><span class="line">改变自增长值</span><br><span class="line">添加或者删除外键约束</span><br><span class="line">列的重命名</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name algorithm=&#123;<span class="keyword">default</span>|INPLACE|COPY&#125;</span><br><span class="line"><span class="keyword">lock</span>=&#123;<span class="keyword">default</span>|<span class="keyword">none</span>|<span class="keyword">shared</span>|exclusive&#125;</span><br></pre></td></tr></table></figure>

<p>algorithm:<br>  copy: 临时表方式创建索引<br>  inplace:不需要创建临时表（默认）<br>  default:根据参数old_alter_table判断通过copy或者inplace算法。<br>lock: 创建索引或者删除索引时对表解锁的情况。<br>   none: 不加锁，任意读写操作都不会收到阻塞。<br>   share: 与FIC类似，执行索引创建或者删除操作时，对目标加S锁。可以并发读，阻塞写事务。<br>   exclusive：执行索引创建或者删除时，对表增加一个X锁，阻塞所有的读写事务。<br>   default：通过判断事物的最大并发性来判断执行DDL模式。none -&gt; share-&gt; exclusive.</p>
<p>远离：在执行创建或者删除操作时，将INsert、UPDATE、DELETE等DML操作日志写入缓冲中，等待索引创建完成后，再将重做应用到表上，达到数据一致性。因此索引在创建过程中SQL优化器不会选择正在创建中的索引。<br>缓存大小由innodb_online_alter_log_max_size=128MB控制。</p>
<h2 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h2><p>表示索引中不重复记录数量的预估值。InnoDB根据Cardinality来决定是否使用该索引。<br>Cardinality的值是通过采样的方法来完成的。</p>
<p>当insert、update的数据占有表中数据的1/16时。<br>每一行的更新次数：stat_modified_counter &gt; 2 000 000 000时<br>就会更新Cardinality值。</p>
<p>当执行以下命令时会导致InnoDB存储引擎重新计算Cardinality值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">analyze table</span><br><span class="line">show table status</span><br><span class="line">show index</span><br><span class="line">访问information_schema 下的表tables和表statistics</span><br></pre></td></tr></table></figure>


<h2 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h2><h3 id="不同应用中B-树索引的使用"><a href="#不同应用中B-树索引的使用" class="headerlink" title="不同应用中B+树索引的使用"></a>不同应用中B+树索引的使用</h3><p>OLTP应用和OLAP应用中索引的使用。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>从辅助索引就可以查询到想要的数据，而不需要再查一次聚集索引中的记录。</p>
<h3 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h3><p>当优化器发现辅助索引不能进行索引覆盖时，并且查找的数据量比较大时会放弃辅助索引，转向全表扫描。</p>
<p>使用force index();</p>
<h3 id="Multi-range-Read优化"><a href="#Multi-range-Read优化" class="headerlink" title="Multi-range Read优化"></a>Multi-range Read优化</h3><p>为了减少磁盘的随机访问，并且将随机访问转化为较顺序的数据访问。</p>
<p>MRR的好处：</p>
<ul>
<li>MRR 使得数据访问变得较为顺序，在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。</li>
<li>减少缓冲池中页被替换的次数</li>
<li>批量处理对键值的查询操作</li>
</ul>
<p>对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR的工作方式如下：</p>
<ul>
<li>将查询得到的辅助索引键值存放在一个缓存中，这时缓存中的数据时根据辅助索引键值排序的。</li>
<li>将缓存中的键值根据rowID进行排序</li>
<li>根据rowID的排序顺序来访问实际的数据文件。</li>
</ul>
<p>如果InnoDB或者MyISAM存储引擎的缓冲池不是足够大，不能存放下一张表中的所有数据，此时频繁的离散读操作还是会导致缓存中的页被替换出缓冲池，然后又不断地被读入缓冲池。如果按照住建顺序进行访问，就可以将重复行为降到最低。<br>可以通过optimizer_swith中的flag来控制，当mrr为on时表示启用mrr优化。<br>mrr_cost_based标记表示是否通过cost_based方式选择是否启用mrr。<br>如果mrr = 0n , mrr_cost_based=off ,  表示总启用mrr。</p>
<p>SET @@optimizer_switch=’mrr=on,mrr_cost_based=off’;</p>
<h3 id="IndexConditionPushDown优化"><a href="#IndexConditionPushDown优化" class="headerlink" title="IndexConditionPushDown优化"></a>IndexConditionPushDown优化</h3><p>IndexConditionPushDown 会在读取索引的同时，判断是否可以进行WHERE条件的过滤从而提升性能。</p>
<h2 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><h3 id="InnoDB存储引擎中的哈希算法"><a href="#InnoDB存储引擎中的哈希算法" class="headerlink" title="InnoDB存储引擎中的哈希算法"></a>InnoDB存储引擎中的哈希算法</h3><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><h3 id="InnoDB全文索引"><a href="#InnoDB全文索引" class="headerlink" title="InnoDB全文索引"></a>InnoDB全文索引</h3><h3 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h3>
      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/05/Mysql%E8%A1%A8/">
      Mysql表
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月5日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB存储索引中，表时根据主键顺序组织存放的，这种存储方式的表称为索引组织表。</p>
<p>在InnoDB存储引擎表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则会按照如下方式创建主键：</p>
<ul>
<li>判断表中是否有非空的唯一索引，如果有该列为主键；</li>
<li>表中没有非空的唯一索引，InnoDB引擎自动创建一个6字节大小的指针；<br>当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键（根据定义的索引顺序，而不是建表时列的顺序）。</li>
</ul>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。<br>表空间由段（Segment）、区（extent）、页（Page）组成。<br><img src="/2020/11/05/Mysql%E8%A1%A8/table_space_struct.jpg" alt="表空间结构"></p>
<p>在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1，所有的数据都存放在这个表空间内。<br>如果配置了innodb_file_per_table，则每张表内的数据可以单独存放在一个表空间中。此时每张表的表空间存放的只是数据、索引和插入缓冲的BitMap页，其他类的数据如回滚（undo）、插入缓冲索引页、系统事务信息、二次写缓冲等还是存放在原来的共享表空间。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间是由各个段组成的，包含数据段、索引段、回滚段等。<br>数据段就是B+树的叶子节点，索引段就是B+树的非叶子结点。<br>回滚段？？？<br>在InnoDB存储引擎中，对段的管理都是由引擎自身完成的，DBA不能对其进行控制。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续的页组成的空间，在任何情况下每个区的大小都是1MB。为了保证区中页的连续行，InnoDB引擎每次从磁盘申请4～5个区。默认情况下InnoDB存储引擎页的大小为16K，一个区中存放64个连续的页。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中，默认每个页的大小为16KB。<br>可以通过参数 innodb_page_size 来设置页的大小为4K、8K、16K。<br>如果设置完成，则所有表中的页大小都变成innodb_page_size，不可用对其再次进行修改。除非通过mysqldump导入和导出来生成新的库。</p>
<p>页的类型有：</p>
<ul>
<li>数据页（B-Tree Node）</li>
<li>undo 页（undo log Page）</li>
<li>系统页（System Page）</li>
<li>事务数据页（Transaction System Page）</li>
<li>插入缓冲位图页（Insert Buffer BitMap）</li>
<li>插入缓冲空闲列表页（Insert Buffer Free List）</li>
<li>未压缩的二进制大对象页（Uncompressed BLOB Page）</li>
<li>压缩的二进制大对象页（Compressed BLOB Page）</li>
</ul>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>Innodb存储引擎按行进行存放，每个页存放的行记录有影星的定义，最多允许存放16KB/2 - 200 行的记录。</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><h4 id="Compact-行记录格式"><a href="#Compact-行记录格式" class="headerlink" title="Compact 行记录格式"></a>Compact 行记录格式</h4><p>从Mysql5.0开始，设计目的是高效地存储数据。一个页中存放的行数据越多，其性能就越高。</p>
<p>|—|—|—|—|—|—|—|—|—|<br>| 变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列 2 数据 | …|事务ID列|回滚指针列|__rowid|</p>
<p>变长字段长度列表：按照列的顺序，逆序放置。<br>  如果列的长度小于255个字节，占用1字节；<br>  如果列的长度大于255个字节，占用2字节；<br>  变长字段的长度最大不可以超过2个字节，因为Mysql数据库中VARCHAR类型的最大长度限制为65535.<br>NULL标志位：表示改行数据中是否有NULL值，有用1表示，占用1个字节。<br>记录头信息：固定占用5个字节。<br>最后的部分是实际存储没咧的数据。<br>事务ID列：隐藏列，占用6字节。<br>回滚指针列:隐藏列，占用7字节。<br>__rowid：占用6字节。</p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnoDB存储引擎的数据都是存放在页类型为B-tree Node中，当发生行溢出是，数据存放在页类型为uncompress BLOG页中。</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><h3 id="Named-File-Formats-机制"><a href="#Named-File-Formats-机制" class="headerlink" title="Named File Formats 机制"></a>Named File Formats 机制</h3><p>###约束</p>
<h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>分区功能不是在存储引擎层面完成的。<br>支持分区的存储引擎有：MyISAM、InnoDB、NDB。<br>不支持分区的存储引擎有：CSV、FEDORATED、MERGE。</p>
<p>分区的过程是将一个表或者索引分解为多个更小的、更可管理的部分。<br>从逻辑上讲只有一个表或者一个索引库，但是在物理上这个表或者索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，页可以作为一个更大的对象的一部分进行处理。</p>
<p>Mysql支持水平分区，不支持垂直分区（水平分区，将同一表中的不同行的记录分配到不同的物理文件；垂直分区，将同一表中的不同列分配到不同的物理文件）。<br>Mysql不支持全局分区，只支持局部分区。<br>局部分区：一个分区中既存放了数据由存放了索引。<br>全局分区：数据存放在各个区，所有数据的索引存放在一个对象中。</p>
<p>分区主要用来数据库高可用性的管理，对于某些SQL的性能带来提高。</p>
<h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><ul>
<li>RANGE分区:行数据基于属于一个给定连续区间的列值被放入分区。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t (</span><br><span class="line">  id int</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by range(id)(</span><br><span class="line"> partition p0 values less than (10),</span><br><span class="line"> partition p1 values less than (20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add partition (partition p2 values less than maxvalue);</span><br></pre></td></tr></table></figure>
<p>启用分区后，表是由建立各个分区时的各个分区ibd文件组成。</p>
<ul>
<li>List分区：和RANGE分区类似，只是LIST分区面向的是离散的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">   a INT, </span><br><span class="line">   b INT</span><br><span class="line">) engine &#x3D; INNODB</span><br><span class="line">partition by list(b)(</span><br><span class="line">  partition p0 values in (1,3,5,7,9),</span><br><span class="line">  partition p1 values in (0,2,4,6,8)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<ul>
<li>HASH分区：根据用户自定义的表达式返回值进行分区，返回值不能为负数。<br>Hash分区的目的是将数据均匀地分布到盂县定义的各个区中，保证各分区的数据数量大致都一样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">  a int, </span><br><span class="line">  b datetime</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by hash(year(b))</span><br><span class="line">partitions 4;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">  a int,</span><br><span class="line">  b datetime</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by linear hash(year(b))</span><br><span class="line">prtions 4;</span><br></pre></td></tr></table></figure>

<p>LINEAR HASH分区的优点在于，增加、删除、合并和拆分分区将变得更加快捷，有利于处理含有大量数据的表。<br>缺点在于，与使用HASH分区得到的数据分布相比，各个分区间数据的分布可能不大均衡。</p>
<ul>
<li>KEY分区：根据MYSQL数据库提供的哈希函数来分区。<br>与HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用MYSQL数据库提供的函数进行分区。对于NDB Cluster引擎，MYSQL数据库使用MD5函数来分区；对于其他引擎，Mysql数据库使用内部的哈希函数。<br>在KEY分区中，使用关键字LINEAR 和在HASH分区中具有同样的效果。</li>
</ul>
<p>无论哪种类型的分区，如果表中存在主键或者唯一索引时，分区列必须时唯一索引的一个组成部分。<br>如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。</p>
<p>以上四种RANGE、LIST、HASH、KEY分区条件是，数据必须是整形，如果不是整型，那应该需要通过函数将其转化成整型，如YEAR（）, TO_DAYS(), MONTH()等函数。</p>
<ul>
<li>Column分区，RANGE分区和LIST分区的一种进化。<br>COLUMN分区可以直接使用菲整形的数据进行分区，分区根据类型直接比较得到，不需要转化为整形。<br>RANGECOLUMNS分区可以对多个列的值进行分区。</li>
</ul>
<p>COLUMN分区支持<br>所有的整型：INT、SMALLINT、TINYINT、BIGING。<br>日期类型：DATE、DATETIME<br>字符串类型：CHAR、VARCHAR、BINARY、VARBINARY。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">  a INT,</span><br><span class="line">  b DATETIME</span><br><span class="line">)engine&#x3D;innodb</span><br><span class="line">partition by range columns(b)(</span><br><span class="line">  partition p0 values less than (&#39;2020-01-01&#39;),</span><br><span class="line">  partition p1 values less than (&#39;2020-02-01&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h4 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h4><p>   子分区是在分区的基础上再进行分区，有时页称为符合分区。 MySQL允许在RANGE和LIST的分区傻姑娘再进行KEY或者HASH的子分区。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t(</span><br><span class="line">   a int,</span><br><span class="line">   b date</span><br><span class="line"> )engine &#x3D; innodb</span><br><span class="line"> partition by range(year(b))</span><br><span class="line"> subpartition by hash(to_days(b))</span><br><span class="line"> subpartitions 2(</span><br><span class="line">     partition p0 values less than (1990),</span><br><span class="line">     partition p1 values less than (2000),</span><br><span class="line">     partition p2 values less than maxvalue</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<h4 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h4><p>MysQL允许对NULL值做分区，对于RANGE分区，如果像分区列插入了NULL值，则Mysql数据库将该值放入到最左边的分区。<br>LIST分区下要使用NULL值，必须显式地指出将该值放入哪个分区。<br>HASH和KEY分区函数会将NULL值的记录返回0.</p>
<h4 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h4><p>当数据量大时，分区可以有效降低B+树的层级。<br>当数据量小时，分区带来的收益并不明显，并且有可能导致扫描所有分区反而降低效率。</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/04/%E6%96%87%E4%BB%B6/">
      MySQL 文件
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月4日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>  动态参数可以在Mysql实例运行中进行更改，可以通过SET命令对动态参数值进行修改。<br>  SET [global|session]  key = value;</p>
<h3 id="静态参数"><a href="#静态参数" class="headerlink" title="静态参数"></a>静态参数</h3><p>  静态参数在整个实例生命周期内不得进行更改，需要重新启动实例才会生效。</p>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了对Mysql的启动、运行、关闭过程中所有的错误、警告和正确的信息。</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>可以帮助定位可能存在问题的SQL语句，从而进行SQL层面的优化。Mysql在启动时设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。<br>通过设置 long_query_time 来设置，单位为秒。<br>log_queries_not_using_indexes: 记录没有使用索引的查询日志。<br>log_throttle_queries_not_using_indexes:每分钟允许记录到showLog的且未使用索引的SQL语句次数，0表示不限制。</p>
<p>查看慢日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow *.log</span><br><span class="line">&#x2F;&#x2F;查看执行时间最长的10条sql语句</span><br><span class="line">mysqldumpslow -s al -n 10 *.log</span><br></pre></td></tr></table></figure>

<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。</p>
<p>查看查询日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail *.log</span><br></pre></td></tr></table></figure>


<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类对数据本身没有修改的操作。二进制日志还包括了执行数据库更改操作的时间等其他额外信息。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>恢复<br>某些数据的恢复需要二进制日志，如在一个数据库全备文件恢复后，用户可以通过二进制日志进行pint-in-time的恢复。</li>
<li>复制<br>与恢复类似，通过复制和执行二进制日志使另一台远程的MySQL数据库与当前数据库进行实时同步。</li>
<li>审计<br>通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li>max_binlog_size: 单个日志文件的最大值，默认1G</li>
<li>binlog_cache_size: 所有未提交的二进制日志会被记录到一个缓存中，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，该缓冲的大小默认为32。该值是基于会话的，每个会话会申请32K的空间。</li>
<li>binlog_cache_use: 记录了使用临时文件写二进制日志的次数。</li>
<li>sync_binlog：表示每写缓冲多少次就同步到磁盘，为1时，表示采用同步写磁盘的方式来写二进制日志，这时写操作不使用操作系统的缓冲来写二进制日志。默认值为0.</li>
<li>binlog-do-db：写入哪些库的日志，默认为空表示同步所有库的日志到二进制日志。</li>
<li>binlog-ignore-db：忽略哪些库的日志</li>
<li>log-slave-update：当前库为slave时，如果需要将从master取得并执行的二进制日志写入自己的二进制日志文件中时需要设置该值。</li>
<li>binlog_format：STATEMENT/ROW/MIXED<br>STATEMENT：格式基于SQL语句，如果主服务器运行rand、uuid等函数或者触发器等操作时，就会导致主从服务器上表中的数据库表中的数据库不一致。<br>ROW：二进制的日志，记录了表的更改情况，解决了Statement下复制的问题。可以设置InnoDB的事务隔离设置为READ_COMMITTED，以获得更好的并发性。<br>MIXED：默认采用STATEMENT，但是在特殊情况下会转为ROW。</li>
</ul>
<h2 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h2><p>名为mysql.sock,可以通过Unix域套接字方式进行与本地MySQL进行连接。套接字文件由参数socket控制。</p>
<h2 id="PID文件"><a href="#PID文件" class="headerlink" title="PID文件"></a>PID文件</h2><p>MySQL实例启动时，会将自己的进程ID写入一个文件中，该文件为PID文件。</p>
<h2 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h2><p>因为MySQL插件式存储引擎的体系结构关系，MySQL数据的存储是根据表进行的，每个表都会有与之对应的文件。但不论表采用哪种存储引擎，MySQL都有一个以frm为后缀名的文件，记录了这个表结构或者视图的定义。</p>
<h2 id="Innodb存储引擎文件"><a href="#Innodb存储引擎文件" class="headerlink" title="Innodb存储引擎文件"></a>Innodb存储引擎文件</h2><h3 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h3><p>InnoDB采用将存储的数据按照表空间进行存放的设计。默认配置喜爱会有一个初始大小为10MB，名为ibdata1的默认表空间文件。</p>
<p>将ibdata1,ibdata2两个文件用来组成表空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path&#x3D;&#x2F;db&#x2F;ibdata1:2000M;&#x2F;dr2&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>
<p>如果该两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。<br>设置innodb_data_file_path后，所有给予innoDB存储引擎的表的数据都会记录带该共享表空间中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_file_per_table&#x3D;ON &#x2F;&#x2F;每个基于InnoDB存储引擎的表产生一个独立表空间。命名规则是：表名.ibd</span><br></pre></td></tr></table></figure>
<p>单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还存放在默认的表空间中。</p>
<p><img src="/2020/11/04/%E6%96%87%E4%BB%B6/table_space.jpg" alt="表空间"></p>
<h3 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h3><p>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。<br>他们记录了对于InnoDB存储引擎的事务日志。</p>
<p>重做日志用于由于主机宕机导致实例失败时，恢复到失败前的状态，一次来保证数据的完整性。</p>
<p>每个InnoDB存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志文件。为了得到更高的可靠性，用户可以设置多个的景象日志组。将不同的组存放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。<br>InnoDB存储引擎献血重做日志文件1，当达到文件的最后时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innodb_log_file_size:每个重做日志文件的大小</span><br><span class="line">innodb_log_files_in_group: 日志文件组中重做日志文件的数量，默认为2</span><br><span class="line">innodb_mirrored_log_groups: 日志镜像文件组的数量，默认为1，表示没有镜像。</span><br><span class="line">innodb_log_group_home_dir: 日志文件组所在的路径，默认为.&#x2F;</span><br></pre></td></tr></table></figure>


<p>重做日志文件的大小对InnoDB存储性能有非常大的影响。<br>如果设置太大，在恢复时可能需要很长的时间。<br>如果设置太小，会导致一个事务的日志需要多次切换重做日志文件。同时会导致频繁地发生 async checkpoint， 导致性能抖动。</p>
<h4 id="二进制文件与重做日志"><a href="#二进制文件与重做日志" class="headerlink" title="二进制文件与重做日志"></a>二进制文件与重做日志</h4><p>层次不同：<br>二进制日志：记录所有与MySQL数据库有关的日志记录，包括InnoDB，MyISAM，Heap等其他存储引擎的日志。<br>重做日志：值记录InnoDB存储引擎本身的事务日志。</p>
<p>内容不同：<br>二进制日志文件记录的是一个事务的具体操作内容，为逻辑日志。<br>重做日志记录的是关于每个页的更改的物理情况。</p>
<p>写入时间不同：<br>二进制文件仅在事务提交前进行，无论事务大小，只写磁盘一次。<br>在事务进行的过程后再难过，不断有重做日志条目被写入到重做日志文件中。</p>
<h4 id="重做日志条目结构"><a href="#重做日志条目结构" class="headerlink" title="重做日志条目结构"></a>重做日志条目结构</h4><p>redo_log_type | space | page_no | redo_log_body<br>redo_log_type ： 占用1字节，表示重做日志的类型<br>space： 表示表空间的ID，采用压缩的方式，占用空间可能小于4字节<br>page_no：表示页的偏移量，压缩方式<br>redo_log_body:每个重做日志的数据部分，恢复时需要调用相应函数解析。</p>
<h4 id="重做日志写入"><a href="#重做日志写入" class="headerlink" title="重做日志写入"></a>重做日志写入</h4><p>重做日志的写入不是直接写，而是先写入重做日志缓冲（redo log buffer）中，然后按照一定的条件顺序地写入日志文件。</p>
<p>从重做日志缓冲网磁盘写入时，按照写入的最小单位（扇区大小：512个字节）进行写入，因此可以保证写入必定是成功的，因此在重做日志的写入过程不需要有doublewrite。</p>
<p>写入时机：<br>1） 不论事务已经提交，主线程每秒都会将重做日志缓冲写入到磁盘的重做日志文件中。<br>2） 事务提交时，设置了innodb_flush_log_at_trx_commit。<br>    值为0时，不将事物的重做日志写入磁盘上的日志文件，<br>    1表示在执行commit时将重做日志缓冲同步写到磁盘，<br>    2表示将重做日志异步写到磁盘（也就是写到文件系统的缓存中）</p>
<p>因此，为了保证ACID中的D（持久性），必须将innodb_flush_log_at_trx_commit设置为1，当数据库因为意外宕机时，可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/">
      InnoDB体系架构
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月3日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="InnoDB-体系架构"><a href="#InnoDB-体系架构" class="headerlink" title="InnoDB 体系架构"></a>InnoDB 体系架构</h2><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><h4 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h4><p>主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。<br>包括脏页的刷新、合并插入缓冲、UNDO页的会后等。</p>
<h4 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h4><p>InnoDB中使用了AIO（AsyncIO）来处理写IO请求，提高了数据库性能。<br>IO线程的工作主要是负责AIO的回调处理。</p>
<p>可以使用innodb_read_io_threads和innodb_write_io_threads进行设置。</p>
<h4 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h4><p>事务被提交后，其所用的undolog可能不再需要，因此需要Perge Thread来回收已经使用并分配的undo页。<br>可以使用 innodb_purge_thread 来设置线程数量。</p>
<h4 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h4><p>为了减轻MasterThread的工作，以及用户查询线程的阻塞提升性能。<br>将之前版本中脏页的舒心操作都放入到单独的线程中完成。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>InnoDB存储引擎是基于磁盘存储的，将其中的记录按照页的方式进行管理。缓冲池就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库的性能影响。</p>
<p>在数据库中进行读取页的操作，首先从磁盘读取到的页放在缓冲池中，下一次再读取相同的页时，首先判断该页是否在缓冲池中。如果在缓冲池中，则直接读取该页，否则读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。</p>
<p>页从缓冲池刷新到磁盘上的操作是通过Checkpoint的机制刷新回到磁盘。</p>
<p>因此缓冲池的大小直接影响着数据库的整体性能。可以使用 innodb_buffer_pool_size 来设置缓冲池大小。</p>
<p>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自使用哈希索引、InnoDB存储的锁信息、数据字典信息等。</p>
<p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/buffer_pool.jpeg" alt="缓冲池"></p>
<p>InnoDB可以有多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中。这样减少了数据库内部的资源竞争，增加了数据库的兵法处理能力。可以使用 innodb_buffer_pool_instances来进行配置。</p>
<h4 id="缓冲池管理算法"><a href="#缓冲池管理算法" class="headerlink" title="缓冲池管理算法"></a>缓冲池管理算法</h4><h5 id="LRU-List"><a href="#LRU-List" class="headerlink" title="LRU List"></a>LRU List</h5><p>LRU List 用来管理已经读取的页，最频繁使用的页存放在LRU列表的前端，最少使用的页存放在LRU列表的尾端。当缓冲池不能存放新读取到的页时，首先释放LRU列表中尾端的页。</p>
<p>新读取的页并不直接存放在LRUList列表的前端，而是存放在midPoint的位置。midPoint之后的列表称为Old列表，之前的列表称为New列表，New列表中的页都是活跃的热点数据。</p>
<p>这是因为，如果新读取的页如果放在最前端时，如果遇到需要访问和扫描大部分甚至全部页的时候，热点页面被刷出缓存，但是非热点数据却存放在了LRU列表的最前端。 </p>
<p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/mid_point.jpg" alt="MID POINT"></p>
<p>使用参数：innodb_old_blocks_pct 来控制midPoint的位置。<br>         innodb_old_blocks_times 来控制读取到MidPoint位置后需要等待多久才会被加入到LRU列表的New列表。</p>
<h5 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h5><p>数据库刚启动的时候，LRUList是空的没有任何页。此时页都存放在FreeList中。当需要从缓冲中分页时，县从Free列表中查找是否有可用的空闲页，如果有可用的空闲页，则将该页从FreeList中删除，存放到LRUList中。如果FreeList中没有可用的空闲页，根据LRU算法，淘汰LRU尾部的页，将该页内存空间分配给新的页。</p>
<h5 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h5><p>在LRU列表中的页被修改后，该页需要通过CheckPoint机制刷回磁盘。<br>FlushList中的页称为脏页里诶包，脏页既存在于LRUList，也存在于FlushList。<br>LRUList用来管理缓冲池中页的可用性，FlushList用来管理将页刷新回磁盘。</p>
<h4 id="重做缓冲日志"><a href="#重做缓冲日志" class="headerlink" title="重做缓冲日志"></a>重做缓冲日志</h4><p>InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按照一定的频率（每秒一次）将其刷新到重做日志文件。<br>可以使用参数：innodb_log_buffer_size来调整该缓冲区域的大小，默认为8MB。</p>
<h4 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h4><p>例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象，这些对象记录了一些如LRU、锁、等待信息，而这个对象的内存需要从额外内存池中申请。</p>
<p>在对一些数据结构本身的内存进行分配是，需要从额外的内存池中进行申请。因此在申请了很大的InnoDB缓冲池是，需要相应地增加额外的内存池。</p>
<h2 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h2><p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/check_point.png" alt="CheckPoint"></p>
<p>Write Pos 是当前记录的位置，一边写好一遍往后移。<br>CheckPoint 是当前要擦除的位置，也就是往后推移并且循环的，擦除记录前要把记录更新到数据文件。<br>Write Pos和 CheckPoint之间是可以写入的部分，用来记录新的操作。</p>
<p>1） 缩短数据库的恢复时间；<br>    当数据库发生宕机时，数据库不需要重做所有的日志，因为CheckPoint之前的页都已经刷新回磁盘，因此只需要对checkPoint之后的重做日志进行恢复，这样大大缩短了数据库的恢复时间。</p>
<p>2） 缓冲池不够用时，将脏页刷新到磁盘；<br>    当缓冲池不够用时，根据LRU算法会移除最近最少使用的页，如果当前页为脏页，则需要刷新该脏页到磁盘。</p>
<p>3） 重做日志不可用时，刷新脏页；<br>    重做日志中Write Pos和checkPint之间没有空间来记录RedoLog时，强制刷新脏页，使得CheckPoint后移。</p>
<h2 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h2><h3 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h3><h4 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h4><p>对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果存在则直接插入；如果不在则先放入到一个InsertBuffer对象中。然后再以一定的频率进行InsertBuffer和辅助索引页子结点的Merge操作。<br>通常会将多个插入操作合并到一个操作中，大大提高了非聚集索引插入的性能。</p>
<p>InsertBuffer的使用要同时满足两个条件：<br>1） 索引是辅助索引（非聚集索引）<br>    如果是聚集索引，则直接按照顺序写就行了，很高效。<br>2） 索引不是唯一的<br>    因为在插入缓冲时，数据库并不去查找索引页来判断插入的记录唯一性。如果去查找肯定又会有离散读取的情况发生，从而导致InsertBuffer失去意义。</p>
<p>当满足索引是辅助索引且非唯一时，InnoDB存储引擎会使用InsertBuffer， 这样就可以提高插入操作的性能。</p>
<p>当应用程序进行大量的插入操作时数据库发生了宕机，这个时候会有大量的InsertBuffer并没有合并到实际的非聚集索引中，因此恢复可能需要很长的时间。</p>
<p>同时在写密集的情况下，InsertBuffer会占用过多的缓冲池内存（innodb_buffer_pool），默认最大可以占用1/2的缓冲池内存。修改IBUF_POOL_SIZE_PER_MAX_SIZE 可以对 InsertBuffer大小进行控制，比如改为3则最大只能使用1/3的缓冲池内存。</p>
<h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p>InsertBuffer 的升级版本，可以对Insert、Delete、Update都进行缓冲，分别是InsertBuffer、DeleteBuffer、PurgeBuffer。</p>
<p>ChangeBuffer适用对象依然是非唯一的辅助索引。</p>
<p>对一条记录进行UPDATE操作需要分为：<br>1）将记录标记为删除（DeleteBuffer对应该过程）；<br>2）真正将记录删除（PurgeBuffer对应删除操作）</p>
<p>开启Buffer选项：<br>innodb_change_buffering: [inserts、deletes、purges、changes、all、none]<br>changes表示启用inserts、deletes<br>all表示启用所有，默认值<br>none表示都不启用。</p>
<p>可以通过innodb_change_buffer_max_size控制changebuffer最大使用内存的数量：<br>该参数的最大有效值为50， 表示只能占用缓冲池的50%。</p>
<h4 id="Merge-InsertBuffer"><a href="#Merge-InsertBuffer" class="headerlink" title="Merge InsertBuffer"></a>Merge InsertBuffer</h4><ul>
<li>辅助索引页被读取到缓冲池时；<br>  执行SELECT语句时，要确认该辅助索引页是否有记录存放于InsertBufferB+树中。<br>  有，则将InsertBufferB+树中该页的记录插入到该辅助索引页中。</li>
<li>InsertBuffer BitMap 追踪到该辅助索引页已无可用空间时；<br>  InsertBuffer BitMap用来追踪每个辅助索引页的可用空间，并至少有1/32页的可用空间。如果插入辅助索引记录时监测到插入记录后可用空间小雨1/32页，则会强制进行一个合并操作。<br>  （强制读取辅助索引页，将InsertBufferB+树中该页的记录以及待插入的记录插入到辅助索引页中。）</li>
<li>Master Thread<br> Master Thread 每秒或者每10秒 根据srv_innodb_io_capacity 的百分比来进行一个Merge InsertBuffer操作。</li>
</ul>
<p>如果在merge时，要进行的merge表已经被删除，此时直接丢弃已经被Insert/Change Buffer的数据记录。</p>
<h3 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h3><p>DoubleWrite为了提升InnoDB存储引擎的数据页可靠性。</p>
<p>当InnoDB存储引擎正在将某个页写入到表中，当这个页只被写了一部分（16k的页，只写了前4k）就发生了宕机，这种情况被称为写失效（partial page write）。</p>
<p>为了解决partial page write，InnoDB实现了Double write buffer，就是在写数据页之前，先把这个数据页写到一块独立的物理文件位置（ibdata），然后再写到数据页。<br>这样在宕机重启时，如果出现数据页损坏，就需要通过该页的副本来还愿该页，然后再进行redo log重做。</p>
<p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/double_write.png" alt="两次写"></p>
<p>double write由两部分组成，一部分是内存中的double write buffer，大小是2MB， 另一部分是磁盘上的共享表空间中连续的128个页，大小也是2M。<br>1）当触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝到内存中的doublewrite buffer中；<br>2）接着从两次写缓冲区分两次写入磁盘共享表空间中（连续存储、顺序写）每次写1MB；<br>3）再将doublewrite buffer中的脏页数据写入实际的各个表空间中（离散写）。</p>
<p><img src="/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/double_write_recovery.png" alt="两次写恢复"></p>
<p>当不需要开启doublewrite时，使用skip_innodb_doublewrite 关闭。</p>
<p>innodb_buffer_pool_flushed : 当前从缓冲池中刷新到磁盘页的数量<br>innodb_dblwr_pages_written: double write 的数量</p>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>InnoDB存储引擎会监控对标上各索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引。自适应哈希索引是通过缓冲池的B+树页构造而来，因此建立的速度很快，不需要对整张表建立哈希索引。 InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>
<p>自使用哈希索引有一个要求，对这个页的查询条件是一样的。<br>如：where a = xxx;<br>   where a = xxx and b = xxx;</p>
<p>自使用哈希索引是数据库自优化的，无需DBA对数据库进行调整。<br>可以通过innodb_adaptive_hash_index 来启用或者禁用。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>1）提升吞吐量<br>2）IO Merge操作</p>
<h3 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h3><p>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。<br>通过AIO可以将多个IO卸乳操作合并为一个IO操作。</p>
<p>可以通过innodb_flush_neighbors 来关闭或者开启该特性。</p>
<p>select version();<br>show variables like ‘innodb_%_threads’;<br>show variables like ‘innodb_buffer_pool_size’;<br>show variables like ‘innodb_buffer_pool_instances’;<br>show variables like ‘innodb_change_buffering’;<br>show engine innodb status;</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/11/03/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">
      Mysql体系结构和存储引擎
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/Mysql</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年11月3日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mysql-体系结构"><a href="#Mysql-体系结构" class="headerlink" title="Mysql 体系结构"></a>Mysql 体系结构</h2><p><img src="/2020/11/03/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Mysql_struct.jpeg" alt="MySQL体系结构"></p>
<ul>
<li>链接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓存组件</li>
<li>插件式表存储引擎</li>
<li>物理文件</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>可以根据MySQL官方手册给出的定义存储引擎的过程来编写符合自己需求的存储引擎。<br>或者使用官方提供的存储引擎。</p>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理的应用。其特点是行锁设计、支持外间，并支持类似于Oracle的非锁定读（默认读取操作不会产生锁）。</p>
<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。可以将每个独立的表单独存放在一个idb文件中。InnoDB存储引擎支持使用裸设备来建立其表空间。</p>
<p>InnoDB通过多版本并发控制（MVCC）来获得高并发性；<br>实现了SQL标准的4种隔离级别，默认为REPEATABLE；<br>使用Next-KeyLocking策略避免欢度现象的产生；<br>提供了插入缓冲（Insert Buffer）；<br>二次写（Double Write）；<br>预读（Read Ahead）。</p>
<p>Innodb存储引擎采用了聚集的方式，每张表的存储都是按照主键的顺序进行存放。如果没有显式地在表定义时制定主键，InnoDB存储引擎会为每一行生成一个6字节的RowId，并以此作为主键。</p>
<h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>MyISAM引擎主要面向一些OLAP（联机分析处理）的应用。 因此不支持事务、表锁设计，但支持全文索引。</p>
<p>它的缓存池只缓存索引文件，不缓存数据文件，数据文件的缓存交给操作系统来完成。<br>MYISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。</p>
<h3 id="Maria存储引擎"><a href="#Maria存储引擎" class="headerlink" title="Maria存储引擎"></a>Maria存储引擎</h3><p>其目标是用来替代原有的MYISAM，可以看作是MyISAM的后续版本。<br>特点是支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项。<br>更好的BLOB自负类型的处理性能。</p>
<h3 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h3><p>也叫NDBCluster存储引擎，壮阳药用于MySQL Cluster分布式集群环境。</p>
<p>NDB的特点是数据全部放在内存中，因此主键查找的速度极快，并且通过添加NDB数据存储结点可以线性地提高数据库性能，是高可用、高性能的集群系统。<br>由于其存储引擎特性，Join操作是在Muysql数据库层完成，而不是在存储引擎层完成。</p>
<h3 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h3><p>表中的数据存放在内存中，适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引。</p>
<p>Memory存储引擎不支持表锁，并发行能差，不支持TEXT和BLOB列类型。存储varchar时是按照char的方式进行的。</p>
<p>MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集。<br>如果中间爱护你接过机大于Memory存储引擎表的容量设置，又或者包含有TEXT或者BLOB列类型的字段，Mysql会把中间结果集转换到MyISAM存储引擎表存放到磁盘中（因为MyISAM不缓存数据文件），因此会有性能损失。</p>
<h3 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h3><p>用来存储归档数据，如日志信息等。<br>使用zlib算法将数据行进行压缩后存储，压缩比达到1:10.<br>该引擎只支持INSERT和SELECT操作，该引擎使用行锁来实现高并发的插入操作。</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">
      DataBase-分布式事务
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/数据库</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年10月16日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着业务的增长，需要进行分表、分库，甚至拆分应用演化成微服务。<br>因此一次交易需要跨库、跨服务保证每个系统中的交易要么全部成功，否则全部回滚。这里就涉及到分布式事务。</p>
<p>XA协议时一个基于数据库的分布式事务协议，其分为两部分：事务管理器和本地资源管理器。<br>事务管理器作为一个全局调度着，负责对各个本地资源管理器统一发送提交或者回滚命令。<br>二阶段提交和三阶段提交都是根据此协议衍生而来，Oracle和Mysql均已实现了XA接口。<br>除了二阶段提交和三阶段提交外还有Try Confirm Cancel (TCC)、本地消息队列等分布式事务解决方案。</p>
<h3 id="二阶段提交-2PC"><a href="#二阶段提交-2PC" class="headerlink" title="二阶段提交 2PC"></a>二阶段提交 2PC</h3><p>二阶段提交需要进行两个阶段的操作，准备阶段和提交阶段。</p>
<p>准备阶段就是事务管理器（协调者）分别给不同的系统发送“准备”命令，这些系统出了提交数据库事务之外的所有操作，都要在准备阶段操作完成。</p>
<p>提交阶段就是事务管理器（协调者）给不同的系统发送“提交”命令，每个系统提交自己的数据库事务，然后给协调者返回“提交成功”， 协调者收到所有响应以后，返回给客户端成功响应。<br>如果遇到异常情况提交不成功，需要做一些补偿机制来保证成功。</p>
<p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/2pc.jpg" alt="二阶段提交"></p>
<p>对于二阶段提交：<br>如果准备阶段全部返回成功， 那么进入提交阶段，该必须保证成功。<br>如果准备阶段有一个失败，那么协调者通知每个系统回滚。</p>
<p>二阶段提交保证了原子性与隔离性。所以2PC适合对数据一致性高的场景。</p>
<p>缺陷：<br>性能低：整个事务的执行过程需要阻塞服务端线程和数据库会话。<br>协调者单点故障：一旦协调者宕机，就会导致事务回话一致处于等待提交阶段，直到事务超时自动回滚。<br>超时导致同步阻塞：当某个参与者节点通信处于超时，其余参与者都会被懂阻塞导致占用的资源不能释放。</p>
<p>适合场景：只有病发量不大且需要强一致的情况下才考虑使用2PC。</p>
<h3 id="三阶段提交-3PC"><a href="#三阶段提交-3PC" class="headerlink" title="三阶段提交 3PC"></a>三阶段提交 3PC</h3><p>三阶段提交是对二阶段提交的一种升级优化，它在二阶段提交的中间增加了precommit阶段。保证了在最后提交阶段之前，各个参与者节点状态都一致。<br>同时在协调者与参与者中都引入超时机制，当参与者由于各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2pc的单点故障问题，但是3pc还是没有能从根本上解决数据一致性的问题。</p>
<p>三个阶段分别是can commit、Pre Commit 、Do Commit；</p>
<p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3pc.jpg" alt="三阶段提交"></p>
<h4 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a>CanCommit</h4><p>类似于二阶段提交的准备阶段，协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作，如果可以提交就返回YES，否则返回NO。如果全部响应YES则进入下一个阶段。</p>
<h4 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a>PreCommit</h4><p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有两种可能</p>
<p>所有参与者的反馈都是YES那么执行事务的预执行：<br>  1）发送于提交请求，协调者向参与者发送Precommit请求，并进入Prepared阶段。<br>  2）事务预提交，参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。<br>  3）响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p>
<p>假如任何一个参与者向协调者发送了NO响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<br>  1）发送终端请求： 协调者向所有参与者发送abort请求。<br>  2）中断事务：参与者收到来自协调者的abort请求之后（或者超时之后，仍未收到协调者的请求）执行事务的中断。</p>
<h4 id="DoCommit"><a href="#DoCommit" class="headerlink" title="DoCommit"></a>DoCommit</h4><p>该阶段进行真正的事务提交，也分为两种情况。</p>
<h5 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h5><p>发送提交请求： 协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态。<br>并向所有参与者发送doCommit请求。<br>事务提交：参与者收到docommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有的事务资源。<br>响应反馈：参与者事务提交之后，向协调者发送ACK请求<br>完成事务： 协调者接收到所有参与者的ACK响应之后，完成事务。</p>
<h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>协调者没有接收到参与者发送的ACK响应（可能是参与者发送的不是ACK响应，也可能是响应超时），那么就会执行中断事务。</p>
<p>发送中断请求：协调者向所有参与者发送abort请求。<br>事务回滚：参与者接收到abort请求后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。<br>反馈结果：参与者完成事务回滚之后，向协调者发送ACK信息<br>中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断操作。</p>
<p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3pc-status.jpg" alt="三阶段提交状态图"></p>
<p>如果已经完成了Precommit进入到Docommit阶段，有的参与者由于超时没有收到Docommit请求时，会自动提交本地事务，并且释放资源。</p>
<p>三阶段提交解决了二阶段提交无法释放资源的问题。<br>也保证了在提交事务之前所有参与者的状态都一致</p>
<h3 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h3><p>针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）</p>
<p>它分为三个操作：</p>
<h5 id="Try阶段"><a href="#Try阶段" class="headerlink" title="Try阶段"></a>Try阶段</h5><p>主要针对业务系统做检测以及资源预留。</p>
<h5 id="Confirm阶段"><a href="#Confirm阶段" class="headerlink" title="Confirm阶段"></a>Confirm阶段</h5><p>确认执行业务操作。</p>
<h5 id="Cancel阶段"><a href="#Cancel阶段" class="headerlink" title="Cancel阶段"></a>Cancel阶段</h5><p>取消执行业务操作。</p>
<p>TCC处理流程与2PC类似，不过2PC通常是在跨库的DB层面，TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，是的降低锁冲突、提高吞吐量成为可能。</p>
<p>不足之处在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。<br>此外其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。<br>为了满足一致性的要求，confirm和cancel必须实现幂等。</p>
<p><img src="/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/TCC.png" alt="TCC(图片来源于网络)"></p>
<h3 id="本地消息队列"><a href="#本地消息队列" class="headerlink" title="本地消息队列"></a>本地消息队列</h3><p>如果只需要保证数据的最终一致性，那么可以使用消息队列来解决。</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/10/15/DataBase-%E4%BA%8B%E5%8A%A1/">
      DataBase-事务
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://pickonebyone.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>June</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java技术栈/数据库</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年10月15日</p>
  </a>
</div>

            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是事务Transaction"><a href="#什么是事务Transaction" class="headerlink" title="什么是事务Transaction"></a>什么是事务Transaction</h2><p>Transaction一词在英语的翻译中还有一次交易、业务、事务、办理、处理；</p>
<p>对于一次账户充值100元的操作，其中就有多个环节。<br>1）检查账户的有效性，查询账户余额；<br>2）记录充值流水；<br>3）为账户余额增加100元。</p>
<p>对于这三个操作来讲，他是一个Transaction， 要么都成功，只要有一个失败，就必须整个Transaction失败，不允许记录了充值流水成功，但是余额增加失败。这三个是一个整体，是不可分割的工作单元。</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>原子性 Atomic：要么都成功，只要有一个步骤失败，整个步骤必须回滚（失败）。<br>一致性 Consistency：事务保证读取到的数据总是一致的，如（不存在100元的充值流水时金额为100元， 存在100元的充值流水时金额为200元）。<br>但是对于这个充值过程来讲，肯定是先记录了充值记录，后增加100元余额。可以查到充值记录，但余额是100是客观存在的。<br>隔离性Isolation：为了保证一致性，事务执行过程中的中间状态不对外部可见，事务需要对整个过程进行隔离。<br>持久性 Durability：只要事务一经提交，就一定会被持久化到磁盘中。</p>
<h2 id="Transaction-阶段"><a href="#Transaction-阶段" class="headerlink" title="Transaction 阶段"></a>Transaction 阶段</h2><p>Transaction 需要有开始和结束，标记一个Transaction的开始和截止；<br>当所有的操作都成功的时候，需要Commit;<br>当其中某个操作失败的时候，之前的操作需要Rollback；</p>
<p>Transaction Start;<br>Transaction Commit Or Rollback;<br>Transaction End;</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>假如业务员给账户A增加100元的操作的同时（记录了充值流水100元，流水号为666），对账系统也在同时运行同时读取到了这一笔流水号为666的流水记录。但是后续的为余额增加100元的操作失败了，整个Transaction RollBack。 导致账户余额比对账系统少了100元。</p>
<p>在这里，对账系统看到了业务系统Transaction未提交时的数据，叫脏读。<br>也就是说当前事务的中间状态，对其他事务时可见的。</p>
<p>事务的最低隔离级别是未提交读（Read Uncommitted），因此会发生脏读的现象。<br>为了解决脏读的现象，需要将事务隔离起来，只允许读到已提交的数据。 Read Committed.</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>假如业务员A给用户增加100元。</p>
<p>开启事务；<br>查询账户余额 100元；<br>有其他事情去忙……</p>
<p>此时业务员B也给用户增加100元。<br>开启事务；<br>查询账户余额 100元<br>增加流水记录；<br>增加账户余额100元，变为200元；<br>结束事务；</p>
<p>业务员A回来为A增加100元：<br>查询账户余额 200元；</p>
<p>不可重复读就是业务员A在同一个事务内，先后两次读取同一条数据的结果可能不一样。<br>可重复读就是业务员A在同一个事务内，先后两次读取同一条数据的结果总是相同的，无论其他会话是否已经更新了这条数据。</p>
<p>为了保障在同一事务下，先后两次读取到的同一条数据结果一致，需要将事务的隔离级别调整为可重复读（Repeatable Read）。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>假如业务员A给用户增加100元。</p>
<p>开启事务；<br>查询流水中是否有ID为1000的流水记录，不存在；</p>
<p>业务员B给用户增加100元；<br>开启事务；<br>查询流水中是否有ID为1000的流水记录，不存在；<br>插入流水记录；<br>更新账户余额为200；<br>提交事务；</p>
<p>业务员A开始执行；<br>插入流水记录，此时已经有ID为1000的流水记录，系统异常；<br>可以开启重试机制；<br>由于隔离性，查询是否有ID为1000的流水记录时还是不存在，重试插入时还是异常。</p>
<p>为了解决幻读的问题，需要将所有的事务和操作进行串行化。这也是Database的最高隔离级别，性能也最差。</p>
<p><img src="/2020/10/15/DataBase-%E4%BA%8B%E5%8A%A1/Transaction-Isolation.jpg" alt="事务的隔离级别以及解决的问题"></p>
<p>对于账户充值来讲，交易的原子性以及持久性是最重要的。可以适当牺牲一些一致性和隔离性。</p>
<p>以下操作在 ReadCommitted 和 Repeatable Read下是安全的。<br>1）给账户余额表增加一个log_id属性，记录最后一笔交易的流水号。<br>2）首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号。<br>3）写入流水记录。<br>4）更新账户余额以及流水记录ID，需要在更新语句的Where条件中限定，只有流水好等于之前查询出的流水号时才能更新。<br>  update account_balance set amount = amount + 100 , log_id = 2 where user_id = 0 and log_id = 1;<br>5）检查更新余额的返回值，如果为1 提交事务，否则回滚。</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
        <p class="current">
          1 / 5
        </p>
        
          <a class="next" rel="next" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/page/2/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  

</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow ">
  <div class='content'>
    
      
        <a class='avatar flat-box' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'/>
        </a>
      
    
    
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"
            id="categoriesJavaE68A80E69CAFE6A088"
            ><div class='name'>Java技术栈</div><div class='badge'>(42)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Etcd/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Etcd/"
            id="categoriesJavaE68A80E69CAFE6A088Etcd"
            ><div class='name'>Etcd</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java/"
            id="categoriesJavaE68A80E69CAFE6A088Java"
            ><div class='name'>Java</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
            id="categoriesJavaE68A80E69CAFE6A088JavaE8999AE68B9FE69CBA"
            ><div class='name'>Java虚拟机</div><div class='badge'>(11)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"
            id="categoriesJavaE68A80E69CAFE6A088Mysql"
            ><div class='name'>Mysql</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Reids/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Reids/"
            id="categoriesJavaE68A80E69CAFE6A088Reids"
            ><div class='name'>Reids</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"
            id="categoriesJavaE68A80E69CAFE6A088Spring"
            ><div class='name'>Spring</div><div class='badge'>(11)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/" href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/"
            id="categoriesJavaE68A80E69CAFE6A088E695B0E68DAEE5BA93"
            ><div class='name'>数据库</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Linux/" href="/categories/Linux/"
            id="categoriesLinux"
            ><div class='name'>Linux</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Linux/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/" href="/categories/Linux/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/"
            id="categoriesLinuxLinuxE591BDE4BBA4-E4BAA4E99B86E38081E5B9B6E99B86E38081E5B7AEE99B86"
            ><div class='name'>Linux命令 - 交集、并集、差集</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Linux/VIM/" href="/categories/Linux/VIM/"
            id="categoriesLinuxVIM"
            ><div class='name'>VIM</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" href="/categories/Redis/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"
            id="categoriesRedisE99B86E7BEA4E983A8E7BDB2"
            ><div class='name'>集群部署</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"
            id="categoriesE58886E5B883E5BC8F"
            ><div class='name'>分布式</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ID%E7%94%9F%E6%88%90%E5%99%A8/" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ID%E7%94%9F%E6%88%90%E5%99%A8/"
            id="categoriesE58886E5B883E5BC8FIDE7949FE68890E599A8"
            ><div class='name'>ID生成器</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/" href="/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"
            id="categoriesE7949FE4BAA7E58A9B"
            ><div class='name'>生产力</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/" href="/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/"
            id="categoriesE7949FE4BAA7E58A9BsublimeE5BFABE68DB7E994AE"
            ><div class='name'>sublime快捷键</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
            id="categoriesE8AEBEE8AEA1E6A8A1E5BC8F"
            ><div class='name'>设计模式</div><div class='badge'>(26)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
            id="categoriesE8AEBEE8AEA1E6A8A1E5BC8FE5889BE5BBBAE59E8BE6A8A1E5BC8F"
            ><div class='name'>创建型模式</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
            id="categoriesE8AEBEE8AEA1E6A8A1E5BC8FE7BB93E69E84E59E8BE6A8A1E5BC8F"
            ><div class='name'>结构型模式</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"
            id="categoriesE8AEBEE8AEA1E6A8A1E5BC8FE8A18CE4B8BAE59E8BE6A8A1E5BC8F"
            ><div class='name'>行为型模式</div><div class='badge'>(12)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"
            id="categoriesE8AEBEE8AEA1E6A8A1E5BC8FE8AEBEE8AEA1E58E9FE58899"
            ><div class='name'>设计原则</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/ClassLoader/" style="font-size: 14px; color: #999">ClassLoader</a> <a href="/tags/Class%E7%BB%93%E6%9E%84/" style="font-size: 14px; color: #999">Class结构</a> <a href="/tags/DI/" style="font-size: 14px; color: #999">DI</a> <a href="/tags/Etcd/" style="font-size: 14px; color: #999">Etcd</a> <a href="/tags/GC/" style="font-size: 14px; color: #999">GC</a> <a href="/tags/IOC/" style="font-size: 14px; color: #999">IOC</a> <a href="/tags/JMM/" style="font-size: 14px; color: #999">JMM</a> <a href="/tags/JVM/" style="font-size: 20.25px; color: #6f6f6f">JVM</a> <a href="/tags/Java/" style="font-size: 16.5px; color: #888">Java</a> <a href="/tags/Linux/" style="font-size: 14px; color: #999">Linux</a> <a href="/tags/Mysql/" style="font-size: 19px; color: #777">Mysql</a> <a href="/tags/Spring/" style="font-size: 21.5px; color: #666">Spring</a> <a href="/tags/Spring-Bean/" style="font-size: 14px; color: #999">Spring-Bean</a> <a href="/tags/Spring-BeanFactory/" style="font-size: 14px; color: #999">Spring-BeanFactory</a> <a href="/tags/comm/" style="font-size: 14px; color: #999">comm</a> <a href="/tags/linux/" style="font-size: 14px; color: #999">linux</a> <a href="/tags/sort/" style="font-size: 14px; color: #999">sort</a> <a href="/tags/sublime/" style="font-size: 14px; color: #999">sublime</a> <a href="/tags/swap/" style="font-size: 14px; color: #999">swap</a> <a href="/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">中介者模式</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 15.25px; color: #919191">事务</a> <a href="/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">享元模式</a> <a href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 15.25px; color: #919191">代理模式</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 14px; color: #999">优化</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 14px; color: #999">作用域</a> <a href="/tags/%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/" style="font-size: 14px; color: #999">依赖处理</a> <a href="/tags/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/" style="font-size: 14px; color: #999">依赖查找</a> <a href="/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" style="font-size: 14px; color: #999">依赖注入</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 14px; color: #999">内存分配</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 14px; color: #999">分布式事务</a> <a href="/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 17.75px; color: #808080">创建型模式</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">单例模式</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">原型模式</a> <a href="/tags/%E5%8F%82%E6%95%B0/" style="font-size: 14px; color: #999">参数</a> <a href="/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">外观模式</a> <a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" style="font-size: 14px; color: #999">字节码执行引擎</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">对象池模式</a> <a href="/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">工厂方法模式</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/" style="font-size: 14px; color: #999">常用工具</a> <a href="/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">建造者模式</a> <a href="/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 14px; color: #999">快捷键</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">抽象工厂模式</a> <a href="/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/" style="font-size: 14px; color: #999">故障排查</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15.25px; color: #919191">数据库</a> <a href="/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">桥接模式</a> <a href="/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">模版方法模式</a> <a href="/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">状态模式</a> <a href="/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/" style="font-size: 14px; color: #999">生产力</a> <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" style="font-size: 14px; color: #999">生命周期</a> <a href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">策略模式</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" style="font-size: 14px; color: #999">类加载机制</a> <a href="/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">组合模式</a> <a href="/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 19px; color: #777">结构型模式</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 14px; color: #999">编译</a> <a href="/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 22.75px; color: #5e5e5e">行为型模式</a> <a href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">观察者模式</a> <a href="/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 15.25px; color: #919191">解释器模式</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size: 14px; color: #999">设计原则</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 24px; color: #555">设计模式</a> <a href="/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">访问者模式</a> <a href="/tags/%E8%B0%83%E4%BC%98/" style="font-size: 14px; color: #999">调优</a> <a href="/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" style="font-size: 16.5px; color: #888">责任链模式</a> <a href="/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" style="font-size: 14px; color: #999">资源管理</a> <a href="/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F/" style="font-size: 14px; color: #999">运行时区域</a> <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">迭代器模式</a> <a href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 14px; color: #999">适配器模式</a>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>

    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>




  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  















  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 标准 markdown 描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
