{"meta":{"title":"碎碎念","subtitle":"","description":"","author":"Picker","url":"https://www.hessentec.top","root":"/"},"pages":[{"title":"小目标","date":"2020-06-16T09:35:55.000Z","updated":"2020-07-14T13:58:25.086Z","comments":true,"path":"aim/index.html","permalink":"https://www.hessentec.top/aim/index.html","excerpt":"","text":"《深入理解Java虚拟机》读书笔记 (10/10) 类文件结构 类加载器和类加载机制 JVM运行时数据区域 字节码执行引擎 JVM 内存模型 线程和并发 内存分配与回收 编译与编译优化技术 常用监控与故障处理工具 常用的JVM参数 设计模式 创建型模式 （6/6） 单例模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 对象池模式 行为型模式 (12/12) 策略模式 状态模式 访问者模式 迭代器模式 责任链模式 模版方法模式 命令模式 备忘录模式 解释器模式 空对象模式 中介者模式 观察者模式 结构型模式 (7/7) 代理模式 组合模式 装饰器模式 桥接模式 适配器模式 外观模式 享元模式 Spring Spring-Bean Spring-依赖查找 Netty源码 Mysql Redis"},{"title":"关于","date":"2020-07-03T03:29:53.741Z","updated":"2020-07-03T03:29:53.741Z","comments":true,"path":"about/index.html","permalink":"https://www.hessentec.top/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-06-16T09:37:38.000Z","updated":"2020-06-17T14:20:58.176Z","comments":true,"path":"books/index.html","permalink":"https://www.hessentec.top/books/index.html","excerpt":"","text":"学习效率 《如何学习》– 本尼迪克特·凯里。 金融世界观 《中国历代政治得失》–钱穆（中国） 《千年金融史》–威廉·戈兹曼（耶鲁大学教授） 《你一定爱读的极简欧洲史》–约翰·赫斯特（澳大利亚） 《金钱永不眠》(北大唐嫣) 《利率是车，汇率是马》(北大宋国青) 《货币崛起》 银行 《货币金融学》–弗雷德里克·米什金 《认为制造的脆弱性：银行业危机和信贷稀缺的政治根源，Fragile By Design》 作者：查尔斯·开罗米里斯（哈佛大学教授）&amp;史蒂芬·哈伯（哥伦比亚大学教授） 投资银行 《金融体系中的投资银行》 （Investment banking in the Financial System，经济科学出版社）– 查理斯·吉斯特 《伟大的博弈》– 约翰·S·戈登（美国） 《摩根财团》 – 罗恩·彻诺（） 电影·纪录片《大国崛起》– 荷兰的崛起史《肖申克的救赎》《大空头》– 08年美国次贷危机"},{"title":"我的朋友们","date":"2020-06-16T07:37:43.223Z","updated":"2020-06-16T07:37:43.223Z","comments":true,"path":"friends/index.html","permalink":"https://www.hessentec.top/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-06-16T06:58:53.446Z","updated":"2020-06-16T06:58:53.446Z","comments":true,"path":"categories/index.html","permalink":"https://www.hessentec.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-16T06:59:26.769Z","updated":"2020-06-16T06:59:26.769Z","comments":true,"path":"tags/index.html","permalink":"https://www.hessentec.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"性能调优","slug":"性能调优","date":"2020-11-25T06:33:52.000Z","updated":"2020-11-25T08:12:15.156Z","comments":true,"path":"2020/11/25/性能调优/","link":"","permalink":"https://www.hessentec.top/2020/11/25/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/","excerpt":"","text":"CPU为了支持更多的内存支持，CPU必须是64位来支持64位操作系统。 OLTP 用户操作并发量大 事务处理的时间比较短 查询语句简单，走索引 复杂查询少 OLTP对CPU要求不是很高，但是并发量高，是IO密集型操作。 OLAP 用户操作并发量小 一般只用于查询 查询语句复杂，需要优化分析，比较、排序、连接等耗费CPU 复杂查询多，耗费时间长 OLAP对CPU要求较高，是CPU密集型操作。 从InnoDB存储引擎的设计架构上来看，主要后台操作都是在一个单独的master thread中完成的，因此并不能更好的支持多核应用。InnoDB1.2支持多个purge线程，以及将刷新操作从master thread中分离出来。虽然一条SQL查询语句只能在一个CPU总工作，但是可以有效的提升大并发量的请求处理。 可以通过修改以下两个参数来增加IO线程。innodb_read_io_threadsinnodb_write_io_threads 内存内存的大小直接反映了数据库的性能（InnoDB缓存数据、索引都缓存在内存中时性能最优。）通常InnoDB存储引擎的缓冲池的命中率不应该小雨99%。 1show global status like &#39;innodb%read%&#39;; innodb_buffer_pool_reads: 表示从物理磁盘读取页的次数；innodb_buffer_pool_read_ahead: 表示预读的次数；innodb_buffer_pool_read_ahead_evicted: 预读的页，但是没有被读取就从缓冲池中被替换的页的数量，一般用来判断预读的效率；innodb_buffer_pool_read_requests: 从缓冲池中读取页的次数；innodb_data_read: 总共读入的字节数；innodb_data_reads: 总共读取请求的次数，每次读取可能需要读取多个页； 缓冲池命中率 = (innodb_buffer_pool_read_requests) / (innodb_buffer_pool_read_requests + innodb_buffer_pool_read_ahead + innodb_buffer_pool_reads); 平均每次读取字节数 = innodb_data_read / innodb_data_reads; 当缓冲池的大小已经大于数据库文件的大小时，磁盘操作依旧会进行。数据库的缓冲池只是用来存放热点的区域， 后台线程还负责将脏页异步写入到磁盘。每次事务提交还要将日志写入重做日志文件。 磁盘机械硬盘机械硬盘的访问需要耗费长时间的磁头旋转和定位来查找，因此顺序访问的速度远高于随机访问。同时用多块磁盘组成RAID来提高数据库的性能，也将数据分布在不同的硬盘上来达到负载均衡。 固态硬盘基于闪存的固态硬盘，内部由山村组成。企业级应用一般使用固态硬盘，通过并联多块闪存来进一步提高数据传输的吞吐量。固态硬盘没有传统的机械磁盘的读写磁头，不需要耗费大量的时间用于磁盘旋转和定位来查找数据，所以固态硬盘可以提供一致的随机访问时间。 闪存中的数据时不可以更新的，智能通过扇区的覆盖重写。在覆盖重写之前需要执行非常耗时的擦除工作。擦除操作不能再所含数据的扇区上完成，而需要在删除整个被称为擦出块的基础上完成，这个擦除块的尺寸大于山区大小，通常是128KB或者256KB。每个擦除块有擦写次数的限制。 因为有擦除写入的问题，因此需要考虑如何利用齐读取性能，避免过多次的写入操作。 增加 innodb_io_capacity 变量的值达到充分利用固态硬盘带来的高IOPS特性。关闭临接页的刷新，可以可以带来一定效果的提升。 RAIDRAID(Redundant Array of Independent Disks,独立磁盘冗余数组)基本思想是吧多个相对便宜的硬盘组合起来，成为一个磁盘数组，使得性能达到甚至超过一个价格昂贵、容量巨大的硬盘。由于将多个硬盘组合成一个逻辑山区，RAID看起来就像一个单独的硬盘或者逻辑存储单元，因此操作系统会把它当作一个硬盘。 RAID的作用： 增强数据集成度 增强容错功能 增加处理量或者容量 RAID0将多个磁盘并列起来合并成一个大磁盘，存放数据时将数据按照磁盘个数分段，同时将这些数据写入磁盘，不会有冗余，并行IO速度最快，但是没有冗余如果一个磁盘损坏，则所有数据都会丢失。 RAID1两组以上的N个磁盘相互作为镜像，在一些多线程操作系统中能有很好的读取速度，但是写入速度略有降低。除非拥有相同数据的主磁盘与镜像同时损坏，否则只要一个磁盘正常即可用维持运作，可靠性最高，磁盘利用率最低。 RAID5一种存储性能、数据安全和存储成本兼顾的解决方案。是一种硬盘分区技术，RAID5至少需要三个硬盘，RAID5部队存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成？RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储与不同的磁盘上。 RAID10RAID1和RAID0的组合体 RAID50RAID5和RAID0的组合体 操作系统LinuxFreeBSD Windows操作系统下，表名不区分大小写；Linux操作系统大小写敏感。 测试工具sysbench模块化的，跨平台的多线程基准测试工具，用于测试各种不同系统参数下的数据库负载情况。 CPU性能 磁盘IO性能 调度程序性能 内存分配以及传输速度 POSIX线程性能 数据库OLTP基准测试 tpcc-mysql开源的TPC-C测试工具，遵循tpcc标准。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"备份与恢复","slug":"备份与恢复","date":"2020-11-24T10:12:38.000Z","updated":"2020-11-25T05:59:24.516Z","comments":true,"path":"2020/11/24/备份与恢复/","link":"","permalink":"https://www.hessentec.top/2020/11/24/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","excerpt":"","text":"","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"Mysql事务","slug":"Mysql事务","date":"2020-11-10T10:47:29.000Z","updated":"2020-11-24T10:14:12.915Z","comments":true,"path":"2020/11/10/Mysql事务/","link":"","permalink":"https://www.hessentec.top/2020/11/10/Mysql%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存，要么所有修改都不保存。 特性InnoDB存储引擎中的事务完全符合ACID的特性（A：Atomic，C：Consistency，I：Isolation，D：Durability）。 原子性数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL执行失败，已经执行成功的SQL也必须撤销，数据库状态应该退回到执行事务前的状态。 一致性事务将数据库从一种状态变更为另一种一致的状态。在事务开始前和事务结束后，数据库的完整性约束没有被破坏。事务是一致性的单位，如果事务中某个动作失败了，系统可以自动撤销事务，返回初始化的状态。 隔离性每个读写事务的对象对其他事务的操作对象能相互分离，该事务提交前对其他事务都不可见，通常使用锁来实现。 数据库系统中都提供了一种粒度锁的策略，允许事务仅锁住一个实体对象的子集，来提高事务之间的并发性。 持久性事务一旦提交，其结果就是永久性的。即使当数据库崩溃需要恢复时，也能保证恢复后提交的数据都不会丢失 分类扁平事务事务类型中最简单，生产环境中使用最为频繁的一种事务类型。在扁平事务中，所有操作都处于同一层次，其由Begin Work开始，有Commit Work或者Rollback work结束，其间操作是原子的，要么都执行，要么都回滚。扁平事务是应用程序成为原子操作的基本组成模块。 缺点：不能提交或者回滚事务的某一部分，或者分几个步骤提交。 带有保存点的扁平事务除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。 这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合要求，开销也太大。保存点用来通知系统应该记住事务的当前状态，以便当之后发生错误时，事务能回到保存点当时的状态。 缺点：当系统发生崩溃时，所有的保存点都将消失。因为其保存点事易失的，而非持久的。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。 链事务保存点模式的一个变种。在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。其中，提交事务操作和开始下一个事务操作将合并为一个原子操作。下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。 链式事务与带有保存点的扁平事务不同的是，带有保存点的扁平事务能回滚到任意正确的保存点。链式事务中的回滚仅限于当前事务，即智能恢复到最近一个的保存点。对于锁的处理，两者也不相同。链式事务在执行commit后就释放了当前事务所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。 嵌套事务一个层次结构框架，由一个顶层事务控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务，其控制每一个局部的变换。 1）嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务2）处在叶子结点的事务是扁平事务。但是每个子事务从根到叶子结点的距离是可以不同的。3）位于根结点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为父事务，事务的下一层称为子事务。4）子事务既可以提交也可以回滚，但是提交操作并不马上生效，除非其父事务应提交。任何子事务都在顶层事务提交后才真正的提交。5) 树中任意一个事务的回滚回引起它所有子事务一同回滚，子事务仅保留ACI的特性，不具有D的特性。 在Moss理论中，所有的工作都是由叶子结点来完成的，只有叶子结点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责逻辑控制，解决何时调用相关的子事务。 即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务。 分布式事务在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同结点。 InnoDB存储引擎支持扁平事务、带有保存结点的扁平事务、链事务、分布式事务。并不原生支持嵌套事务。 实现事务的隔离性由锁来实现。原子性、一致性、持久性通过数据库的redo log和undo log来完成。redolog 用来保证事务的原子性和持久性。undolog 用来保证事务的一致性。 redoRedo 用来实现事务的持久性，是InnoDB存储引擎用来记录对于每个页的修改，它在事务的进行中不断的被写入。由于是物理操作日志，每个事务对应多个日志条目。并且事务的重做日志是并发写入的，因此在文件中记录的顺序并不是事务的顺序。 其由两部分组成：1）易失的内存中的重做日志缓冲 redo log buffer2）持久的重做日志文件 redo log file InnoDB存储引擎通过Force Log At Commit机制实现事务的持久性，事务提交时必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的commit操作完成才完成。redo log都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。 为了确保每次日志都写入redo log file，在每次重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作，由于重做日志文件打开并没有使用O_DIRECT选项，因此重做日志缓冲先写入文件系统缓存。为了确保重做日志写入磁盘，必须进行一次fsync操作。由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交（数据库）的性能。 InnoDB存储引擎允许用户手工设置非持久的情况发生来提高数据库的性能。当事务提交时，日志不写入重做文件，等待一个时间周期后再执行fsync操作。但是当数据库发生宕机时，由于部分日志未刷新到磁盘，因此回丢失最后一段时间的事务。 innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。默认值为1，表示事务提交时必须调用一次fsync操作。值为0:表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，master thread每秒都会进行一次重做日志文件的fsync操作。值为2:表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。当Mysql宕机时并不会发生丢失，但是操作系统宕机时，重起数据库后回丢失未从文件系统缓存刷新到重做日志文件的那部分事务。 日志块在InnoDB存储引擎中，重做日志缓存、重做日志文件都是按照512字节大小的块来进行保存的。如果一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储。此外由于重做日志块的大小和磁盘扇区大小一样都是512个字节，因此重做日志的写入可以保证原子性，不需要doublewrite技术。 重做日志块结构日志块头共占用12个字节， 名称 占用字节数 说明 LOG_BLOCK_HDR_NO 4 log buffer 由log block组成，在内部log buffer就像一个数组，log_block_hdr_no来标记这个数据中的位置，它是递增并且循环使用的，占用四个字节。第一位用来判断是否是flush bit，最大的值为2G。 LOG_BLOCK_HDR_DATA_LEN 2 表示log block锁占用的大小。当log block被写满时，该值为0x200，表示使用全部log block空间，也就是占用512字节。 LOG_BLOCK_FIRST_REC_GROUP 2 占用两个字节，表示logblock中第一个日志所在的偏移量，如果该值的大小和log_block_hdr_len相同，表示当前logblock 不包含新的日志。 LOG_BLOCK_CHECKPOINT_NO 4 表示logblock 最后被写入时的检查点的值。 日志内容日志块内容可以占用512 - 12 - 8 = 492个字节。 日志块尾共占用8个字节，共有一部分组成，他的值和log_block_hdr_no相同，并在log_block_init中被初始化。 重做日志组重做日志组中有多个重做日志文件。InnoDB存储引擎只有一个log group。它是一个逻辑上的概念，并没有实际存储的物理文件来表示log group信息。log group是由多个重做日志文件组成的，每个log group中的日志文件大小是相同的。 重做日志文件中存储的是log buffer中保存的log block，因此它也是根据快的方式进行物理存储的管理，每个块的大小与log block一样都是512个字节。在InnoDB存储引擎中，log buffer根据一定的规则将内存中的 log block刷新到磁盘。 事务提交时 log buffer中有一般的内存空间已经被使用时 log checkpoint时 对于log block的写入追加在redo log file 的最后部分，当一个redo log file 被写满时，回接着写入下一个redo log file， 其使用方式是round-robin. 对于log group中的第一个redo log file, 其前2KB的部分保存4个512字节大小的块，存放的内容是： 名称 大小 log file header 512 checkpoint1 512 空 512 checkpoint2 512 对于log group的其他 redo log file ,仅保留这些空间，但不保存这些信息。 redo log file的写入并不是完全顺序的，因为除了log block的写入操作，还需要更新前2KB部分的信息，这些信息对于InnoDB存储引擎的恢复非常重要。 在log file header 后面的部分为InnoDB存储引擎保存的check point值，其设计是交替写入，这样的设计避免了因介质失败而导致无法找到可用的checkpoint情况。 重做日志格式不同的数据库操作会有丢赢的重做日志格式，由于InnoDB存储引擎的存储管理是基于页的，因此重做日志格式也是基于页的。 通用的头部格式 redo_log_type space page_no redo log body 重做日志类型 表空间ID 页偏移量 日志不同，存储内容不同 LSNLog Sequence Number代表日志序列号，在INnoDB存储引擎中，LSN占用8个字节，并且单调递增。它的含义是： 重做日志写入总量，表示事务写入重做日志的总量，单位是字节。 checkpoint 的位置 页的版本，在每个页头部的fil_page_lsn记录了该页的LSN值，表示LSN最后刷新时的大小。用来判断该页是否需要进行恢复操作。如，页P1的LSN为10000， 而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已经提交，那么数据库需要进行恢复操作，将重做日志应用到P1中。对于重做日志中LSN小于P1页的LSN，不需要进行重做，表示已经被刷新到该位置。 恢复InnoDB存储引擎在启动时不管上次数据哭运行时是否正常关闭，都会尝试进行恢复操作，因为重做日志记录的是物理日志，因此恢复的速度比逻辑日志要快很多。同时InnoDB存储引擎自身对恢复做了优化，如顺序读取和并行应用重做日志，这样可以进一步提高数据库恢复的速度。 由于checkpoint表示应刷新到磁盘页上的LSN，因此恢复过程中仅需要恢复检查点开始的日志部分即可。 12create table t(a int, b int, primary key(a), key(b));insert into t select 1,2; 对于INSERT操作，其记录的是每个页上的变化。由于需要对聚集索引页和辅助索引页进行操作，其记录的重做日志大致为：Page(2,3), offset 32, value 1,2#聚集索引Page(2,4), offset 64, value 2 #辅助索引 如果插入操作涉及到B+树的分裂，则更多的页需要记录日志。此外，重做日志是物理日志，因此其是幂等的。 undo在数据库进行修改时，为了防止突然宕机导致最近提交的事务丢失，需要redo log进行恢复。如果需要对当前事务进行回滚，需要undo log来支持。 redo存放在重做日志中， undo 存放在数据库内部的一个特殊段中，这个段称为undo 段（undo segment）。undo 段位于共享表空间内。 undo 是逻辑日志，只是将数据库逻辑地恢复到原来的样子。例如：执行一个INSERT 10万条记录的事务，这个事务会导致分配一个新的段（导致表空间增大）。在执行RollBack时，会将插入的事务进行回滚，但是表空间的大小并不会因此收缩。当InnoDB存储引擎回滚时，它实际上做的事与先前相反的工作。对于每个INSERT，InnoDB存储引擎会完成一个DELETE；对于每个DELETE，InnoDB存储引擎会完成一个INSERT；对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE。 除了回滚操作，undo的另一个作用是mvcc（多版本并发控制），在InnoDB存储引擎中mvcc的实现是通过undo来完成的。当用户读取一行记录时，如果该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。 undo log也需要持久性的保护，所以undo log 也会产生redo log。 undo存储管理InnoDB存储引擎对undo的管理采用段的方式。InnoDB存储和引擎有rollback segment，每个回滚段中记录了1024 个undo log segment，在每个undo log segment段中进行undo 页的申请。从1.1开始InnoDB支持最大128个rollback segment，故其支持同时在线的事务限制为128 * 1024个。这些所有的rollback segment都存储在共享表空间中。 innodb_undo_directory: 用于设置rollback segment 文件所在的路径，默认为“.”表示当前InnoDB存储引擎的目录。可以设置为共享表空间以外的位置。 innodb_undo_logs：设置rollback segment的个数，默认值为128. innodb_undo_tablespaces：设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。该参数设置后，可以在innodb_undo_directory看到undo前缀的文件，该文件代表rollback segment文件。undo log segment分配页写入undo log 的这个过程同样需要写入redo log日志。当事务提交时，InnoDB存储引擎做两件事情：1）将undo log放入列表中，供以后的purge使用。2）判断undo log所在的页是否可以重用，如果可以则分配给下一个事务使用。 事务提交以后并不能马上删除undo log以及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。因此事务提交时将undo log放入一个链表中，然后判断undo页的使用空间是否小于3/4，如果小于3/4则表示该undo页可以被重用，之后新的undo log记录在当前undo log后面。由于存放undo log 的里诶包是以记录进行组织的，而undo 页可能存放着不同事务的undo log，是否可以最终删除undo log以及undolog所在的页由purge线程来判断。purge操作需要涉及磁盘的离散读取操作，是一个比较缓慢的过程。 undo log 格式在InnoDB存储引擎中，undo log分为： insert undo log / update undo log. Insert undo log 是指在Insert 操作中产生的undo log，因为Insert操作的记录只对事务本身可见，对其他事务部可见，因此该undo log 可以在事务提交后直接删除，不需要等待purge操作。 *：表示对存储的字段进行压缩。 next: 记录下一个undo log 的位置，通过该值的字节可以知道一个undo log所占用的空间字节数。start：占用2个字节，记录的是undo log 的开始位置。type_cmp1:占用1个字节，记录的是undo 的类型，对于insert undo log,值总是11。undo_no：记录事务的IDtable_id:记录undo log所对应的表对象。接下来记录所有主键的列和值。在进行rollBack操作室，根据这些纸可以定位到具体的记录，然后进行删除。 update undo log 记录的是对delete和update操作产生的undo log。该undo log 可以能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undolog 链表中，等待purge线程进行最后的删除操作。 update undo log相对于之前介绍的 insert undo log, 记录的内容更多，所需要占用的空间也更大。 type_cmpl: 12 TRX_UNDO_UPD_EXIST_REC更新non-delete-mark的记录。 13 TRX_UNDO_UPD_DEL_REC将delete的记录标记为not delete 14 TRX_UNDO_DEL_MARK_REC将记录标记为delete update_vector表示update操作导致发生改变的列。每个修改的列信息都要记录到undo log中。对于不同的undo log类型，可能还需要记录对索引列所做的修改。 查看undo信息查看rollback segment 1DESC INNODB_TRX_ROLLBACK_SEGMENT 查看rollback segment所在的页 1select segment_id, space, page_no from innodb_trx_rollback_segment; 查看事务所对应的undolog 1select * from information_schema.INNODB_TRX_UNDO; 通过segment_id 查看当前rollback segment信息 1select segment_id, insert_undo_list, insert_undo_cached from information_schema.innodb_trx_rollback_segment where segment_id &#x3D; 2; delete操作并不直接删除记录，而只是将记录的delete flag标记为1表示已删除，而记录最终的删除是在purge操作中完成的。 update 主键的操作分为两部完成，首先将原主键记录标记为已删除，因此需要产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log， 之后插入一条新的记录，因此需要产生一个类型为TRX_UNDO_INSERT_RED的undo log。 purgedelete和update的操作可能并不直接删除原有的数据。 1delete from t where a &#x3D; 1; 表t上列a有聚集索引，列b上有辅助索引。对于上述的delete操作仅仅是将主键列等于1的记录delete flag设置为1， 记录并没有被真正的删除还存在于B+树中。 其次对于辅助索引上a=1，b=1的记录同样没有做任何处理，甚至都没有产生undo log。真正删除这行记录的操作被放到了purge操作中。是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事务可能正在引用这行，因此InnoDB 存储引擎需要保存记录之前的版本。是否可以删除需要通过purge来判断。如果这行已经不被任何其他事务引用，那么就可以进行真正的delete操作。 一个页上有多个undo log存在，虽然不代表事务在全局过程中的提交顺序，但是后面的事务产生的undo log总在最后。此外InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行链接。在InnoDB存储引擎的设计中，先提交的事务总在尾端。undo page存放了undo log，由于可以重用，因此一个undo page中可能存放了多个不同事务的undo log。 trx5的灰色阴影表示该undo log还没有被其他事务引用。 在执行purge的过程中，InnoDB存储引擎先从history list中找到第一个需要被清理的记录，trx1， 清理之后InnhoDB存储引擎会在trx1的undo log所在的页中继续寻找是否存在可以被清理的记录。会继续找到trx3， trx5但是发现trx5倍其他事务所引用而不能清理，因此再去history list中国呢查找，发现最尾端的记录trx2，找到trx2所在的页，然后依次吧事务trx6，trx4的记录进行清理。 由于undo page2中的所有页都被清理，因此undo page2可以被重用。 InnoDB存储引擎这种先从historylist中照undo log，然后再从undo page中查找undo log的设计避免了大量的随机读取操作，从而提高了purge的效率。 全局动态参数innodb_purge_batch_size用来设置每次purge操作需要清理的undopage数量。值设置的越大，每次回收的undo page就越多，可供重用的undo page就越多，减少了磁盘存储空间与分配的开销。但是当之设置的太大，每次需要purge处理更多的undo page，从而导致cpu和磁盘IO过于集中与对undo log的处理，使得性能下降。 当InnoDB的存储引擎压力非常大时，并不能高效地进行purge操作。那么history list的长度会变得越来越长。 全局动态参数innodb_max_purge_lag控制history list的长度，0: 默认值，不对history list 做任何限制。大于0时，延缓每一行的DML操作。 全局动态参数innodb_max_purge_lag_delay: 用来控制delay的最大号描述。将innodb_max_purge_lag计算出的值大于当前参数值是，将delay设置为innodb_max_purge_lag_delay, 避免由于purge操作缓慢导致其他SQL线程出现无限制的等待。 group commit如果事务为非只读事务，每次事务提交时需要进行一次fsync操作，以此保证重做日志都已经写入磁盘。当数据库发生宕机时，可以通过重做日志进行恢复。为了提高fsync的效率，数据库都提供了groupcommit功能，一次fsync可以刷新确保多个事务日志被写入文件。对于InnoDB存储引擎来说，事务提交时会进行两个阶段的操作： 1）修改内存中事务对应的信息，并且将日志写入重做日志缓冲。2）调用fsync将确保日志都从重做日志缓冲写入磁盘。（将多个事务的重做日志通过一次fsync刷新到磁盘，这样大大的减轻了磁盘的压力，从而提高了数据库的整体性能。对于写入或者更新较为频繁的操作，group commit的效果尤为明显） 在InnoDB1.2版本之前，在开启二进制日志后，InnoDB存储引擎的group Commit都会失效，从而导致性能的下降。在线环境多使用replication环境，因此二进制日志的选项基本都为开启状态，因此该问题尤为显著。导致这个问题的原因是在开启二进制日志后， 为了保证存储引擎层中的事务和二进制日志的一致性，二者之间使用了两阶段事务，其步骤如下。1）当事务提交时InnoDB存储引擎进行prepare操作。2）MySQL数据库上层写入二进制日志(一旦该步骤完成，即使后续发生宕机，也能保证事务的提交)3）InnoDB存储引擎层将日志写入重做日志文件 a) 修改内存中事务对应的信息，并且将日志写入重做日志缓冲。 b) 调用fsync将确保日志都从重做日志缓冲写入磁盘。每个步骤都需要进行一次fsync才能保证上下两层的数据一致性。步骤2的fsync由参数sync_binlog控制， 步骤3的fsync由陈安叔innodb_flush_log_at_trx_commit控制。 为了保证MYSQL数据库上层二进制日志的写入顺序和InnoDB层的事务提交顺序一致，MySQL数据库内部使用了prepare_commit_mutex串行锁。启用锁后3.a步骤不可以在其他事务执行步骤3.b时进行，从而导致了group commit失效。 在Mysql5.6之后，采用了Binary Log Group Commit的方式，不但上层写入的二进制日志时group commit的， InnoDB存储引擎也是group commit的，并且移除了prepare_commit_mutex. BLGC在Mysql数据库上层进行提交时首先按照顺序将其放入一个队列中，队列中的第一个事务称为leader， 其他事务称为follower， leader控制这follower的行为。 BLGC分为三个阶段： Flush 阶段，将每个事务的二进制日志写入内存中。 Sync 阶段，将内存中的二进制日志刷新到磁盘，如果队列中有多个事务，那么仅一次fsync操作就完成了二进制日志的写入。 Commit 阶段，leader 根据顺序调用存储引擎层事务的提交，InnoDB存储引擎本身就支持groupcommit， 因此修复了原先由于锁prepare_commit_mutex导致的group commit 失效的问题。 当有一组事务进行Commit操作时，其他新事务可以进行Flush阶段的操作，从而使GroupCommit不断生效。binlog_max_flush_queue_time用来控制Flush阶段中等待的时间，即使之前的额一组事务完成提交，当前一组的事务也不会马上进入Sync阶段，而是进行等待。这样做的好处是groupCommit的数量更多。但是会导致事务的响应时间变慢。 事务控制语句 START TRANSACTION ｜ BEGIN : 开启事务； COMMIT：提交事务； ROLLBACK：回滚事务； SAVEPOINT identifier： savepoint 允许在事务中创建一个保存点，一个事务中可以有多个savepoint； RELEASE SAVEPOINT identifier：删除一个事务的保存点，当钱保存点不存在时抛出异常； ROLLBACK TO 【savepoint】identifier：与savepoint一起使用，可以把事务回滚到标记点，而不回滚在标记点之前的任何工作。（后续还需commit或者rollback才会真正的完成事务） SET TRANSACTION：设置事务的隔离级别。 隐式提交的SQL语句执行完这些操作后，都会产生一个隐式的提交操作。alter database。。。 upgrade data directory name;alter event ;alter procedure;alter table;alter view;create database;create event;create index;create procedure;create table;create trigger;create view;drop database;drop event;drop index;drop procedure;drop table;drop trigger;drop view;rename table;truncate table; 用来隐式地修改MySQL架构的操作：create user;drop user;grant;rename user;revoke;set password; 管理语句：analyze table;cache index;check table;load index into cache;optimize table;repair table; 事务的隔离级别 READ UNCOMMITTED READ COMMITTED REPEATABLE READ SERIALIZABLE 123SET 【GLOBAL|SESSION】 TRASACTION | SOLATION LEVEL &#123; READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIABLE&#125; [mysqld] 1transaction-isolation&#x3D;READ-COMMITTED 12select @@tx_isolation;&#x2F;&#x2F;查看当前会话的事务隔离级别select @@global.tx_isolation; &#x2F;&#x2F;查看全局事务隔离级别 InnoDB默认隔离级别为 REPEATABLE READ，使用Next-Key Lock 锁算法， 避免了幻读的产生，因此在改隔离级别下久已经能保证事务隔离性的要求，达到标准SQL的SERIALIZABLE的隔离级别。隔离级别越低，事务请求的锁越少或者保持锁的时间就越短。 在SERIALIABLE隔离级别， INNODB会对每个SELECT语句后自动加上 lock in share mode的共享锁。 因此在这个隔离级别下，读占用了锁， 对一致性的非锁定读就不再予以支持。Serialiable隔离级别一般用在分布式事务上。 ##分布式事务 InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务是多个独立的事务资源参与到一个全局的事务中。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。 XA事务由一个或者多个资源管理器、一个事务管理器以及一个应用程序组成。 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。 事务管理器：协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信。 应用程序：定义事务的边界，指定全局事务中的操作。 不好的事务习惯 在循环中提交事务（每次提交都会写一次 redo log，导致性能变慢） 使用自动提交 使用自动回滚长事务","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"Mysql锁","slug":"Mysql锁","date":"2020-11-09T12:56:08.000Z","updated":"2020-11-11T02:49:24.949Z","comments":true,"path":"2020/11/09/Mysql锁/","link":"","permalink":"https://www.hessentec.top/2020/11/09/Mysql%E9%94%81/","excerpt":"","text":"锁InnoDB存储引擎锁的实现提供了一致性的非锁定读、行级锁支持。行级锁没有相关的额外开销，并可以同时得到并发性和一致性。 LOCK与LATCHLatch轻量级的锁，因为其要求锁定的时间必须非常短，如果持续的时间长，则应用的性能会非常差。InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁），目的就是用来保证并发线程操作临界资源的正确性，通常没有死锁检测机制。 LOCKLock对象是事务，用来锁定数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放（不同的隔离级别释放时间不同）。lock有死锁机制。 Latch 信息查看1show engine innodb mutex; 名称 说明 count mutext被请求的次数 spin_waits spin lock 的次数，InnoDB存储引擎latch在不能获得锁时首先进行自旋，若自旋后还不能获得，则进入等待 spin_rounds 自旋内部循环的总次数，每次自旋的内部循环是一个随机数。spin_rounds/spin_waits 表示平均每次自旋所需要的内部循环次数 os_waits 操作系统等待的次数，当spinlock通过自旋还不能获得latch时，则会进入操作系统等待状态，等待被唤醒 os_yields 进行os_thread_yield唤醒操作的次数 os_wait_times 操作系统等待的时间，单位ms Lock信息查看12show engine innodb status;information_schema 下 innodb_trx、innodb_locks、innodb_lock_waits InnoDB存储引擎中的锁锁类型 共享锁 S Lock, 允许事务读一行数据 排他锁 X Lock, 允许事务删除或者更新一行数据。 InnoDB存储引擎支持多力度锁定，允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，Mysql支持意向锁。 一致性非锁定读一致性非锁定读是InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会u因此去等待行上锁的释放，InnoDB存储引擎会读取行的一个快照数据。快照数据是改行之前的版本数据，通过undo段来完成，undo用来在事务中回滚数据，一次快照数据本身没有额外开销。读取快照数据本身没有额外开销，也不需要上锁。 一个行记录可能有多个快照数据，由此来来的并发控制称为多版本并发控制。在事务隔离级别为READCOMMITED和REPEATABLEREAD下， InnoDB存储引擎使用非锁定一致性读。但是对于快照的定义不同。 在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。 一致性锁定读12select ... for updateselect ... lock in share mode 自增长与锁InnoDB自增长ID的锁机制称为Auto-Inc Locking, 为了提高插入的性能，在完成对自增长值插入的SQL语句后立即释放，而不需要等到事务提交。必须等待前一个插入完成，并且对Inser。。Select的大户巨量的插入会影响插入性能，因为另一个事务中的插入会被阻塞。 轻量级互斥量的自增长实现机制，大大提高了自增长值插入的性能。通过innodb_autoinc_lock_mode来控制自增长的模式。默认值为1. insert-like : 所有的插入语句，insert/replace/insert-select, replace-select, load data. simple-inserts: 插入之前就确定插入行数的语句，如insert/replace。 bulk inserts: 插入前不能确定得到插入行数的语句。 mixed-mode inserts: 插入中有一部分的数据是自增长的， 一部分是确定的。 innodb_autoinc_lock_mode: 0, auto-inc locking 的方式，innodb_autoinc_lock_mode: 1, 默认值， 对于imple inserts, 该值会用互斥量去对内存中的计数器进行累加操作， 对于bulk inserts,使用auto-inc locking 方式，不考虑回滚操作时，对于自增值列的增长是连续的，statement-based方式的replication可以很好的工作。innodb_autoinc_lock_mode: 2, 所有的insert-like自增长的值产生的都是通过互斥量。性能最高。出现的问题是增长的值不连续， 基于statement-based replication 会出现问题。所以在使用当前模式时，任何时候都应该使用 row-based replalication, 这样才能保证最大的并发性能以及replication主从数据的一致。 MyISAM自增主键是表锁设计，自增长不用考虑并发插入的问题， 因此在Master傻姑娘使用InnoDB存储引擎，slave上使用MyISAM存储引擎的replication架构下用户必须考虑这种问题。？？？ 外键和锁InnoDB引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其家一个索引，这样就可以避免表锁。 对于外键值的插入或者更新，首先要查询父表中的记录，如果以一致性非锁定读的方式读取，会发生数据不一致的问题，此时需要对父表加一个S锁。如果这时父表已经有一个X锁，则子表的操作会被阻塞。 锁的算法行锁的三种算法 Record Lock: 单行记录上锁，总是会去锁定索引记录，如果InnoDB存储引擎在建立的时候没有设置任何一个索引，那么InnoDB存储引擎会使用隐式的主键来进行锁定。 Gap Lock: 锁定一个范围，不包含记录本身,为了阻止多个事务将记录插入到同一个范围内。但是又导致Phantom Problem（幻读）问题的产生。 Next-Key Lock: Gap Lock + Record Lock, 锁定一个范围，并锁定记录本身， 解决了Phantom Problem。 当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock锁住索引本身而不是范围。 对于辅助所用，加上的是Next-keyLock， 锁定的是范围，并且还会对下一个键值加上Gap Lock. 显示关闭gap_lock后，除了外键约束和唯一性检查依然需要GapLock，其余情况仅需要使用RecordLock进行锁定。 将事务的隔离级别设置为READ COMMITTED 设置innodb_locks_unsafe_for_binlog=1 解决Phantom Problem默认的可重复读的事务隔离级别下，InnoDB存储引擎采用Next-Key Locking机制来避免幻读。在ReadCommited模式下，仅采用RecordLock来加锁。 锁问题通过所及之可以实现事务的隔离性要求，使得事务可以并发地工作。脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交的数据。 脏读在不同的事务下，当前事务可以读到另外事务未提交的数据（脏数据）。 不可重复读在一个事务内，多次读取同一数据集合，由于当前事务看到了另外的事务提交的数据，两次返回的数据是不一样的。InnoDB存储引擎中，使用Next-Key Lock算法来避免不可重复读的问题（不可重复读也叫幻读）。 丢失更新一个事务的更新操作会被另一个事务的更新成操作覆盖。 阻塞因为不同锁止键的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁匙放它所占用的资源，就是阻塞，阻塞时为了确保事务可以并发且正常地运行。 innodb_lock_wait_timeout: 等待超时时间innodb_rollback_on_timeout: 等待超时时是否对进行中的事务进行回滚。默认为OFF，默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。。 1SET @@innodb_lock_wait_timeout&#x3D;60; 死锁概念两个或者两情歌以上的事务在执行过程中，因为争夺锁资源而造成相互等待的现象。 超时解决解决思索最简单的方式是不要有等待，将任何的等待都化为回滚，并且事务重新开始。如果超时的事务更新了很多行，占用了较多的undo log会导致回滚性能差。 死锁检测采用 wait-for graph（等待图）的方式进行死锁检测。要求数据库保存两种信息，通过这两种信息构造一张图，如果图中有回路，就代表存在死锁，从而选择回滚undo量最小的事务。 锁的信息链表 事务等待链表 锁升级锁升级是指将所得粒度降低。InnoDB存储引擎不存在锁升级的问题。因为不是根据每个记录来产生行锁，而是根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。因此不管是一个事务锁住页中一个记录还是多个记录，开销通常是一样。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"ThreadLocal","slug":"ThreadLocal","date":"2020-11-06T13:43:22.000Z","updated":"2020-11-06T14:25:14.572Z","comments":true,"path":"2020/11/06/ThreadLocal/","link":"","permalink":"https://www.hessentec.top/2020/11/06/ThreadLocal/","excerpt":"","text":"简介 ThreadLocal 是JDK包提供的，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的副本，在实际多线程操作的时候，操作的都是自己本地内存中的变量，从而规避了线程安全问题。 使用12345ThreadLocal tl = new ThreadLocal();tl.set(k);tl.get();tl.remove(); 12345678910111213141516public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; Thread.java 123456789/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;/* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 实现原理Thread 类中有两个变量，一个threadLocals， 一个inheritableThreadLocals。 不支持继承性InheritableThreadLocal内存泄漏问题","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java","slug":"Java技术栈/Java","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.hessentec.top/tags/Java/"}]},{"title":"Mysql索引","slug":"Mysql索引","date":"2020-11-06T01:19:34.000Z","updated":"2020-11-09T12:52:00.210Z","comments":true,"path":"2020/11/06/Mysql索引/","link":"","permalink":"https://www.hessentec.top/2020/11/06/Mysql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"InnoDB存储引擎索引InnoDB支持B+树索引、全文索引和哈希索引。 B+树索引就是传统意义上的索引，是目前关系型数据库中查找最为常用和最为有效的索引。InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为敢于是否在一张表中生成哈希索引。 数据结构与算法二分查找法也叫折半查找，必须是一组有序的记录数组。具体详见《二分查找法》。 二叉查找树与平衡二叉树二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值。 前序遍历：根 -&gt; 左 -&gt; 右中序遍历: 左 -&gt; 根 -&gt; 右后序遍历: 左 -&gt; 右 -&gt; 根 当一个二叉查找树的每个结点只有左子树或者只有右子树时，该数据结构退化成了链表，查找性能会变低，时间复杂度变成O(n). 平衡二叉树：在二叉树的基础上，必须满足任何结点的两个子树高度最大差1. 平衡二叉树的查询速度极快，但是维护一颗平衡二叉树的代价非常大。 需要经过1次或者多次左旋和右旋来得到插入或者更新后的平衡树。 B+树B+树由B树和索引顺序访问方法演化而来，为磁盘或者其他直接存取辅助设备设计的一种平衡查找树。在B+树中，所有记录结点都是按照键值的大小顺序存放在同一层的叶子结点上，由各个叶子结点指针进行连接。 B+树的插入B+树的插入必须保证插入后叶子结点中的记录依然排序，同时要考虑插入到B+树的三种情况，每种情况都可能会导致不同的插入算法。 1）叶子页未满，索引页未满：直接将记录插入到叶子结点。2）叶子页已满，索引页未满： 2.1）拆分LeafPage 2.2) 将中间的结点放入到IndexPage中 2.3）小于中间结点的记录放在左边 2.4) 大于或者等于中间结点的记录放在右边3）叶子页已满，索引页已满： 3.1）拆分LeafPage 3.2) 小于中间结点的记录放左边 3.3) 大于或者等于中间结点的记录放右边 3.4) 拆分索引页IndexPage 4.5) 小于中间结点的记录放左边 4.6) 大于中间结点的记录放右边 4.7) 中间结点放入上一层IndexPage 无论如何变化，B+树总会保持平衡。但是为了保持平衡对于新插入的键值可能需要做大量的拆分页操作。因为B+树结构主要用于磁盘，页的拆分意味着磁盘的额操作，所以在可能的情况下尽量减少页的拆分。B+树提供了类似于平衡二叉树的旋转功能。旋转发生在LeafPage已满，但是其左右兄弟结点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录转移到所在页的兄弟结点上。在通常情况下，左兄弟回被首先检查用来做旋转操作。 B+树的删除B+树删除时根据填充因子的变化来衡量（最小填充因子的值为50%）。删除操作同样必须保证删除后叶子结点中的记录已俨然排序。 叶子结点大于填充因子， 中间结点大于填充因子：直接将记录从叶子结点删除，如果该结点还是IndexPage的结点，用该结点的右结点代替。叶子结点小于填充因子，中间结点大于填充因子：合并叶子结点和它的兄弟结点，同时更新IndexPage叶子结点小于填充因子，中间结点小于填充因子：合并叶子结点和它的兄弟结点，更新IndexPage，合并IndexPage和它的兄弟结点。 B+树索引聚集索引按照每张表的主键构造一颗B+树，同时叶子结点中存放的是张张表的行记录数据，聚集索引的叶子结点称为数据页。由于实际的树叶也只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。大多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子结点上直接找到数据。此外定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围的查询。 数据页存放的是完整的每行的数据，索引页存放的是键值和指向数据页的偏移量Offset。聚集索引是按照主键逻辑顺序在磁盘存储。 辅助索引对于辅助索引，叶子结点除了包含键值意外，每个结点中的索引行中包含了聚集索引键。每张表中可以有多个辅助索引，当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历并通过叶子级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。 B+树索引的分裂InnoDB存储引擎的PageHeader中包含了Page_Last_Insert、Page_Direction、Page_N_Direction，通过这几个参数来决定向左分裂或者向右分裂。 如果插入是随机的，则取页的中间记录作为分裂点的记录。如果向同一方向进行插入的记录数量是5，并且目前已经定位到的记录之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是待插入的记录。 B+树索引的管理只对表中b字段的前100个字符创建索引。 1alter table t add key idx_b(b(100)); 查看t表中的所有索引。 1show index from t; 在非高峰时期执行以下语句，更新索引Cardinality信息，使得优化器和索引可以更好的工作。 1analyze table t; 生产环境创建索引时遇到的问题： 临时表方式创建索引先创建临时表，导入数据，创建索引然后修改临时表名称。 Fast Index CreationFIC在辅助索引创建的过程中对表加了S锁，因此在创建的过程中之能对该表进行读操作，如果有大量的食物需要对目标表进行写操作，那么数据库的服务同样不可用。FIC方式只限于辅助索引，对于主键的创建和删除需要重建一张表。 Online Schema ChangePHP脚本维护，且在进行OSC过程中，允许SET sql_bin_log=0， 因此所做的操作不会同步到slave服务器，可能导致主从不一致的情况。 Online DDL允许辅助索引创建的同时，还允许Insert、UPdate、Delete等DML操作，极大地提高了Mysql数据库在生产环境的可用性。还可以在线的操作以下命令： 1234辅助索引的创建与删除改变自增长值添加或者删除外键约束列的重命名 12alter table table_name add index index_name algorithm=&#123;default|INPLACE|COPY&#125;lock=&#123;default|none|shared|exclusive&#125; algorithm: copy: 临时表方式创建索引 inplace:不需要创建临时表（默认） default:根据参数old_alter_table判断通过copy或者inplace算法。lock: 创建索引或者删除索引时对表解锁的情况。 none: 不加锁，任意读写操作都不会收到阻塞。 share: 与FIC类似，执行索引创建或者删除操作时，对目标加S锁。可以并发读，阻塞写事务。 exclusive：执行索引创建或者删除时，对表增加一个X锁，阻塞所有的读写事务。 default：通过判断事物的最大并发性来判断执行DDL模式。none -&gt; share-&gt; exclusive. 远离：在执行创建或者删除操作时，将INsert、UPDATE、DELETE等DML操作日志写入缓冲中，等待索引创建完成后，再将重做应用到表上，达到数据一致性。因此索引在创建过程中SQL优化器不会选择正在创建中的索引。缓存大小由innodb_online_alter_log_max_size=128MB控制。 Cardinality值表示索引中不重复记录数量的预估值。InnoDB根据Cardinality来决定是否使用该索引。Cardinality的值是通过采样的方法来完成的。 当insert、update的数据占有表中数据的1/16时。每一行的更新次数：stat_modified_counter &gt; 2 000 000 000时就会更新Cardinality值。 当执行以下命令时会导致InnoDB存储引擎重新计算Cardinality值： 1234analyze tableshow table statusshow index访问information_schema 下的表tables和表statistics B+树索引的使用不同应用中B+树索引的使用OLTP应用和OLAP应用中索引的使用。 联合索引覆盖索引从辅助索引就可以查询到想要的数据，而不需要再查一次聚集索引中的记录。 优化器选择不使用索引的情况当优化器发现辅助索引不能进行索引覆盖时，并且查找的数据量比较大时会放弃辅助索引，转向全表扫描。 使用force index(); Multi-range Read优化为了减少磁盘的随机访问，并且将随机访问转化为较顺序的数据访问。 MRR的好处： MRR 使得数据访问变得较为顺序，在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。 减少缓冲池中页被替换的次数 批量处理对键值的查询操作 对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR的工作方式如下： 将查询得到的辅助索引键值存放在一个缓存中，这时缓存中的数据时根据辅助索引键值排序的。 将缓存中的键值根据rowID进行排序 根据rowID的排序顺序来访问实际的数据文件。 如果InnoDB或者MyISAM存储引擎的缓冲池不是足够大，不能存放下一张表中的所有数据，此时频繁的离散读操作还是会导致缓存中的页被替换出缓冲池，然后又不断地被读入缓冲池。如果按照住建顺序进行访问，就可以将重复行为降到最低。可以通过optimizer_swith中的flag来控制，当mrr为on时表示启用mrr优化。mrr_cost_based标记表示是否通过cost_based方式选择是否启用mrr。如果mrr = 0n , mrr_cost_based=off , 表示总启用mrr。 SET @@optimizer_switch=’mrr=on,mrr_cost_based=off’; IndexConditionPushDown优化IndexConditionPushDown 会在读取索引的同时，判断是否可以进行WHERE条件的过滤从而提升性能。 HASH算法Hash表InnoDB存储引擎中的哈希算法自适应哈希索引全文检索倒排索引InnoDB全文索引全文检索","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"Mysql表","slug":"Mysql表","date":"2020-11-05T01:19:16.000Z","updated":"2020-11-05T11:50:09.506Z","comments":true,"path":"2020/11/05/Mysql表/","link":"","permalink":"https://www.hessentec.top/2020/11/05/Mysql%E8%A1%A8/","excerpt":"","text":"索引组织表在InnoDB存储索引中，表时根据主键顺序组织存放的，这种存储方式的表称为索引组织表。 在InnoDB存储引擎表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则会按照如下方式创建主键： 判断表中是否有非空的唯一索引，如果有该列为主键； 表中没有非空的唯一索引，InnoDB引擎自动创建一个6字节大小的指针；当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键（根据定义的索引顺序，而不是建表时列的顺序）。 InnoDB逻辑存储结构表空间表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。表空间由段（Segment）、区（extent）、页（Page）组成。 在默认情况下，InnoDB存储引擎有一个共享表空间ibdata1，所有的数据都存放在这个表空间内。如果配置了innodb_file_per_table，则每张表内的数据可以单独存放在一个表空间中。此时每张表的表空间存放的只是数据、索引和插入缓冲的BitMap页，其他类的数据如回滚（undo）、插入缓冲索引页、系统事务信息、二次写缓冲等还是存放在原来的共享表空间。 段表空间是由各个段组成的，包含数据段、索引段、回滚段等。数据段就是B+树的叶子节点，索引段就是B+树的非叶子结点。回滚段？？？在InnoDB存储引擎中，对段的管理都是由引擎自身完成的，DBA不能对其进行控制。 区区是由连续的页组成的空间，在任何情况下每个区的大小都是1MB。为了保证区中页的连续行，InnoDB引擎每次从磁盘申请4～5个区。默认情况下InnoDB存储引擎页的大小为16K，一个区中存放64个连续的页。 页页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中，默认每个页的大小为16KB。可以通过参数 innodb_page_size 来设置页的大小为4K、8K、16K。如果设置完成，则所有表中的页大小都变成innodb_page_size，不可用对其再次进行修改。除非通过mysqldump导入和导出来生成新的库。 页的类型有： 数据页（B-Tree Node） undo 页（undo log Page） 系统页（System Page） 事务数据页（Transaction System Page） 插入缓冲位图页（Insert Buffer BitMap） 插入缓冲空闲列表页（Insert Buffer Free List） 未压缩的二进制大对象页（Uncompressed BLOB Page） 压缩的二进制大对象页（Compressed BLOB Page） 行Innodb存储引擎按行进行存放，每个页存放的行记录有影星的定义，最多允许存放16KB/2 - 200 行的记录。 InnoDB行记录格式Compact 行记录格式从Mysql5.0开始，设计目的是高效地存储数据。一个页中存放的行数据越多，其性能就越高。 |—|—|—|—|—|—|—|—|—|| 变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列 2 数据 | …|事务ID列|回滚指针列|__rowid| 变长字段长度列表：按照列的顺序，逆序放置。 如果列的长度小于255个字节，占用1字节； 如果列的长度大于255个字节，占用2字节； 变长字段的长度最大不可以超过2个字节，因为Mysql数据库中VARCHAR类型的最大长度限制为65535.NULL标志位：表示改行数据中是否有NULL值，有用1表示，占用1个字节。记录头信息：固定占用5个字节。最后的部分是实际存储没咧的数据。事务ID列：隐藏列，占用6字节。回滚指针列:隐藏列，占用7字节。__rowid：占用6字节。 行溢出数据InnoDB存储引擎的数据都是存放在页类型为B-tree Node中，当发生行溢出是，数据存放在页类型为uncompress BLOG页中。 InnoDB数据页结构Named File Formats 机制###约束 数据完整性约束的创建和查找约束和索引的区别对错误数据的约束ENUM和SET约束触发器与约束外键约束视图分区表分区功能不是在存储引擎层面完成的。支持分区的存储引擎有：MyISAM、InnoDB、NDB。不支持分区的存储引擎有：CSV、FEDORATED、MERGE。 分区的过程是将一个表或者索引分解为多个更小的、更可管理的部分。从逻辑上讲只有一个表或者一个索引库，但是在物理上这个表或者索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，页可以作为一个更大的对象的一部分进行处理。 Mysql支持水平分区，不支持垂直分区（水平分区，将同一表中的不同行的记录分配到不同的物理文件；垂直分区，将同一表中的不同列分配到不同的物理文件）。Mysql不支持全局分区，只支持局部分区。局部分区：一个分区中既存放了数据由存放了索引。全局分区：数据存放在各个区，所有数据的索引存放在一个对象中。 分区主要用来数据库高可用性的管理，对于某些SQL的性能带来提高。 分区类型 RANGE分区:行数据基于属于一个给定连续区间的列值被放入分区。1234567create table t ( id int)engine&#x3D;innodbpartition by range(id)( partition p0 values less than (10), partition p1 values less than (20)); 1alter table t add partition (partition p2 values less than maxvalue); 启用分区后，表是由建立各个分区时的各个分区ibd文件组成。 List分区：和RANGE分区类似，只是LIST分区面向的是离散的值。 12345678create table t( a INT, b INT) engine &#x3D; INNODBpartition by list(b)( partition p0 values in (1,3,5,7,9), partition p1 values in (0,2,4,6,8)) HASH分区：根据用户自定义的表达式返回值进行分区，返回值不能为负数。Hash分区的目的是将数据均匀地分布到盂县定义的各个区中，保证各分区的数据数量大致都一样。 123456create table t( a int, b datetime)engine&#x3D;innodbpartition by hash(year(b))partitions 4; 123456create table t( a int, b datetime)engine&#x3D;innodbpartition by linear hash(year(b))prtions 4; LINEAR HASH分区的优点在于，增加、删除、合并和拆分分区将变得更加快捷，有利于处理含有大量数据的表。缺点在于，与使用HASH分区得到的数据分布相比，各个分区间数据的分布可能不大均衡。 KEY分区：根据MYSQL数据库提供的哈希函数来分区。与HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用MYSQL数据库提供的函数进行分区。对于NDB Cluster引擎，MYSQL数据库使用MD5函数来分区；对于其他引擎，Mysql数据库使用内部的哈希函数。在KEY分区中，使用关键字LINEAR 和在HASH分区中具有同样的效果。 无论哪种类型的分区，如果表中存在主键或者唯一索引时，分区列必须时唯一索引的一个组成部分。如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。 以上四种RANGE、LIST、HASH、KEY分区条件是，数据必须是整形，如果不是整型，那应该需要通过函数将其转化成整型，如YEAR（）, TO_DAYS(), MONTH()等函数。 Column分区，RANGE分区和LIST分区的一种进化。COLUMN分区可以直接使用菲整形的数据进行分区，分区根据类型直接比较得到，不需要转化为整形。RANGECOLUMNS分区可以对多个列的值进行分区。 COLUMN分区支持所有的整型：INT、SMALLINT、TINYINT、BIGING。日期类型：DATE、DATETIME字符串类型：CHAR、VARCHAR、BINARY、VARBINARY。 12345678create table t( a INT, b DATETIME)engine&#x3D;innodbpartition by range columns(b)( partition p0 values less than (&#39;2020-01-01&#39;), partition p1 values less than (&#39;2020-02-01&#39;)) 子分区 子分区是在分区的基础上再进行分区，有时页称为符合分区。 MySQL允许在RANGE和LIST的分区傻姑娘再进行KEY或者HASH的子分区。 1234567891011create table t( a int, b date )engine &#x3D; innodb partition by range(year(b)) subpartition by hash(to_days(b)) subpartitions 2( partition p0 values less than (1990), partition p1 values less than (2000), partition p2 values less than maxvalue ); 分区中的NULL值MysQL允许对NULL值做分区，对于RANGE分区，如果像分区列插入了NULL值，则Mysql数据库将该值放入到最左边的分区。LIST分区下要使用NULL值，必须显式地指出将该值放入哪个分区。HASH和KEY分区函数会将NULL值的记录返回0. 分区和性能当数据量大时，分区可以有效降低B+树的层级。当数据量小时，分区带来的收益并不明显，并且有可能导致扫描所有分区反而降低效率。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"MySQL 文件","slug":"文件","date":"2020-11-04T02:55:42.000Z","updated":"2020-11-04T10:16:43.150Z","comments":true,"path":"2020/11/04/文件/","link":"","permalink":"https://www.hessentec.top/2020/11/04/%E6%96%87%E4%BB%B6/","excerpt":"","text":"参数文件动态参数 动态参数可以在Mysql实例运行中进行更改，可以通过SET命令对动态参数值进行修改。 SET [global|session] key = value; 静态参数 静态参数在整个实例生命周期内不得进行更改，需要重新启动实例才会生效。 日志文件错误日志记录了对Mysql的启动、运行、关闭过程中所有的错误、警告和正确的信息。 慢查询日志可以帮助定位可能存在问题的SQL语句，从而进行SQL层面的优化。Mysql在启动时设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。通过设置 long_query_time 来设置，单位为秒。log_queries_not_using_indexes: 记录没有使用索引的查询日志。log_throttle_queries_not_using_indexes:每分钟允许记录到showLog的且未使用索引的SQL语句次数，0表示不限制。 查看慢日志 123mysqldumpslow *.log&#x2F;&#x2F;查看执行时间最长的10条sql语句mysqldumpslow -s al -n 10 *.log 查询日志查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。 查看查询日志： 1tail *.log 二进制日志二进制日志记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类对数据本身没有修改的操作。二进制日志还包括了执行数据库更改操作的时间等其他额外信息。 作用 恢复某些数据的恢复需要二进制日志，如在一个数据库全备文件恢复后，用户可以通过二进制日志进行pint-in-time的恢复。 复制与恢复类似，通过复制和执行二进制日志使另一台远程的MySQL数据库与当前数据库进行实时同步。 审计通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。 配置 max_binlog_size: 单个日志文件的最大值，默认1G binlog_cache_size: 所有未提交的二进制日志会被记录到一个缓存中，等该事务提交时直接将缓冲中的二进制日志写入二进制日志文件，该缓冲的大小默认为32。该值是基于会话的，每个会话会申请32K的空间。 binlog_cache_use: 记录了使用临时文件写二进制日志的次数。 sync_binlog：表示每写缓冲多少次就同步到磁盘，为1时，表示采用同步写磁盘的方式来写二进制日志，这时写操作不使用操作系统的缓冲来写二进制日志。默认值为0. binlog-do-db：写入哪些库的日志，默认为空表示同步所有库的日志到二进制日志。 binlog-ignore-db：忽略哪些库的日志 log-slave-update：当前库为slave时，如果需要将从master取得并执行的二进制日志写入自己的二进制日志文件中时需要设置该值。 binlog_format：STATEMENT/ROW/MIXEDSTATEMENT：格式基于SQL语句，如果主服务器运行rand、uuid等函数或者触发器等操作时，就会导致主从服务器上表中的数据库表中的数据库不一致。ROW：二进制的日志，记录了表的更改情况，解决了Statement下复制的问题。可以设置InnoDB的事务隔离设置为READ_COMMITTED，以获得更好的并发性。MIXED：默认采用STATEMENT，但是在特殊情况下会转为ROW。 套接字文件名为mysql.sock,可以通过Unix域套接字方式进行与本地MySQL进行连接。套接字文件由参数socket控制。 PID文件MySQL实例启动时，会将自己的进程ID写入一个文件中，该文件为PID文件。 表结构定义文件因为MySQL插件式存储引擎的体系结构关系，MySQL数据的存储是根据表进行的，每个表都会有与之对应的文件。但不论表采用哪种存储引擎，MySQL都有一个以frm为后缀名的文件，记录了这个表结构或者视图的定义。 Innodb存储引擎文件表空间文件InnoDB采用将存储的数据按照表空间进行存放的设计。默认配置喜爱会有一个初始大小为10MB，名为ibdata1的默认表空间文件。 将ibdata1,ibdata2两个文件用来组成表空间。 1innodb_data_file_path&#x3D;&#x2F;db&#x2F;ibdata1:2000M;&#x2F;dr2&#x2F;db&#x2F;ibdata2:2000M:autoextend 如果该两个文件位于不同的磁盘上，磁盘的负载可能被平均，因此可以提高数据库的整体性能。设置innodb_data_file_path后，所有给予innoDB存储引擎的表的数据都会记录带该共享表空间中。 1innodb_file_per_table&#x3D;ON &#x2F;&#x2F;每个基于InnoDB存储引擎的表产生一个独立表空间。命名规则是：表名.ibd 单独的表空间文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还存放在默认的表空间中。 重做日志文件默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件。他们记录了对于InnoDB存储引擎的事务日志。 重做日志用于由于主机宕机导致实例失败时，恢复到失败前的状态，一次来保证数据的完整性。 每个InnoDB存储引擎至少有1个重做日志文件组，每个文件组下至少有2个重做日志文件。为了得到更高的可靠性，用户可以设置多个的景象日志组。将不同的组存放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎献血重做日志文件1，当达到文件的最后时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1中。 1234innodb_log_file_size:每个重做日志文件的大小innodb_log_files_in_group: 日志文件组中重做日志文件的数量，默认为2innodb_mirrored_log_groups: 日志镜像文件组的数量，默认为1，表示没有镜像。innodb_log_group_home_dir: 日志文件组所在的路径，默认为.&#x2F; 重做日志文件的大小对InnoDB存储性能有非常大的影响。如果设置太大，在恢复时可能需要很长的时间。如果设置太小，会导致一个事务的日志需要多次切换重做日志文件。同时会导致频繁地发生 async checkpoint， 导致性能抖动。 二进制文件与重做日志层次不同：二进制日志：记录所有与MySQL数据库有关的日志记录，包括InnoDB，MyISAM，Heap等其他存储引擎的日志。重做日志：值记录InnoDB存储引擎本身的事务日志。 内容不同：二进制日志文件记录的是一个事务的具体操作内容，为逻辑日志。重做日志记录的是关于每个页的更改的物理情况。 写入时间不同：二进制文件仅在事务提交前进行，无论事务大小，只写磁盘一次。在事务进行的过程后再难过，不断有重做日志条目被写入到重做日志文件中。 重做日志条目结构redo_log_type | space | page_no | redo_log_bodyredo_log_type ： 占用1字节，表示重做日志的类型space： 表示表空间的ID，采用压缩的方式，占用空间可能小于4字节page_no：表示页的偏移量，压缩方式redo_log_body:每个重做日志的数据部分，恢复时需要调用相应函数解析。 重做日志写入重做日志的写入不是直接写，而是先写入重做日志缓冲（redo log buffer）中，然后按照一定的条件顺序地写入日志文件。 从重做日志缓冲网磁盘写入时，按照写入的最小单位（扇区大小：512个字节）进行写入，因此可以保证写入必定是成功的，因此在重做日志的写入过程不需要有doublewrite。 写入时机：1） 不论事务已经提交，主线程每秒都会将重做日志缓冲写入到磁盘的重做日志文件中。2） 事务提交时，设置了innodb_flush_log_at_trx_commit。 值为0时，不将事物的重做日志写入磁盘上的日志文件， 1表示在执行commit时将重做日志缓冲同步写到磁盘， 2表示将重做日志异步写到磁盘（也就是写到文件系统的缓存中） 因此，为了保证ACID中的D（持久性），必须将innodb_flush_log_at_trx_commit设置为1，当数据库因为意外宕机时，可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"InnoDB体系架构","slug":"InnoDB体系架构","date":"2020-11-03T03:40:38.000Z","updated":"2020-11-04T02:55:30.055Z","comments":true,"path":"2020/11/03/InnoDB体系架构/","link":"","permalink":"https://www.hessentec.top/2020/11/03/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/","excerpt":"","text":"InnoDB 体系架构后台线程Master Thread主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页的刷新、合并插入缓冲、UNDO页的会后等。 IO ThreadInnoDB中使用了AIO（AsyncIO）来处理写IO请求，提高了数据库性能。IO线程的工作主要是负责AIO的回调处理。 可以使用innodb_read_io_threads和innodb_write_io_threads进行设置。 Purge Thread事务被提交后，其所用的undolog可能不再需要，因此需要Perge Thread来回收已经使用并分配的undo页。可以使用 innodb_purge_thread 来设置线程数量。 Page Cleaner Thread为了减轻MasterThread的工作，以及用户查询线程的阻塞提升性能。将之前版本中脏页的舒心操作都放入到单独的线程中完成。 内存缓冲池InnoDB存储引擎是基于磁盘存储的，将其中的记录按照页的方式进行管理。缓冲池就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库的性能影响。 在数据库中进行读取页的操作，首先从磁盘读取到的页放在缓冲池中，下一次再读取相同的页时，首先判断该页是否在缓冲池中。如果在缓冲池中，则直接读取该页，否则读取磁盘上的页。 对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。 页从缓冲池刷新到磁盘上的操作是通过Checkpoint的机制刷新回到磁盘。 因此缓冲池的大小直接影响着数据库的整体性能。可以使用 innodb_buffer_pool_size 来设置缓冲池大小。 缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自使用哈希索引、InnoDB存储的锁信息、数据字典信息等。 InnoDB可以有多个缓冲池实例，每个页根据哈希值平均分配到不同的缓冲池实例中。这样减少了数据库内部的资源竞争，增加了数据库的兵法处理能力。可以使用 innodb_buffer_pool_instances来进行配置。 缓冲池管理算法LRU ListLRU List 用来管理已经读取的页，最频繁使用的页存放在LRU列表的前端，最少使用的页存放在LRU列表的尾端。当缓冲池不能存放新读取到的页时，首先释放LRU列表中尾端的页。 新读取的页并不直接存放在LRUList列表的前端，而是存放在midPoint的位置。midPoint之后的列表称为Old列表，之前的列表称为New列表，New列表中的页都是活跃的热点数据。 这是因为，如果新读取的页如果放在最前端时，如果遇到需要访问和扫描大部分甚至全部页的时候，热点页面被刷出缓存，但是非热点数据却存放在了LRU列表的最前端。 使用参数：innodb_old_blocks_pct 来控制midPoint的位置。 innodb_old_blocks_times 来控制读取到MidPoint位置后需要等待多久才会被加入到LRU列表的New列表。 Free List数据库刚启动的时候，LRUList是空的没有任何页。此时页都存放在FreeList中。当需要从缓冲中分页时，县从Free列表中查找是否有可用的空闲页，如果有可用的空闲页，则将该页从FreeList中删除，存放到LRUList中。如果FreeList中没有可用的空闲页，根据LRU算法，淘汰LRU尾部的页，将该页内存空间分配给新的页。 Flush List在LRU列表中的页被修改后，该页需要通过CheckPoint机制刷回磁盘。FlushList中的页称为脏页里诶包，脏页既存在于LRUList，也存在于FlushList。LRUList用来管理缓冲池中页的可用性，FlushList用来管理将页刷新回磁盘。 重做缓冲日志InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按照一定的频率（每秒一次）将其刷新到重做日志文件。可以使用参数：innodb_log_buffer_size来调整该缓冲区域的大小，默认为8MB。 额外的内存池例如：分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象，这些对象记录了一些如LRU、锁、等待信息，而这个对象的内存需要从额外内存池中申请。 在对一些数据结构本身的内存进行分配是，需要从额外的内存池中进行申请。因此在申请了很大的InnoDB缓冲池是，需要相应地增加额外的内存池。 Checkpoint技术 Write Pos 是当前记录的位置，一边写好一遍往后移。CheckPoint 是当前要擦除的位置，也就是往后推移并且循环的，擦除记录前要把记录更新到数据文件。Write Pos和 CheckPoint之间是可以写入的部分，用来记录新的操作。 1） 缩短数据库的恢复时间； 当数据库发生宕机时，数据库不需要重做所有的日志，因为CheckPoint之前的页都已经刷新回磁盘，因此只需要对checkPoint之后的重做日志进行恢复，这样大大缩短了数据库的恢复时间。 2） 缓冲池不够用时，将脏页刷新到磁盘； 当缓冲池不够用时，根据LRU算法会移除最近最少使用的页，如果当前页为脏页，则需要刷新该脏页到磁盘。 3） 重做日志不可用时，刷新脏页； 重做日志中Write Pos和checkPint之间没有空间来记录RedoLog时，强制刷新脏页，使得CheckPoint后移。 InnoDB关键特性插入缓冲Insert Buffer对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果存在则直接插入；如果不在则先放入到一个InsertBuffer对象中。然后再以一定的频率进行InsertBuffer和辅助索引页子结点的Merge操作。通常会将多个插入操作合并到一个操作中，大大提高了非聚集索引插入的性能。 InsertBuffer的使用要同时满足两个条件：1） 索引是辅助索引（非聚集索引） 如果是聚集索引，则直接按照顺序写就行了，很高效。2） 索引不是唯一的 因为在插入缓冲时，数据库并不去查找索引页来判断插入的记录唯一性。如果去查找肯定又会有离散读取的情况发生，从而导致InsertBuffer失去意义。 当满足索引是辅助索引且非唯一时，InnoDB存储引擎会使用InsertBuffer， 这样就可以提高插入操作的性能。 当应用程序进行大量的插入操作时数据库发生了宕机，这个时候会有大量的InsertBuffer并没有合并到实际的非聚集索引中，因此恢复可能需要很长的时间。 同时在写密集的情况下，InsertBuffer会占用过多的缓冲池内存（innodb_buffer_pool），默认最大可以占用1/2的缓冲池内存。修改IBUF_POOL_SIZE_PER_MAX_SIZE 可以对 InsertBuffer大小进行控制，比如改为3则最大只能使用1/3的缓冲池内存。 Change BufferInsertBuffer 的升级版本，可以对Insert、Delete、Update都进行缓冲，分别是InsertBuffer、DeleteBuffer、PurgeBuffer。 ChangeBuffer适用对象依然是非唯一的辅助索引。 对一条记录进行UPDATE操作需要分为：1）将记录标记为删除（DeleteBuffer对应该过程）；2）真正将记录删除（PurgeBuffer对应删除操作） 开启Buffer选项：innodb_change_buffering: [inserts、deletes、purges、changes、all、none]changes表示启用inserts、deletesall表示启用所有，默认值none表示都不启用。 可以通过innodb_change_buffer_max_size控制changebuffer最大使用内存的数量：该参数的最大有效值为50， 表示只能占用缓冲池的50%。 Merge InsertBuffer 辅助索引页被读取到缓冲池时； 执行SELECT语句时，要确认该辅助索引页是否有记录存放于InsertBufferB+树中。 有，则将InsertBufferB+树中该页的记录插入到该辅助索引页中。 InsertBuffer BitMap 追踪到该辅助索引页已无可用空间时； InsertBuffer BitMap用来追踪每个辅助索引页的可用空间，并至少有1/32页的可用空间。如果插入辅助索引记录时监测到插入记录后可用空间小雨1/32页，则会强制进行一个合并操作。 （强制读取辅助索引页，将InsertBufferB+树中该页的记录以及待插入的记录插入到辅助索引页中。） Master Thread Master Thread 每秒或者每10秒 根据srv_innodb_io_capacity 的百分比来进行一个Merge InsertBuffer操作。 如果在merge时，要进行的merge表已经被删除，此时直接丢弃已经被Insert/Change Buffer的数据记录。 两次写DoubleWrite为了提升InnoDB存储引擎的数据页可靠性。 当InnoDB存储引擎正在将某个页写入到表中，当这个页只被写了一部分（16k的页，只写了前4k）就发生了宕机，这种情况被称为写失效（partial page write）。 为了解决partial page write，InnoDB实现了Double write buffer，就是在写数据页之前，先把这个数据页写到一块独立的物理文件位置（ibdata），然后再写到数据页。这样在宕机重启时，如果出现数据页损坏，就需要通过该页的副本来还愿该页，然后再进行redo log重做。 double write由两部分组成，一部分是内存中的double write buffer，大小是2MB， 另一部分是磁盘上的共享表空间中连续的128个页，大小也是2M。1）当触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝到内存中的doublewrite buffer中；2）接着从两次写缓冲区分两次写入磁盘共享表空间中（连续存储、顺序写）每次写1MB；3）再将doublewrite buffer中的脏页数据写入实际的各个表空间中（离散写）。 当不需要开启doublewrite时，使用skip_innodb_doublewrite 关闭。 innodb_buffer_pool_flushed : 当前从缓冲池中刷新到磁盘页的数量innodb_dblwr_pages_written: double write 的数量 自适应哈希索引InnoDB存储引擎会监控对标上各索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引。自适应哈希索引是通过缓冲池的B+树页构造而来，因此建立的速度很快，不需要对整张表建立哈希索引。 InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。 自使用哈希索引有一个要求，对这个页的查询条件是一样的。如：where a = xxx; where a = xxx and b = xxx; 自使用哈希索引是数据库自优化的，无需DBA对数据库进行调整。可以通过innodb_adaptive_hash_index 来启用或者禁用。 异步IO1）提升吞吐量2）IO Merge操作 刷新邻接页当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。通过AIO可以将多个IO卸乳操作合并为一个IO操作。 可以通过innodb_flush_neighbors 来关闭或者开启该特性。 select version();show variables like ‘innodb_%_threads’;show variables like ‘innodb_buffer_pool_size’;show variables like ‘innodb_buffer_pool_instances’;show variables like ‘innodb_change_buffering’;show engine innodb status;","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"Mysql体系结构和存储引擎","slug":"Mysql体系结构和存储引擎","date":"2020-11-03T02:12:43.000Z","updated":"2020-11-03T03:21:43.491Z","comments":true,"path":"2020/11/03/Mysql体系结构和存储引擎/","link":"","permalink":"https://www.hessentec.top/2020/11/03/Mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","excerpt":"","text":"Mysql 体系结构 链接池组件 管理服务和工具组件 SQL接口组件 查询分析器组件 优化器组件 缓存组件 插件式表存储引擎 物理文件 存储引擎可以根据MySQL官方手册给出的定义存储引擎的过程来编写符合自己需求的存储引擎。或者使用官方提供的存储引擎。 InnoDB存储引擎InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理的应用。其特点是行锁设计、支持外间，并支持类似于Oracle的非锁定读（默认读取操作不会产生锁）。 InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。可以将每个独立的表单独存放在一个idb文件中。InnoDB存储引擎支持使用裸设备来建立其表空间。 InnoDB通过多版本并发控制（MVCC）来获得高并发性；实现了SQL标准的4种隔离级别，默认为REPEATABLE；使用Next-KeyLocking策略避免欢度现象的产生；提供了插入缓冲（Insert Buffer）；二次写（Double Write）；预读（Read Ahead）。 Innodb存储引擎采用了聚集的方式，每张表的存储都是按照主键的顺序进行存放。如果没有显式地在表定义时制定主键，InnoDB存储引擎会为每一行生成一个6字节的RowId，并以此作为主键。 MyISAM存储引擎MyISAM引擎主要面向一些OLAP（联机分析处理）的应用。 因此不支持事务、表锁设计，但支持全文索引。 它的缓存池只缓存索引文件，不缓存数据文件，数据文件的缓存交给操作系统来完成。MYISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。 Maria存储引擎其目标是用来替代原有的MYISAM，可以看作是MyISAM的后续版本。特点是支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项。更好的BLOB自负类型的处理性能。 NDB存储引擎也叫NDBCluster存储引擎，壮阳药用于MySQL Cluster分布式集群环境。 NDB的特点是数据全部放在内存中，因此主键查找的速度极快，并且通过添加NDB数据存储结点可以线性地提高数据库性能，是高可用、高性能的集群系统。由于其存储引擎特性，Join操作是在Muysql数据库层完成，而不是在存储引擎层完成。 Memory存储引擎表中的数据存放在内存中，适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引。 Memory存储引擎不支持表锁，并发行能差，不支持TEXT和BLOB列类型。存储varchar时是按照char的方式进行的。 MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集。如果中间爱护你接过机大于Memory存储引擎表的容量设置，又或者包含有TEXT或者BLOB列类型的字段，Mysql会把中间结果集转换到MyISAM存储引擎表存放到磁盘中（因为MyISAM不缓存数据文件），因此会有性能损失。 Archive存储引擎用来存储归档数据，如日志信息等。使用zlib算法将数据行进行压缩后存储，压缩比达到1:10.该引擎只支持INSERT和SELECT操作，该引擎使用行锁来实现高并发的插入操作。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"}]},{"title":"B+ Tree","slug":"Tree","date":"2020-10-19T11:58:34.000Z","updated":"2020-10-20T11:07:15.929Z","comments":true,"path":"2020/10/19/Tree/","link":"","permalink":"https://www.hessentec.top/2020/10/19/Tree/","excerpt":"","text":"B+树的特征与结构 每个子树不保存数据，值用来保存索引数据，所有的数据都保存在叶子结点上； 所有的叶子结点中包含了全部元素的信息，以及指向这些元素记录的指针，且叶子结点本身依关键字大小有效到大顺序链接。 所有的中间结点元素都同时存在于子结点，在子结点元素中是最大/最小元素 Mysql索引B+树","categories":[],"tags":[]},{"title":"DataBase-分布式事务","slug":"DataBase-分布式事务","date":"2020-10-16T03:27:19.000Z","updated":"2020-10-16T12:43:22.783Z","comments":true,"path":"2020/10/16/DataBase-分布式事务/","link":"","permalink":"https://www.hessentec.top/2020/10/16/DataBase-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"随着业务的增长，需要进行分表、分库，甚至拆分应用演化成微服务。因此一次交易需要跨库、跨服务保证每个系统中的交易要么全部成功，否则全部回滚。这里就涉及到分布式事务。 XA协议时一个基于数据库的分布式事务协议，其分为两部分：事务管理器和本地资源管理器。事务管理器作为一个全局调度着，负责对各个本地资源管理器统一发送提交或者回滚命令。二阶段提交和三阶段提交都是根据此协议衍生而来，Oracle和Mysql均已实现了XA接口。除了二阶段提交和三阶段提交外还有Try Confirm Cancel (TCC)、本地消息队列等分布式事务解决方案。 二阶段提交 2PC二阶段提交需要进行两个阶段的操作，准备阶段和提交阶段。 准备阶段就是事务管理器（协调者）分别给不同的系统发送“准备”命令，这些系统出了提交数据库事务之外的所有操作，都要在准备阶段操作完成。 提交阶段就是事务管理器（协调者）给不同的系统发送“提交”命令，每个系统提交自己的数据库事务，然后给协调者返回“提交成功”， 协调者收到所有响应以后，返回给客户端成功响应。如果遇到异常情况提交不成功，需要做一些补偿机制来保证成功。 对于二阶段提交：如果准备阶段全部返回成功， 那么进入提交阶段，该必须保证成功。如果准备阶段有一个失败，那么协调者通知每个系统回滚。 二阶段提交保证了原子性与隔离性。所以2PC适合对数据一致性高的场景。 缺陷：性能低：整个事务的执行过程需要阻塞服务端线程和数据库会话。协调者单点故障：一旦协调者宕机，就会导致事务回话一致处于等待提交阶段，直到事务超时自动回滚。超时导致同步阻塞：当某个参与者节点通信处于超时，其余参与者都会被懂阻塞导致占用的资源不能释放。 适合场景：只有病发量不大且需要强一致的情况下才考虑使用2PC。 三阶段提交 3PC三阶段提交是对二阶段提交的一种升级优化，它在二阶段提交的中间增加了precommit阶段。保证了在最后提交阶段之前，各个参与者节点状态都一致。同时在协调者与参与者中都引入超时机制，当参与者由于各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2pc的单点故障问题，但是3pc还是没有能从根本上解决数据一致性的问题。 三个阶段分别是can commit、Pre Commit 、Do Commit； CanCommit类似于二阶段提交的准备阶段，协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作，如果可以提交就返回YES，否则返回NO。如果全部响应YES则进入下一个阶段。 PreCommit协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有两种可能 所有参与者的反馈都是YES那么执行事务的预执行： 1）发送于提交请求，协调者向参与者发送Precommit请求，并进入Prepared阶段。 2）事务预提交，参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。 3）响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。 假如任何一个参与者向协调者发送了NO响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。 1）发送终端请求： 协调者向所有参与者发送abort请求。 2）中断事务：参与者收到来自协调者的abort请求之后（或者超时之后，仍未收到协调者的请求）执行事务的中断。 DoCommit该阶段进行真正的事务提交，也分为两种情况。 执行提交发送提交请求： 协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。事务提交：参与者收到docommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有的事务资源。响应反馈：参与者事务提交之后，向协调者发送ACK请求完成事务： 协调者接收到所有参与者的ACK响应之后，完成事务。 中断事务协调者没有接收到参与者发送的ACK响应（可能是参与者发送的不是ACK响应，也可能是响应超时），那么就会执行中断事务。 发送中断请求：协调者向所有参与者发送abort请求。事务回滚：参与者接收到abort请求后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。反馈结果：参与者完成事务回滚之后，向协调者发送ACK信息中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断操作。 如果已经完成了Precommit进入到Docommit阶段，有的参与者由于超时没有收到Docommit请求时，会自动提交本地事务，并且释放资源。 三阶段提交解决了二阶段提交无法释放资源的问题。也保证了在提交事务之前所有参与者的状态都一致 补偿事务（TCC）针对每个操作都要注册一个与其对应的确认和补偿（撤销操作） 它分为三个操作： Try阶段主要针对业务系统做检测以及资源预留。 Confirm阶段确认执行业务操作。 Cancel阶段取消执行业务操作。 TCC处理流程与2PC类似，不过2PC通常是在跨库的DB层面，TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，是的降低锁冲突、提高吞吐量成为可能。 不足之处在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel必须实现幂等。 本地消息队列如果只需要保证数据的最终一致性，那么可以使用消息队列来解决。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"数据库","slug":"Java技术栈/数据库","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.hessentec.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://www.hessentec.top/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://www.hessentec.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}]},{"title":"DataBase-事务","slug":"DataBase-事务","date":"2020-10-15T01:41:18.000Z","updated":"2020-10-15T10:07:12.677Z","comments":true,"path":"2020/10/15/DataBase-事务/","link":"","permalink":"https://www.hessentec.top/2020/10/15/DataBase-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"什么是事务TransactionTransaction一词在英语的翻译中还有一次交易、业务、事务、办理、处理； 对于一次账户充值100元的操作，其中就有多个环节。1）检查账户的有效性，查询账户余额；2）记录充值流水；3）为账户余额增加100元。 对于这三个操作来讲，他是一个Transaction， 要么都成功，只要有一个失败，就必须整个Transaction失败，不允许记录了充值流水成功，但是余额增加失败。这三个是一个整体，是不可分割的工作单元。 事务的特性原子性 Atomic：要么都成功，只要有一个步骤失败，整个步骤必须回滚（失败）。一致性 Consistency：事务保证读取到的数据总是一致的，如（不存在100元的充值流水时金额为100元， 存在100元的充值流水时金额为200元）。但是对于这个充值过程来讲，肯定是先记录了充值记录，后增加100元余额。可以查到充值记录，但余额是100是客观存在的。隔离性Isolation：为了保证一致性，事务执行过程中的中间状态不对外部可见，事务需要对整个过程进行隔离。持久性 Durability：只要事务一经提交，就一定会被持久化到磁盘中。 Transaction 阶段Transaction 需要有开始和结束，标记一个Transaction的开始和截止；当所有的操作都成功的时候，需要Commit;当其中某个操作失败的时候，之前的操作需要Rollback； Transaction Start;Transaction Commit Or Rollback;Transaction End; 脏读假如业务员给账户A增加100元的操作的同时（记录了充值流水100元，流水号为666），对账系统也在同时运行同时读取到了这一笔流水号为666的流水记录。但是后续的为余额增加100元的操作失败了，整个Transaction RollBack。 导致账户余额比对账系统少了100元。 在这里，对账系统看到了业务系统Transaction未提交时的数据，叫脏读。也就是说当前事务的中间状态，对其他事务时可见的。 事务的最低隔离级别是未提交读（Read Uncommitted），因此会发生脏读的现象。为了解决脏读的现象，需要将事务隔离起来，只允许读到已提交的数据。 Read Committed. 不可重复读假如业务员A给用户增加100元。 开启事务；查询账户余额 100元；有其他事情去忙…… 此时业务员B也给用户增加100元。开启事务；查询账户余额 100元增加流水记录；增加账户余额100元，变为200元；结束事务； 业务员A回来为A增加100元：查询账户余额 200元； 不可重复读就是业务员A在同一个事务内，先后两次读取同一条数据的结果可能不一样。可重复读就是业务员A在同一个事务内，先后两次读取同一条数据的结果总是相同的，无论其他会话是否已经更新了这条数据。 为了保障在同一事务下，先后两次读取到的同一条数据结果一致，需要将事务的隔离级别调整为可重复读（Repeatable Read）。 幻读假如业务员A给用户增加100元。 开启事务；查询流水中是否有ID为1000的流水记录，不存在； 业务员B给用户增加100元；开启事务；查询流水中是否有ID为1000的流水记录，不存在；插入流水记录；更新账户余额为200；提交事务； 业务员A开始执行；插入流水记录，此时已经有ID为1000的流水记录，系统异常；可以开启重试机制；由于隔离性，查询是否有ID为1000的流水记录时还是不存在，重试插入时还是异常。 为了解决幻读的问题，需要将所有的事务和操作进行串行化。这也是Database的最高隔离级别，性能也最差。 对于账户充值来讲，交易的原子性以及持久性是最重要的。可以适当牺牲一些一致性和隔离性。 以下操作在 ReadCommitted 和 Repeatable Read下是安全的。1）给账户余额表增加一个log_id属性，记录最后一笔交易的流水号。2）首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号。3）写入流水记录。4）更新账户余额以及流水记录ID，需要在更新语句的Where条件中限定，只有流水好等于之前查询出的流水号时才能更新。 update account_balance set amount = amount + 100 , log_id = 2 where user_id = 0 and log_id = 1;5）检查更新余额的返回值，如果为1 提交事务，否则回滚。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"数据库","slug":"Java技术栈/数据库","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.hessentec.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://www.hessentec.top/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"Spring-应用上下文生命周期","slug":"Spring-应用上下文生命周期","date":"2020-09-08T01:24:22.000Z","updated":"2020-09-09T01:54:56.691Z","comments":true,"path":"2020/09/08/Spring-应用上下文生命周期/","link":"","permalink":"https://www.hessentec.top/2020/09/08/Spring-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"refresh()AbstractApplicationContext#refresh() 该方法是线程安全的方法，在startupShutdownMonitor的锁同步块中。 prepareRefresh()12345678910111213141516171819202122232425262728293031323334353637383940/** * Prepare this context for refreshing, setting its startup date and * active flag as well as performing any initialization of property sources. */protected void prepareRefresh() &#123; // Switch to active. this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(\"Refreshing \" + this); &#125; else &#123; logger.debug(\"Refreshing \" + getDisplayName()); &#125; &#125; // Initialize any placeholder property sources in the context environment. initPropertySources(); // Validate that all properties marked as required are resolvable: // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // Store pre-refresh ApplicationListeners... if (this.earlyApplicationListeners == null) &#123; this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); &#125; else &#123; // Reset local application listeners to pre-refresh state. this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); &#125; // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();&#125; obtainFreshBeanFactory() This implementation performs an actual refresh of this context’s underlying bean factory, shutting down the previous bean factory (if any) and initializing a fresh bean factory for the next phase of the context’s lifecycle. 1234567891011121314151617181920212223protected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123; //如果存在beanfactory， 则关闭 destroyBeans(); closeBeanFactory(); &#125; try &#123; //为上下文生命周期的下个阶段初始化一个新的beanfactory DefaultListableBeanFactory beanFactory = createBeanFactory(); //指定ID beanFactory.setSerializationId(getId()); //设置是否允许被覆盖，是否允许循环引用 customizeBeanFactory(beanFactory); //从Xml、Annotation、Groovy中读取Bean信息并注册。 loadBeanDefinitions(beanFactory); //set the refrences to this.beanFactory. synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125;&#125; prepareBeanFactory(beanFactory)Prepare the bean facotry for use in this context. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // Tell the internal bean factory to use the context's class loader etc. beanFactory.setBeanClassLoader(getClassLoader()); beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // Register default environment beans. if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; postProcessBeanFactory(beanFactory)Allows post-processing of the bean factory in context subclasses. Modify the application context’s internal bean factory after its standard initialization.All bean definitions will have bean loaded, but no beans have been instantiated yet.This alllows for registering special BeanPostProcessors etc in certain Applicationcontext implementations. invokeBeanFactoryPostProcessors(beanFactory);invoke factory processors registered as beans in the creation. Instantiate and invoke all registered BeanFactoryPostProcessor beans,respecting explicit order if given. Must be called before singleton instantiation.","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.hessentec.top/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"}]},{"title":"Redis-总章","slug":"Redis-总章","date":"2020-09-01T09:23:07.000Z","updated":"2020-09-02T11:17:46.688Z","comments":true,"path":"2020/09/01/Redis-总章/","link":"","permalink":"https://www.hessentec.top/2020/09/01/Redis-%E6%80%BB%E7%AB%A0/","excerpt":"","text":"要设计一个内存型数据库需要考虑哪些？ 0）终端连接 1）存储的数据结构（需要支持多样的数据类型、数据结构） 哈希表Hash冲突：Key的Hash值冲突，导致一个桶挂了多个元素，Hash表退化成了链表，查找耗时。 rehash：为了解决Hash冲突的问题，需要rehash操作，增加现有的Hash桶数量。 渐进式Rehash：每操作一次迁移一个Entry，避免rehash造成的阻塞。双向链表整数数组压缩队列类似于一个数组，数组中的每一个元素都对应保存一个数据。 压缩列表表头有三个字段zlbytes 列表长度, zltail 列表尾部偏移量, zllen 列表中entry的个数, 压缩列表再表尾还有一个zlend，表示列表结束。跳表加速队列和数组的访问。简单动态字符串byte 1字节 boolean 1字节 char 2字节,只要是字符无论是英文还是汉字，都占2个字节。 short 2字节 int 4字节 long 8字节 float 4字节 double 8字节 整数数组和压缩列表再查找时间复杂度方面并没有很大的优势，为什么Redis还会把他们作为底层数据结构？ 1）内存利用率方面：数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存更少。 Redis是内存数据库，大量数据存储到内存中，此时需要做尽可能的优化，提高内存的利用率。 2）数组对CPU高速缓存支持更友好，所以Redis再设计师，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。 当数据元素超过设定阈值后看，避免时间复杂度太高，转为Hash和跳表数据结构存储，保证查询效率。 数组对CPU缓存友好的原因是，CPU预读取一个CacheLine大小的数据，数组数据排列紧凑，相同大小空间保存的元素更多，访问下一个元素时、恰好已经在CPU缓存中了，如果是随机访问，就不能充分利用CPU缓存。2）对数据的加工和操作 单个元素的查找、修改、删除对于Redis来讲会非常快（在没有Hash冲突的情况下） LLEN、SCARD等操作时间复杂度为O（1）, 集合类型采用压缩列表，双向链表，整数数组等数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效的完成相关操作。 HGETALL、SMEMBERS、LRANGE、ZRANGE等复杂度为O(N)的操作要避免，使用HSCAN、SSCAN、ZSCAN来替代，SCAN操作实现了渐进式便利，每次只返回优先数量的数据。 3）数据的安全性： 1）数据的备份： 实时备份： 对数据进行操作后记录操作日志 定时备份 2）数据的恢复4）服务的高可用 主从模式 5）服务的监控、故障恢复以及通知 哨兵模式 哨兵集群 6）数据分片 纵向扩展：扩大服务器的内存，但是当存储数据内容较多，需要RDS备份时，会影响到Redis的使用性能。 横向扩展 数据结构高性能IO模型多路复用命令解析命令处理数据安全AOF AppendOnlyFile记录每一条日志 日志压缩RDB 快照数据同步/读写分离 主从/主从从哨兵监测选举通知哨兵集群扩容纵向扩容横向扩容/分片","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Reids","slug":"Java技术栈/Reids","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Reids/"}],"tags":[]},{"title":"Spring-注解","slug":"Spring-注解","date":"2020-08-18T11:41:32.000Z","updated":"2020-08-26T13:34:54.978Z","comments":true,"path":"2020/08/18/Spring-注解/","link":"","permalink":"https://www.hessentec.top/2020/08/18/Spring-%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Spring 注解驱动编程发展历程 1.2 @Transactional @ManagedResource 2.0 @Component @Repository 3.0 @Bean @Import 4.0 @Profile @Conditional @IndexedSpring 核心注解场景分类 |注解|场景说明|起始版本| |---|---|---| |@Repository| 数据仓储模式注解| 2.0| |@Component| 通用组件模式注解| 2.5| |@Service| 服务模式注解| 2.5| |@Controller| Web控制器模式注解| 2.5| |@Configuration| 配置类模式注解| 3.0|装配注解|注解|场景说明|起始版本| |---|---|---| |@ImportResource| 替换XML元素\\&lt;import\\&gt;| 2.5| |@Import| 导入Configuration类，无论是否标记@Configuration| 2.5| |@ComponentScan| 扫描指定package下标注Spring模式注解的类| 3.1|依赖注入注解|注解|场景说明|起始版本| |---|---|---| |@Autowired| Bean依赖注入，支持多种依赖查找方式| 2.5| |@Qualifier| 细粒度的@Autowired查找| 2.5|Spring 注解编程模型 元注解 Spring 模式注解 Spring 组合注解 Spring 注解属性别名/覆盖 Spring 元注解（Meta-Annotations） A meta-annotation is an annotation that is declared on another annotation. An annotation is therefore meta-annotated if it is annotated with another annotation. For example, any annotation that is declared to be documented is meta-annotated with @Documented from the java.lang.annotation package. java.lang.annotation.Documented java.lang.annotation.Inherited java.lang.annotation.Repeatable Spring 模式注解（Stereotype Annotations） 元标注@Component的注解在XML元素 context:component-scan 或 注解 @ComponentScan 扫描中派生了 @Component 特性， 并且从Spring Framework 4.0 开始支持多层次派生。 @Repository @Service @Controller @Configuration @SpringBootConfiguration Spring 组合注解（Composed Annotations） A composed annotation is an annotation that is meta-annotated withy one or more annotations with the intent of combining the behavor associated with those meta-annotations into a single custom annotation. For example, an annotation named @TransactionalService that is meta-annotation with Spring’s @Transactional and @Service annotations is a composed annotation that combines the semantics of @Transactional and @Service. @TransactionalService is technically also a custom stereotype annotation. 基本定义： spring组合注解中的元注解允许是Spring模式注解与其他Spring功能性注解的任意组合。 Spring 注解属性别名（Attribute Alias） Spring 注解属性覆盖（Attribute Ovverides） Spring @Enable 模块驱动 @Import(@Configuration) @Import(ImportSelector) @Import(ImportBeanDefinitionRegistrar) AnnotatedBeanDefinition ad = new AnnotatedGenericBeanDefinition(); BeanDefinitionReaderUtils.registerWithGeneratedName(ad, register); Spring 条件注解 上下文对象： org.springframework.context.annotation.ConditionContext条件判断：org.springframework.context.annotation.ConditionEvaluator配置阶段：org.sprignframework.context.annotation.ConfigurationCondition.ConfigurationPhase判断入口：org.springframework.context.annotation.ConfigurationClassPostProcessor org.springframework.context.annotation.ConfigurationClassPasserConditionContextConditionEvaluator","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"Spring-DataBind","slug":"Spring-DataBind","date":"2020-08-15T01:44:54.000Z","updated":"2020-08-15T01:44:54.057Z","comments":true,"path":"2020/08/15/Spring-DataBind/","link":"","permalink":"https://www.hessentec.top/2020/08/15/Spring-DataBind/","excerpt":"","text":"","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"Spring-Validator","slug":"Spring-Validator","date":"2020-08-14T11:17:14.000Z","updated":"2020-08-14T12:24:57.323Z","comments":true,"path":"2020/08/14/Spring-Validator/","link":"","permalink":"https://www.hessentec.top/2020/08/14/Spring-Validator/","excerpt":"","text":"Spring 校验使用场景 Spring 常规校验 Validator Spring 数据绑定 Databinder Spring Web 参数绑定 WebDataBinder Spring WebMVC/WebFlux 处理方法参数校验 Validator 接口设计 Errors 接口设计 Errors 文案来源 自定义Validator Validator的救赎 面试题","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"Spring-Resource-资源管理","slug":"Spring-Resource-资源管理","date":"2020-08-07T01:03:00.000Z","updated":"2020-08-10T12:40:58.329Z","comments":true,"path":"2020/08/07/Spring-Resource-资源管理/","link":"","permalink":"https://www.hessentec.top/2020/08/07/Spring-Resource-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"引入冬季 Java标准资源管理 强大 |面向资源|文件系统、artifact（Jar、War、ear）、远程资源（HTTP/FTP）| |API整合|java.lang.ClassLoader.getResource\\ java.io.File / java.net.URL| |资源定位|java.net.URL / java.net.URI| |面向流存储|java.net.URLConnection| |协议扩展|java.net.URLStreamHandler / java.net.URLStreamHandlerFactory| 扩展复杂 Spring资源接口 类型 接口 输入流 org.springframework.core.io.InputStreamSource 只读资源 org.springframework.core.io.Resource 可写资源 org.springframework.core.io.WritableResource 编码资源 org.springframework.core.io.EncodedResource 上下文资源 org.springframework.core.io.ContextResource Spring内建Resource实现 |Bean 定义|无|org.springframework.beans.factory.support.BeanDefinitionResource||字节码|无|org.springframework.core.io.ByteArrayResource||类路径|classpath:/|org.springframework.core.io.ClassPathResource||文件系统|file:/|org.springframework.core.io.FileSystemResource||URL|URL支持的协议|org.springframework.core.io.UrlResource||ServletContext|无|org.springframework.web.context.support.ServletContextResource| Spring Resource 接口扩展Spring 资源加载器 Resource 加载器 org.springframework.core.io.ResourceLoader org.springframewor.core.io.DefaultResourceLoader org.springframework.core.io.FileSystemResourceLoader org.springframework.core.io.ClassRelativeResourceLoader org.springframework.context.support.AbstractapplicationContext Spring 通配路径资源加载器 通配路径ResourceLoader org.springframework.core.io.support.ResourcePatternResolver org.springframework.core.io.support.PathMatchingResourcePatternResolver 路径匹配起 org.springframework.util.PathMatcher Ant模式匹配实现 - org.springframework.util.AntPathMatcher Spring 通配路径资源扩展 依赖注入 Spring Resource @Value(“classpath:/…”) private Resource resource; 依赖注入 ResourceLoader 实现 ResourceLoaderAware 回调 @Autowire 注入 ResourceLoader 注入ApplicationContext 作为 ResourceLoader Java 标准资源管理扩展 实现URLStreamhandler, 并放置在 sun.net.www.protocal.${protocal}.Handler 下 12345678910111213public class XURLConnection extends URLConnection&#123; private final UrlResource resource; protected XURLConnection(URL url)&#123; super(url); this.resource = new ClassPathResource(url.getPath()); &#125; public InputStream getInputStream() throws IOException&#123; return resource.getInputStream(); &#125;&#125; 12345public class Handler extends URLStreamHandler&#123; protected URLConnection openConnection(URL u) throws IOException&#123; return new XURLConnection(u); &#125;&#125; 123URL url = new URL(\"x:///META-INF/default.properties\");InputStream is = url.openStream();System.out.println(StreamUtils.copyString(is, Charset.forName(\"UTF-8\"))); 实现URLStreamHandler， 添加 -Djava.protocal.handler.pkgs 启动参数,指向URLStreamHandler 实现类的包 实现URLStreamHandlerFactory 并传递到URL之中","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"资源管理","slug":"资源管理","permalink":"https://www.hessentec.top/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"}]},{"title":"Spring-Bean配置元信息","slug":"Spring-Bean配置元信息","date":"2020-07-28T13:12:16.000Z","updated":"2020-08-06T01:45:17.741Z","comments":true,"path":"2020/07/28/Spring-Bean配置元信息/","link":"","permalink":"https://www.hessentec.top/2020/07/28/Spring-Bean%E9%85%8D%E7%BD%AE%E5%85%83%E4%BF%A1%E6%81%AF/","excerpt":"","text":"Spring 配置元信息 Bean配置元信息：BeanDefinition Bean属性元信息：PropertyValues 容器配置元信息 外部化配置元信息： PropertySource Profile 元信息： @Profile Spring Bean 配置元信息 GenericBeanDefinition RootBeanDefinition AnnotatedBeanDefinitionSpring Bean 属性元信息 PropertyValues MutablePropertyValues PropertyValueBean 属性上下文存储 AttributeAccessorBean 元信息元素 BeanMetadataElement Spring 容器配置元信息 beans 元素123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- outter --&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" profile=\"dev\" default-lazy-init=\"default\" default-merge=\"default\" default-autowire=\"default\" default-autowire-candidates=\"\" default-init-method=\"\" default-destroy-method=\"\"&gt; &lt;!-- inner --&gt; &lt;import resource=\"applicationContext-lookup.xml\"/&gt; &lt;bean id=\"userRepository\" class=\"com.github.springframework.repository.UserRepository\" autowire=\"byType\"&gt;&lt;/bean&gt;&lt;/beans&gt; Beans元素属性 默认值 使用场景 profile null（留空） SpringProfiles 配置值 default-lazy-init default 当outter Beans “default-lazy-init”属性存在时，继承该值，否则为false default-merge default 当outter beans ‘default-merge’ 属性存在时，继承该值，否则为“false” default-autowire default 当outter beans “default-autowire”存在时，继承该值，否则为no default-autowire-candidates null 默认SpringBean名称的pattern default-init-method null 默认springBeans 自定义初始化方法 default-destroy-method null 默认SpringBean自定义的销毁方法 Spring Xml 配置元信息 xml元素 使用场景 &lt;context:annotation-config/&gt; 激活Spring注解驱动 &lt;context:component-scan/&gt; Spring @Component 以及自定义注解扫描 &lt;context:load-time-weaver /&gt; 激活Spring LoadTimeWeaver &lt;context:mbean-export /&gt; 暴露Springbeans 做为JMX beans &lt;context:mbean-server /&gt; 将当前平台作为MBeanServer &lt;context:property-placeholder /&gt; 加载外部化配置资源作为Spring属性配置 &lt;context:property-override /&gt; 利用外部化配置资源覆盖Spring属性值 底层实现 BeanDefinitionParserDelegate 基于XML文件装载Spring Bean 配置元信息 xml元素 使用场景 &lt;beans:beans /&gt; 单XML资源下的多个SpringBean配置 &lt;beans:bean /&gt; 单个SpringBean定义Beandefinition 配置 &lt;beans:alias /&gt; 为SpringBean 定义（BeanDefinition）映射别名 &lt;beans:import /&gt; 加载外部SpringXML 配置资源 底层实现 XmlBeanDefinitionReader 和 BeanDefinitionDocumentReader 和 BeanDefinitionHolder 基于Properties文件装载Spring Bean 配置元信息 Properties 属性名 使用场景 (class) Bean类全称限定名 (abstract) 是否为抽象的BeanDefinition (parent) 指定 parent BeanDefinition (lazy-init) 是否延迟初始化 (ref) 引用其他Bean的名称 (scope) 设置Bean的scope属性 ${n} n标示第n个构造器参数 底层实现PropertiesBeanDefinitionReader 基于Java注解装载SpringBean的配置元信息 Spring注解 场景说明 @Repository 数据仓储模式 @Component 通用组建模式 @Service 服务模式 @Controller Web控制器模式 @Configuration 配置类模式 @Autowired Bean依赖注入，支持多种依赖查找方式 @Qualifier 细粒度的@Autowired 依赖查找 @Resource Java注解，类似于@Autowired @Inject Java注解，类似于@Autowired @Profile 配置话条件装配 @Conditional 编程条件装配 @PostConstructor 替换XML元素 &lt;bean init-method=” /&gt; 或者 initializingBean @PreDestroy 替换XML元素 或者 DisposableBean ClassPathScanningCandidateComponentProviderAutowiredAnnotationBeanPostProcessorCommonAnnotationBeanPostProcessor SpringBean配置元信息底层实现 Xml资源 BeanDefinition解析与注册 核心API: XmlBeanDefinitionReader 资源： Resource 底层： BeanDefinitionDocumentReader XML 解析： JavaDOM Level 3 API BeanDefinition 解析 BeanDefinitionParserDelegate BeanDefinition 注册 BeanDefinitionRegistryDefaultBeanDefinitionDocumentReader Properties 资源 BeanDefinition 解析与注册 核心API：PropertiesBeanDefinitionReader 资源 字节流：Resource 字符流：EncodeResource 底层： 存储：java.util.Properties BeanDefinition 解析： API内部实现 BeanDefinition 注册： BeanDefinitionRegistry Annotation 解析与注册 核心API：AnnotatedBeanDefinitionReader 资源 类对象： java.lang.Class 底层 条件评估： ConditionEvaluator Bean范围解析： ScopeMetadataResolver BeanDefinition解析：内部API实现 BeanDefinition处理：AnnotationConfigUtils.processCommonDefinitionAnnotations BeanDefinition注册：BeanDefinitionRegistry 基于XML文件装载SpringIOC容器配置元信息 命名空间 所属模块 Schema资源URL beans spring-beans https://www.springframework.org/schema/beans/spring-beans.xsd context spring-context https://www.springframework.org/schema/context/spring-context.xsd aop spring-aop https://www.springframework.org/schema/aop/spring-aop.xsd tx spring-tx https://www.springframework.org/schema/tx/spring-tx.xsd util spring-util https://www.springframework.org/schema/util/spring-util.xsd tool spring-tool https://www.springframework.org/schema/tool/spring-tool.xsd 基于Java注解装载SpringIOC容器配置元信息 Spring注解 场景说明 Since @ImportResource 替换XML元素 &lt;/import&gt; 3.0 @Import 导入Configuration Class 3.0 @ComponentScan 扫描指定package下标注Spring模式注解的类 3.1 @PropertySource 配置属性抽象 3.1 @PropertySources @PropertySource集合注解 4.0 基于ExtensibleXML authoring扩展Spring XML元素 编写 XML Schema 文件，定义XML结构 自定义NameSpaceHandler， 实现命名空间绑定 自定义BeanDefinitionParser， 实现XML元素与BeanDefinition解析 注册XML扩展：命名空间与XML Schema 映射 Extensible XML authoring扩展原理 AbstractApplicationcontext.obtainFreshBeanFactory AbstractRefreshableApplicationContext.refreshBeanFactory AbstractXmlApplicationContext.loadBeanDefinitions XmlBeanDefinitionReader.doLoadBeanDefinitions BeanDefinitionParserDelegate.parseCustomElement BewanDefinitionParserDelegate.parseCustomElement(Element, BeanDefinition); 获取namespace 通过namespace 解析NamespaceHandler 构造ParserContext 解析元素，获取BeanDefinition 基于Properties文件装载外部化配置基于YAML文件装载外部化配置 org.springfrmework.beans.factory.config.YamlProcessor org.springframework.beans.factory.config.YamlMapFactoryBean org.springframework.beans.factory.config.YamlPropertiesFactoryBean","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"Spring-生命周期","slug":"Spring-生命周期","date":"2020-07-22T11:55:26.000Z","updated":"2020-07-28T13:28:38.214Z","comments":true,"path":"2020/07/22/Spring-生命周期/","link":"","permalink":"https://www.hessentec.top/2020/07/22/Spring-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"SpringBean 元信息 元信息的配置 通过资源的方式配置，如： XML、 Properties、Groovy 通过注解配置 ： @Bean 通过API配置 ：BeanDefinitionBuilder / GenericBeanDefinition 元信息的读取1) Get beanDefinitionRegistry for registry beanDefinitions.2) Get ResourceLoader3) Get ClassLoader. 读取通过资源方式配置，如：XmlBeanDefinitionReader、PropertiesBeanDefinitionReader、GroovyBeanDefinitionReader 读取注解配置的Bean：AnnotatedBeanDefinitionReader 123DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(beanFactory);reader.register(Main.class); 元信息的解析 图片版本的看不太清，整理一份文字版本的层级关系，除BeanDefinitionParser是顶层抽象接口外，其余Parser都是类或者抽象类。 BeanDefinitionParser SpringConfiguredBeanDefinitionParser AnnotationDrivenCacheBeanDefinitionParser ScriptingDefaultsParser ComponentScanBeanDefinitionParser AnnotationConfigBeanDefinitionParser AspectJAutoProxyBeanDewfinitionParser SpringConfiguredBeanDefinitionParser ConfigBeanDefinitionParser AnnotationDrivenBeanDefinitionParser AbstractBeanDefinitionParser MBeanExportBeanDefinitionParser MBeanServiceBeanDefinitionParser ScriptBeanDefinitionParser AbstractSingleBeanDefinitionParser ExecutorBeanDefinitionParser SchedulerBeanDefinitionParser SetBeanDefinitionParser AbstractPropertyLoadingBeanDefinitionParser LoadTimeWeaverBeanDefinitionParser CacheAdviceParser ListBeanDefinitionParser ScheduledTasksBeanDefinitionParser MapBeanDefinitionParser PropertiesBeanDefinitionParser PropertyPathBeanDefinitionParser AbstractSimpleBeanDefinitionParser ConstantBeanDefinitionParser AbstractJndiLocatingBeanDefinitionParser JndiLookupBeanDefinitionParser LocalStatelessSessionBeanDefinitionParser RemoteStatelessSessionBeanDefinitionParser SpringBean 注册1234567891011121314151617181920212223242526272829303132@Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; BeanDefinition existingDefinition &#x3D; this.beanDefinitionMap.get(beanName); this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; if (hasBeanCreationStarted()) &#123; &#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames &#x3D; updatedDefinitions; removeManualSingletonName(beanName); &#125; &#125; else &#123; &#x2F;&#x2F; Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); removeManualSingletonName(beanName); &#125; this.frozenBeanDefinitionNames &#x3D; null; &#125; if (existingDefinition !&#x3D; null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125; &#125; Spring BeanDefinition 合并阶段 GenericBeanDefinition -&gt; RootBeanDefinition Spring Bean Class 加载阶段 BeanDefinition 中定义的Class名称加载具体的Class类。 ClassLoader 类加载Java Security 安全控制ConfigurableBeanFactory 临时 ClassLoader Spring Bean 实例化 实例化前： InstantiationAwareBeanProcessor.postProcessorBeforeInstantiation() 提前生成一些代理对象，替换掉默认的springIOC的实现内容。 实例化 传统实例化方式 + 实例化策略 InstantiationStrategy 构造器依赖注入（根据类型来注入） 实例化后 InstantiationAwareBeanProcessor.postProcessorAfterInstantiation() Spring Bean 属性赋值前阶段 Bean的属性值元信息： PropertyValues 构造器参数值：ConstructorValues Bean属性赋值前回调 &lt;= 5.0 InstantiationAwareBeanPostProcessor#postProcessorPropertyValues(); &gt;= 5.1 InstantiationAwareBeanPostProcessor#postProcessorProperties(); Spring Bean Aware 接口回调阶段 Aware接口是一个标志接口，并没有提供任何实现。 BeanNameAware BeanClassLoaderAware BeanFactoryAware EnvironmentAware EmbeddedValueResolverAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware Spring Bean 初始化 初始化前 BeanPostProcessor#postProcessorBeforeInitialization 初始化 @PostConstructor AfterPropertiesSet init-method 初始化后 BeanPostProcessor#postProcessAfterInitialization 初始化完成 SmartinitializingSingleton#afterSingletonsInstanted AbstractAutowireCapableBeanFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Initialize the given bean instance, applying factory callbacks * as well as init methods and bean post processors. * &lt;p&gt;Called from &#123;@link #createBean&#125; for traditionally defined beans, * and from &#123;@link #initializeBean&#125; for existing bean instances. * @param beanName the bean name in the factory (for debugging purposes) * @param bean the new bean instance we may need to initialize * @param mbd the bean definition that the bean was created with * (can also be &#123;@code null&#125;, if given an existing bean instance) * @return the initialized bean instance (potentially wrapped) * @see BeanNameAware * @see BeanClassLoaderAware * @see BeanFactoryAware * @see #applyBeanPostProcessorsBeforeInitialization * @see #invokeInitMethods * @see #applyBeanPostProcessorsAfterInitialization */protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; Spring Bean 销毁 销毁前 DestructionAwareBeanPostProcessor#postProcessorBeforeDestruction 销毁 @PreDestroy 实现DisposableBean接口的destroy方法 自定义销毁方法 垃圾回收 关闭Spring 容器 执行GC SpringBean 覆盖finalize()方法被回调","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"生命周期","slug":"生命周期","permalink":"https://www.hessentec.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]},{"title":"Spring-作用域","slug":"Spring-作用域","date":"2020-07-21T13:50:43.000Z","updated":"2020-07-27T03:32:07.632Z","comments":true,"path":"2020/07/21/Spring-作用域/","link":"","permalink":"https://www.hessentec.top/2020/07/21/Spring-%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"Spring Bean 作用域 单例模式singleton Bean 作用域：在BeanFactory中唯一。 原型模式prototype Bean 作用域： servlet 引擎：request Bean 作用域： 将Spring Bean 存储在Servlet Request上下文中session Bean 作用域：将SpringBean存储在HttpSession中application bean 作用域：将SpringBean存储在ServletContext中。自定义Bean 作用域","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"作用域","slug":"作用域","permalink":"https://www.hessentec.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"}]},{"title":"Spring-依赖处理","slug":"Spring-依赖处理","date":"2020-07-18T00:07:51.000Z","updated":"2020-07-27T03:32:07.629Z","comments":true,"path":"2020/07/18/Spring-依赖处理/","link":"","permalink":"https://www.hessentec.top/2020/07/18/Spring-%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/","excerpt":"","text":"入口：DefaltListableBeanFactory#resolveDependency依赖描述符：DependencyDescriptor自定绑定候选对象处理器：AutowireCandidateResolver","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"依赖处理","slug":"依赖处理","permalink":"https://www.hessentec.top/tags/%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/"}]},{"title":"Spring-BeanFactory","slug":"Spring-BeanFactory","date":"2020-07-17T09:00:35.000Z","updated":"2020-07-27T03:32:07.622Z","comments":true,"path":"2020/07/17/Spring-BeanFactory/","link":"","permalink":"https://www.hessentec.top/2020/07/17/Spring-BeanFactory/","excerpt":"","text":"BeanFactory是访问Spring bean容器的根接口。提供了一些获取Bean的基础方法定义。 ListableBeanFactory 和 ConfigurableBeanFactory 提供了一些更具体的特殊目标。 ListableBeanFactory继承了BeanFactory, 容器可以以列表的形式获取bean的相关信息，提供了获取多个beanName的基础方法。 ConfigurableBeanFactory 继承了 hierarchicalBeanFactory, 提供了IOC容器的可配置能力，几乎所有的BeanFactory都会实现这个接口。 AutowireCapableBeanFactory 提供了自动装配Bean的能力。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"Spring-BeanFactory","slug":"Spring-BeanFactory","permalink":"https://www.hessentec.top/tags/Spring-BeanFactory/"}]},{"title":"Spring-依赖注入","slug":"Spring-依赖注入","date":"2020-07-16T12:39:24.000Z","updated":"2020-07-18T01:33:10.887Z","comments":true,"path":"2020/07/16/Spring-依赖注入/","link":"","permalink":"https://www.hessentec.top/2020/07/16/Spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"依赖注入的模式和类型 手动 Xml资源配置元信息 Java注解配置元信息 @Bean @Autowired API配置元信息 自动 Autowiring 类型 No : 默认值，未激活自动绑定，需要手动指定依赖注入 byName: 根据被注入属性的名称做为Bean名称进行依赖查找，并将对象设置到该属性 byType: 根据被注入属性的类型做为依赖类型进行查找，并将对象设置到该属性 constructor： 特殊的byType，用于构造器参数 xml 资源配置元信息 123&lt;bean id=\"\" name=\"\" class=\"\"&gt; &lt;property name=\"name\" ref=\"nameObj\"/&gt;&lt;/bean&gt; 依赖注入类型 示例 set &lt;property name=”user” ref=”userBean”/&gt; 构造器 &lt;constructor-arg name=”user” ref=”userBean”/&gt; 字段注入 @Autowired User user; 方法注入 @Autowired public void user(User user){} 回调注入 class MyBean implements BeanFactoryAware{} 依赖注入选择 基础类型注入集合类型注入限定注入延迟依赖注入依赖处理过程@Autowired 注入原理JSR-330@inject注入原理Java通用注解注入原理自定义依赖注解 自动绑定 模式 限制和不足 题目精选","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"依赖注入","slug":"依赖注入","permalink":"https://www.hessentec.top/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"}]},{"title":"Spring-依赖查找","slug":"Spring-依赖查找","date":"2020-07-14T13:43:04.000Z","updated":"2020-07-16T12:38:40.053Z","comments":true,"path":"2020/07/14/Spring-依赖查找/","link":"","permalink":"https://www.hessentec.top/2020/07/14/Spring-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/","excerpt":"","text":"依赖查找历史单一类型依赖查找JNDI - javax.naming.Context#lookup*(javax.naming.Name);JavaBeans - java.beans.beancontext.BeanContext BeanFactory: 根据bean名称查找 getBean(String); getBean(String,Object…) //覆盖默认参数 根据Bean类型查找 bean实时查找 getBean(Class) getBean(Class,Object…)//覆盖默认参数 bean延时查找 getBeanProvider(Class); getBeanProvider(String,Class); 根据Bean名称和类型查找 getBean(String,Class); 123456789101112131415161718192021/** * 通过 &#123;@link org.springframework.beans.factory.ObjectProvider&#125; 进行依赖查找 */public class ObjectProviderDemo &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ObjectProviderDemo.class); applicationContext.refresh(); lookupByObjectProvider(applicationContext); applicationContext.close(); &#125; @Bean public String helloWorld() &#123; return \"Hello World\"; &#125; private static void lookupByObjectProvider(AnnotationConfigApplicationContext applicationContext) &#123; ObjectProvider&lt;String&gt; objectProvider = applicationContext.getBeanProvider(String.class); System.out.println(objectProvider.getObject()); &#125;&#125; 集合类型依赖查找java.beans.beancontext.BeanContext ListableBeanFactory是针对某个类型去查找一个集合列表。一种是查询bean的名称， 一种是查询bean的实例。一般情况下应该使用bean的名称来判断当前bean是否存在，或者进一步判断BeanDefinition是否存在。而查询bean实例会提早初始化bean实例，造成初始化不完整。 根据Bean类型查找 获取同类型Bean名称列表 getBeanNamesForType(Class) getBeanNamesForType(ResolvableType) 获取痛类型Bean实例列表 getBeansOfType(Class)以及重载方法 根据注解类型查找 获取标注类型Bean 名称列表 getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt;); 获取标注类型Bean实例列表 getBeansWithAnnotation(Class&lt;? extends Annotation&gt;); 获取指定名称+标注类型实例 findAnnotationOnBean(String,Class&lt;? extends Annotation&gt;); 层次性依赖查找java.beans.beancontext.BeanContext HierachicalBeanFactory 双亲 BeanFactory: getParentBeanFactory(); 层次查找 根据Bean名称查找 基于containsLocalBean方法实现 根据Bean类型查找实例列表 单一类型：BeanFactoryUtils#beanOfType 集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors 根据Java注解查找名称列表 BeanFactoryUtils#beanNamesForTypeIncludingAncestors 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HierarchicalDependencyLookupDemo &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory(); HierarchicalBeanFactory parentBeanFactory = createParentBeanFactory(); beanFactory.setParentBeanFactory(parentBeanFactory); displayContainsLocalBean(beanFactory, \"user\"); //false displayContainsLocalBean(parentBeanFactory, \"user\"); //true displayContainsBean(beanFactory, \"user\"); //true displayContainsBean(parentBeanFactory,\"user\");//true applicationContext.refresh(); applicationContext.close(); &#125; private static void displayContainsBean(HierarchicalBeanFactory beanFactory, String beanName) &#123; System.out.printf(\"当前 BeanFactory [%s] 是否包含 bean[name:%s] %s\\n\", beanFactory, beanName, containsBean(beanFactory,beanName)); &#125; private static boolean containsBean(HierarchicalBeanFactory beanFactory, String beanName) &#123; BeanFactory parentBeanFactory = beanFactory.getParentBeanFactory(); if (parentBeanFactory instanceof HierarchicalBeanFactory) &#123; HierarchicalBeanFactory parentHierarchicalBeanFactory = HierarchicalBeanFactory.class.cast(parentBeanFactory); if (containsBean(parentHierarchicalBeanFactory, beanName)) &#123; return true; &#125; &#125; return beanFactory.containsLocalBean(beanName); &#125; private static void displayContainsLocalBean(HierarchicalBeanFactory parentBeanFactory, String user) &#123; System.out.printf(\"当前 BeanFactory [%s] 是否包含 Local bean[name:%s] %s\\n\", parentBeanFactory, user, parentBeanFactory.containsLocalBean(user)); &#125; private static HierarchicalBeanFactory createParentBeanFactory() &#123; DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); String location = \"classpath:applicationContext-lookup.xml\"; reader.loadBeanDefinitions(location); return beanFactory; &#125;&#125; 延迟依赖查找 Bean延迟依赖查找接口 org.springframework.beans.factory.ObjectFactory#getObject(); org.springframework.beans.factory.ObjectProvider Spring5对于Java8的特性扩展 函数式接口 getIfAvailable(Supplier) ifAvailable(Consumer) Stream扩展 - stream() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 通过 &#123;@link org.springframework.beans.factory.ObjectProvider&#125; 进行依赖查找 */public class ObjectProviderDemo &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(ObjectProviderDemo.class); applicationContext.refresh(); lookupByObjectProvider(applicationContext); lookupIfAvailable(applicationContext); lookupByStream(applicationContext); applicationContext.close(); &#125; private static void lookupByStream(AnnotationConfigApplicationContext applicationContext) &#123; ObjectProvider&lt;String&gt; objectProvider = applicationContext.getBeanProvider(String.class);// Iterator&lt;String&gt; iterator = objectProvider.iterator();// while(iterator.hasNext())&#123;// System.out.println(iterator.next());// &#125; objectProvider.stream().forEach(System.out::println); &#125; private static void lookupIfAvailable(AnnotationConfigApplicationContext applicationContext) &#123; ObjectProvider&lt;User&gt; userObjectProvider = applicationContext.getBeanProvider(User.class); User user = userObjectProvider.getIfAvailable(User::new); System.out.println(user); &#125; @Bean @Primary public String helloWorld() &#123; return \"Hello World\"; &#125; @Bean public String message()&#123; return \"message\"; &#125; private static void lookupByObjectProvider(AnnotationConfigApplicationContext applicationContext) &#123; ObjectProvider&lt;String&gt; objectProvider = applicationContext.getBeanProvider(String.class); System.out.println(objectProvider.getObject()); &#125;&#125; 安全依赖查找依赖查找安全性对比 依赖查找类型 代表实现 是否安全 单一类型查找 BeanFactory#getBean 否 ObjectFactory#getObject 否 ObjectProvider#getIfAvailable 是 集合类型查找 ListableBeanFactory#getBeansOfType 是 ObjectProvider.stream 是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.github.springframework.models.User;import org.springframework.beans.BeansException;import org.springframework.beans.factory.*;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TypeSafetyDependencyLookupDemo &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(TypeSafetyDependencyLookupDemo.class); applicationContext.refresh(); displayBeanFactoryGetBean(applicationContext); displayObjectFactoryGetObject(applicationContext); displayObjectProviderIfAvailable(applicationContext); displayListableBeanFactoryGetBeansOfType(applicationContext); displayObjectProviderStreamOps(applicationContext); applicationContext.close(); &#125; public static void displayObjectProviderStreamOps(AnnotationConfigApplicationContext beanFactory)&#123; ObjectProvider&lt;User&gt; userObjectFactory = beanFactory.getBeanProvider(User.class); printException(\"displayObjectProviderStreamOps\", ()-&gt;userObjectFactory.forEach(System.out::println)); &#125; public static void displayListableBeanFactoryGetBeansOfType(ListableBeanFactory beanFactory)&#123; printException(\"displayListableBeanFactoryGetBeansOfType\", ()-&gt;beanFactory.getBeansOfType(User.class)); &#125; public static void displayObjectProviderIfAvailable(BeanFactory beanFactory)&#123; ObjectProvider&lt;User&gt; userObjectFactory = beanFactory.getBeanProvider(User.class); printException(\"displayObjectProviderIfAvailable\", ()-&gt;userObjectFactory.getIfAvailable()); &#125; public static void displayObjectFactoryGetObject(BeanFactory beanFactory)&#123; ObjectProvider&lt;User&gt; userObjectFactory = beanFactory.getBeanProvider(User.class); printException(\"displayObjectFactoryGetObject\", ()-&gt;userObjectFactory.getObject()); &#125; public static void displayBeanFactoryGetBean(BeanFactory beanFactory)&#123; printException(\"displayBeanFactoryGetBean\",()-&gt;beanFactory.getBean(User.class)); &#125; public static void printException(String source, Runnable run)&#123; System.out.println(\"Source From : \" + source); System.out.println(\"======================================\"); try&#123; run.run(); &#125;catch (BeansException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 内建可查找的依赖 AbstractApplicationContext 内建可查找依赖 Bean名称 Bean实例 使用场景 environment Environment对象 外部化配置以及Profiles systemProperties java.util.Proerties对象 Java系统属性 systemEnvironment java.util.Map对象 操作系统环境变量 messageSource MessageSource对象 国际化文案 lifecycleProcessor LifecycleProcessor对象 LifecycleBean处理器 applicationEventMulticaster ApplicationEventMulticaster对象 Spring事件广播器 注解驱动Spring上下文内建可查找的依赖 AnnotationConfigUtils. Bean名称 Bean实例 使用场景 org.springframework.context.annotation.internalConfigurationAnnotationProcessor ConfigurationClassPostProcessor对象 处理Spring配置类 org.springframework.context.annotation.internalAutowiredAnnotationProcessor AutowireAnnotationBeanPostProcessor对象 处理@Autowired以及@Value注解 org.springframework.context.annotation.internalCommonAnnotatinProcessor CommonAnnotationBeanPostProcessor对象 条件激活处理JSR-250注解，如@PostConstruct org.springframework.context.event.internalEventListenerProcessor EventListenerMethodProcessor对象 处理@EventListener的Spring事件监听方法 依赖查找中的异常 NoSuchBeanDefinitionException NoUniqueBeanDefinitionException BeanInstantiationException BeanCreationException BeanDefinitionStoreException 常见题目 ObjectFactory 和 BeanFactory 的区别 BeanFactory.getBean 的线程安全性","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"依赖查找","slug":"依赖查找","permalink":"https://www.hessentec.top/tags/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/"}]},{"title":"Spring-Bean","slug":"Spring-Bean","date":"2020-07-14T00:24:48.000Z","updated":"2020-07-30T13:17:50.541Z","comments":true,"path":"2020/07/14/Spring-Bean/","link":"","permalink":"https://www.hessentec.top/2020/07/14/Spring-Bean/","excerpt":"","text":"BeanDefinition A BeanDefinition describes a bean instance, which has property values,Constructor arguments values, and further information supplied by concrete implementations.This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor to introspect and modify property values and other bean metadata. BeanDefinition： 顶级父接口,继承了BeanMetadataElement和AttributeAccessor. AbstractBeanDefinition：是GenericBeanDefinition、RootBeanDefinition、ChildBeanDefinition 的通用属性的完整实现。GenericBeanDefinition: 标准的bean定义目的的一站式服务类.RootBeanDefinition: 根Bean定义，代表合并的BeanDefinition。ChildBeanDefinition: 有parent的BeanDefinition BeanDefinition是SpringFramework中定义的配置元信息接口,包含了： Bean 的类名 Bean 的行为配置元素，如作用域、自动绑定模式、生命周期回调等 其他Bean引用，（Collaborators、Dependends) 配置设置（Bean的Properties） BeanDefinition 元信息 属性 说明 Class Bean的全限类名，必须是具体类 Name Bean的名称或者🆔 Scope Bean的作用域，singleton、prototype Constructor arguments Bean的构造器参数 for DI Properties Bean的属性设置 for DI Autowiring Mode Bean的自动绑定模式：ByName 、 byType Lazy Initialization Mode Bean 延迟初始化模式 initialzation method Bean初始化回调方法名称 destruction method Bean 销毁回调方法名称 BeanDefinition 构建 通过BeanDefinitionBuilder构建Beandefinition 1234567 //bean definition builder.BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);beanDefinitionBuilder.addPropertyValue(\"id\",1L);beanDefinitionBuilder.addPropertyValue(\"name\",\"lisi\");BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition(); 通过GenericBeanDefinition 构建 12345678910GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();genericBeanDefinition.setBeanClass(User.class);MutablePropertyValues propertyValues = new MutablePropertyValues();// propertyValues.addPropertyValue(\"id\",2L);// propertyValues.addPropertyValue(\"name\",\"zhaowu\");propertyValues.add(\"id\",2L) .add(\"name\",\"zhaowu\");genericBeanDefinition.setPropertyValues(propertyValues); SpringBean 命名每个Bean拥有一个或者多个标识符，这些标识符在Bean所在的容器必须是唯一的。通常，一个Bean仅有一个标识符，可以考虑使用别名来扩充。 在基于XML的配置元信息中，可以使用id或者name属性来规定Bean的标识符。通常Bean的标识符由字母组成，允许出现特殊字符。可以在Bean的name属性使用逗号“,”或者“;”或者空格来间隔名称做为别名。 Bean的id或者name属性如果为空，容器会为Bean自动生成一个唯一的名称。 BeanNameGenerator DefaultBeanNameGenerator123456789101112131415161718192021222324252627282930313233343536373839404142/** * Generate a bean name for the given bean definition, unique within the * given bean factory. * @param definition the bean definition to generate a bean name for * @param registry the bean factory that the definition is going to be * registered with (to check for existing bean names) * @param isInnerBean whether the given bean definition will be registered * as inner bean or as top-level bean (allowing for special name generation * for inner beans versus top-level beans) * @return the generated bean name * @throws BeanDefinitionStoreException if no unique name can be generated * for the given bean definition */public static String generateBeanName( BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) throws BeanDefinitionStoreException &#123; String generatedBeanName = definition.getBeanClassName(); if (generatedBeanName == null) &#123; if (definition.getParentName() != null) &#123; generatedBeanName = definition.getParentName() + \"$child\"; &#125; else if (definition.getFactoryBeanName() != null) &#123; generatedBeanName = definition.getFactoryBeanName() + \"$created\"; &#125; &#125; if (!StringUtils.hasText(generatedBeanName)) &#123; throw new BeanDefinitionStoreException(\"Unnamed bean definition specifies neither \" + \"'class' nor 'parent' nor 'factory-bean' - can't generate bean name\"); &#125; String id = generatedBeanName; if (isInnerBean) &#123; // Inner bean: generate identity hashcode suffix. id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition); &#125; else &#123; // Top-level bean: use plain class name with unique suffix if necessary. return uniqueBeanName(generatedBeanName, registry); &#125; return id;&#125; 由代码可以看出， 首先获取BeanClassName, BeanClassName 为空时，获取ParentName，ParentName为空时获取FactoryBeanName， 当三者都为空的时候名称是无法创建的。 三者不为空时生成的名称前缀为：BeanClassNameParentName$childFactoryBeanName$created 在生成名字时，如果是内部类， 则生成名字为前缀+#+当前beanDefinition的hashCode， 如下：BeanClassName#hashCodeParentName$child#hashCodeFactoryBeanName$created#hashCode 如果不是内部类， 则调用uniqueBeanName生成唯一的BeanName，格式为 + “#” + 序号。 BeanClassName#1ParentName$child#1FactoryBeanName$created#1 1234567891011121314151617181920/** * Turn the given bean name into a unique bean name for the given bean factory, * appending a unique counter as suffix if necessary. * @param beanName the original bean name * @param registry the bean factory that the definition is going to be * registered with (to check for existing bean names) * @return the unique bean name to use * @since 5.1 */public static String uniqueBeanName(String beanName, BeanDefinitionRegistry registry) &#123; String id = beanName; int counter = -1; // Increase counter until the id is unique. while (counter == -1 || registry.containsBeanDefinition(id)) &#123; counter++; id = beanName + GENERATED_BEAN_NAME_SEPARATOR + counter; &#125; return id;&#125; AnnotationBeanNameGeneritor先判断是否为AnnotatedBeanDefinition, 优先按照AnnotationBeanDefinition配置的Value获取，如果没有配置，则按照缺省的方式来生成beanName(如果是mypackage.MyJdbcDao 则生成 myJdbcDao)。 123456789101112@Overridepublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123; if (definition instanceof AnnotatedBeanDefinition) &#123; String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition); if (StringUtils.hasText(beanName)) &#123; // Explicit bean name found. return beanName; &#125; &#125; // Fallback: generate a unique default bean name. return buildDefaultBeanName(definition, registry);&#125; 12345678910111213141516/** * Derive a default bean name from the given bean definition. * &lt;p&gt;The default implementation simply builds a decapitalized version * of the short class name: e.g. \"mypackage.MyJdbcDao\" -&gt; \"myJdbcDao\". * &lt;p&gt;Note that inner classes will thus have names of the form * \"outerClassName.InnerClassName\", which because of the period in the * name may be an issue if you are autowiring by name. * @param definition the bean definition to build a bean name for * @return the default bean name (never &#123;@code null&#125;) */protected String buildDefaultBeanName(BeanDefinition definition) &#123; String beanClassName = definition.getBeanClassName(); Assert.state(beanClassName != null, \"No bean class name set\"); String shortClassName = ClassUtils.getShortName(beanClassName); return Introspector.decapitalize(shortClassName);&#125; BeanDefinition 配置Xml123456789101112&lt;bean id=\"user\" class=\"com.github.springframework.models.User\" primary=\"true\"&gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;property name=\"name\" value=\"zhangsan\"/&gt;&lt;/bean&gt;&lt;bean id=\"superUser\" class=\"com.github.springframework.models.SuperUser\" parent=\"user\" &gt; &lt;property name=\"addr\" value=\"上海\"/&gt;&lt;/bean&gt;&lt;bean id=\"objectFactory\" class=\"org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean\"&gt; &lt;property name=\"targetBeanName\" value=\"user\"/&gt;&lt;/bean&gt; Java注解 @Bean123456789101112131415161718192021222324252627282930public class AnnotationBeanDefinitionDemo &#123; public static void main(String[] args) &#123; //create factory bean AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); //register config class. applicationContext.register(Config.class); //refresh applicationContext.refresh(); //getUser System.out.println(applicationContext.getBean(User.class)); &#125; static class Config&#123; @Bean public User user()&#123; User user = new User(); user.setId(1L); user.setName(\"Ann: zhangsan\"); return user; &#125; &#125;&#125; Java注解 @Component12345678910111213141516171819202122232425public class AnnotationBeanDefinitionDemo &#123; public static void main(String[] args) &#123; //create factory bean AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); //register config class. applicationContext.register(Config.class); //refresh applicationContext.refresh(); // System.out.println(applicationContext.getBean(Config.class)); &#125; @Component static class Config&#123; @Bean public User user()&#123; User user = new User(); user.setId(1L); user.setName(\"Ann: zhangsan\"); return user; &#125; &#125;&#125; BeanDefinition注册到容器BeanDefinitionRegistry 提供了 BeanDefinition 的注册、删除，获取，判断是否存在等功能。 12345678910static void beanDefinitionRegistry(BeanDefinitionRegistry registry, String name) &#123; BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class); beanDefinitionBuilder.addPropertyValue(\"id\", 1L) .addPropertyValue(\"name\", \"Reg: zhangsan\"); if (StringUtils.hasText(name)) &#123; registry.registerBeanDefinition(name, beanDefinitionBuilder.getBeanDefinition()); &#125; else &#123; BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(),registry); &#125;&#125; 由于AnnotatinoConfigApplicationContext 是 BeanDefinitionRegistry的间接子类。 12345678AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();applicationContext.register(Config.class);beanDefinitionRegistry(applicationContext,\"REG:ZhangSan:Name\");beanDefinitionRegistry(applicationContext,null);applicationContext.refresh();System.out.println(applicationContext.getBeansOfType(Config.class));System.out.println(applicationContext.getBeansOfType(User.class));System.out.println(applicationContext.getBeansOfType(AnnotationApplicationContextDemo.class)); Bean 实例化常规： 通过构造器（配置元信息：XML、Java注解、JavaAPI） 静态工厂方法（配置元信息：XML、JavaAPI） 12345678910public class User2 &#123; private Long id; private String name; public static User2 getInstance()&#123; return new User2(); &#125;&#125; 1&lt;bean id=\"user-by-static-method\" class=\"com.github.spring.beans.User2\" factory-method=\"getInstance\"&gt;&lt;/bean&gt; 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:/META-INF/bean-creation-context.xml\");User2 user = applicationContext.getBean(\"user-by-static-method\", User2.class); Bean工厂方法（配置元信息：XML、JavaAPI） 12345678public interface UserFactory &#123; default User2 createuser() &#123; return new User2(); &#125;&#125;public class DefaultUserFactory implements UserFactory &#123;&#125; 12&lt;bean id=\"userFactory\" class=\"com.github.spring.factory.DefaultUserFactory\"/&gt;&lt;bean id=\"user-by-instance-method\" factory-bean=\"userFactory\" factory-method=\"createuser\"/&gt; 12ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:/META-INF/bean-creation-context.xml\");User2 user3 = applicationContext.getBean(\"user-by-instance-method\", User2.class); FactoryBean（XML、Java注解、JavaAPI） 123456789101112public class UserFactoryBean implements FactoryBean&lt;User2&gt; &#123; @Override public User2 getObject() throws Exception &#123; return User2.getInstance(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User2.class; &#125;&#125; 1&lt;bean id=\"user-by-factory-bean\" class=\"com.github.spring.factory.UserFactoryBean\"/&gt; 12ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:/META-INF/bean-creation-context.xml\");User2 user2 = applicationContext.getBean(\"user-by-factory-method\", User2.class); 特殊方式： ServiceLoaderFactoryBean Java ServiceLoader: 会在classpath:/META-INF/services下加载接口配置文件： 文件名名称为全限定接口名称，内容为全限定实现类 1com.github.spring.factory.DefaultUserFactory 123456789101112public static void demoServiceLoader() &#123; ServiceLoader&lt;UserFactory&gt; serviceLoader = ServiceLoader.load(UserFactory.class, Thread.currentThread().getContextClassLoader()); displayServiceLoad(serviceLoader);&#125;public static void displayServiceLoad(ServiceLoader&lt;UserFactory&gt; serviceLoader) &#123; Iterator&lt;UserFactory&gt; iterator = serviceLoader.iterator(); while (iterator.hasNext()) &#123; UserFactory userFactory = iterator.next(); System.out.println(userFactory.createuser()); &#125;&#125; ServiceLoaderFactoryBean的实现 123&lt;bean id=\"userFactoryServiceLoader\" class=\"org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean\"&gt; &lt;property name=\"serviceType\" value=\"com.github.spring.factory.UserFactory\"/&gt;&lt;/bean&gt; 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:/META-INF/sp-bean-creation-context.xml\");ServiceLoader&lt;UserFactory&gt; serviceLoader = applicationContext.getBean(\"userFactoryServiceLoader\", ServiceLoader.class);displayServiceLoad(serviceLoader); AutowireCapableBeanFactory#createBean(java.lang.Class,int, boolean); 123AutowireCapableBeanFactory beanFactory = applicationContext.getAutowireCapableBeanFactory();UserFactory userFactory = beanFactory.createBean(DefaultUserFactory.class);System.out.println(userFactory.createuser()); BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition); Bean的初始化 @PostConstructor InitializingBean 的 afterPropertiesSet Bean的initMethod@Bean(initMethod=””) AbstractBeanDefinition.setInitMethodName(\"\"); 1234567891011121314151617181920public class DefaultUserFactory implements UserFactory, InitializingBean &#123; public DefaultUserFactory() &#123; System.out.println(\"DefaultUserFactory Constructor Called.\"); &#125; @PostConstruct public void init()&#123; System.out.println(\"DefaultUserFactory PostConstructor Called.\"); &#125; public void initUserFactory()&#123; System.out.println(\"DefaultUserFactory initUserFactory Called.\"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(\"DefaultUserFactory afterPropertiesSet called.\"); &#125;&#125; 12345678910111213141516@Configurationpublic class BeanInitializationDemo &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(BeanInitializationDemo.class); applicationContext.refresh(); UserFactory userFactory = applicationContext.getBean(UserFactory.class) System.out.println(userFactory.createuser()); applicationContext.close(); &#125; @Bean(initMethod = \"initUserFactory\") public DefaultUserFactory userFactory()&#123; return new DefaultUserFactory(); &#125;&#125; 延迟初始化 xml: annotation: @Lazy 对于延迟初始化，是在applicationContext初始化之后进行初始化。非延迟初始化，是在applicationContext初始化之前进行初始化。 Bean 的销毁 @PreDestroy 实现DisposableBean接口的destoy()方法 Bean的 destroy方法 @Bean(destroy=\"\") AbstractBeanDefinition.setDestroyMethodName(\"\"); 如何注册一个Spring Bean 可以通过BeanDefinition和外部单体对象来注册。 12345UserFactory userFactory = new DefaultUserFactory();ConfiguableListableBeanFactory factory = applicationContext.getBeanFactory();factory.registerSingleton(\"userFactory\", userFactory);UserFactory userFactory = applicationContext.getBean(\"UserFactory\",UserFactory.class); Spring BeanDefinition 是什么？ Spring 容器是如何注册Bean的？","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"Spring-Bean","slug":"Spring-Bean","permalink":"https://www.hessentec.top/tags/Spring-Bean/"}]},{"title":"享元模式","slug":"享元模式","date":"2020-07-12T00:31:28.000Z","updated":"2020-07-12T02:22:10.693Z","comments":true,"path":"2020/07/12/享元模式/","link":"","permalink":"https://www.hessentec.top/2020/07/12/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"享元模式享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享。多食用细粒度的对象，以便于重用或者重构。 定义使用共享对象可以有效地支持大量的细粒度的对象。 大量的细粒度对象，需要把对象的共有属性提取出来，做为内部状态，剩余的非共有做为外部状态。内部状态：可以共享出来的信息，存储在襄垣对象内部，并且不会随着环境的改变而改变。外部状态：对象得以依赖的一个标记，是随着环境的改变而改变的，不可以共享的状态。 实现Flyweight抽象享元角色，产品抽象类，同时定义出对象的外部状态和内部状态的接口或者实现。 123456789101112131415161718public abstract class Flyweight&#123; private String instrinsic; //inner status protected final String extrinsic; //external status public Flyweight(String extrinsic)&#123; this.extrinsic = extrinsic; &#125; public abstract void operate(); public String getInstrinsic()&#123; return this.instrinsic; &#125; public void setInstrinsic(String instrinsic)&#123; this.instrinsic = instrinsic; &#125;&#125; ConcreteFlyweight具体享元角色，实现抽象角色的定义业务，该角色中需要注意的是内部状态处理应该与环境无关。 123456789101112131415161718192021public class ConcreteFlyweight1 extends Flyweight&#123; public ConcreteFlyweight1(String _Extrinsic)&#123; super(_Extrinsic); &#125; public void operate()&#123; //... &#125;&#125;public class ConcreteFlyweight2 extends Flyweight&#123; public ConcreteFlyweight2(String _Extrinsic)&#123; super(_Extrinsic); &#125; public void operate()&#123; //... &#125;&#125; unsharConcreteFlyweight不可共享的享元角色 不存在外部状态或者安全要求不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。 FlyweightFactory享元工厂，构造一个池容器，同时提供从池中获得对象的方法。 123456789101112131415public class FlyweightFactory&#123; private static HashMap&lt;String, Flyweight&gt; pool = new HashMap&lt;&gt;(); public static Flyweight getFlyweight(String extrinsic)&#123; Flyweight flyweight = null; if(pool.containsKey(extrinsic))&#123; flyweight = pool.get(extrinsic); &#125;else&#123; flyweight = new ConcreteFlyweight1(extrinsic); pool.put(extrinsic, flyweight); &#125; return flyweight; &#125;&#125; 应用优点可以减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。 缺点提高了程序的复杂性，需要分离出内部状态和外部状态，而且外部状态具有固话特征，不能随着内部状态的改变而改变。 扩展 线程安全的问题创建的对象尽量多，多到满足业务对象为止。 性能平衡外部状态最好以基本类型为标志，如String, Int等可以大幅提升效率。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"享元模式","slug":"享元模式","permalink":"https://www.hessentec.top/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"}]},{"title":"门面模式","slug":"外观模式","date":"2020-07-11T14:10:09.000Z","updated":"2020-07-11T15:05:40.640Z","comments":true,"path":"2020/07/11/外观模式/","link":"","permalink":"https://www.hessentec.top/2020/07/11/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"门面模式门面模式也叫外观模式。 定义要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。 外观模式提供一个高层次的接口，使得子系统更易于使用。 门面模式注重要求“统一的对象”，提供一个访问子系统的接口，除了这个接口不允许任何访问子系统的行为发生。 实现Subsystem子系统角色，可以同时有一个或者多个子系统，每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面知识一个客户端而已。 1234567891011121314151617public class classA&#123; public void doSomethingA()&#123; //..logic a &#125;&#125;public class classB&#123; public void doSomethingB()&#123; //. logic b &#125;&#125;public class classC&#123; public void doSomethingC()&#123; //. logic c. &#125;&#125; Facade门面角色，客户端可以调用这个角色的方法。这个角色知道子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统，也就是说改角色没有实际的业务逻辑，只是一个委托类。 1234567891011121314151617public class Facade&#123; private classA a = new classA(); private classB b = new classB(); private classC c = new classC(); public void methodA()&#123; this.a.doSomethingA(); &#125; public void methodB()&#123; this.b.doSomethingB(); &#125; public void methodC()&#123; this.c.doSomethingC(); &#125;&#125; 应用优点 减少系统的相互依赖 提高了灵活性 提高安全性 使用场景 为一个复杂的模块或者子系统提供一个供外界访问的接口 子系统相对独立 预防低水平人员带来的风险扩散 一个子系统可以有多个门面 门面不参与子系统内的业务逻辑","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"外观模式","slug":"外观模式","permalink":"https://www.hessentec.top/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"适配器模式","date":"2020-07-10T09:22:07.000Z","updated":"2020-07-10T10:29:46.144Z","comments":true,"path":"2020/07/10/适配器模式/","link":"","permalink":"https://www.hessentec.top/2020/07/10/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"适配器模式当我们去国外旅行时，我们国内的插头不能直接插入到国外的插线板上，我们需要购买一个电源适配器来适配国外的插线板。 或者最新版的macbook pro 用的是utypec，并不能直接插入usb3.0的u盘，我们需要购买一个适配器做转换。 定义将一个类的接口编程客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 实现Target目标角色是一个接口或者抽象类，是一个已经存在的角色，不可能去修改角色中的方法。 123public interface Target&#123; public void request();&#125; ConcreteTarget具体的目标角色实现类。 12345public class ConcreteTarget implements Target&#123; public void request()&#123; //... &#125;&#125; Adaptee源角色，已经使用中的角色。需要将Adaptee转换为Target。 12345public class Adaptee&#123; public void doSomething()&#123; //... &#125;&#125; Adaptor适配器角色。 12345public class Adaptor extends Adaptee implements Target&#123; public void request()&#123; super.doSomething(); &#125;&#125; Use123456Target target = new ConcreteTarget();target.request();Target target2 = new Adaptor();target2.request(); 扩展当需要把多个Adaptee转换为Target的时候，就不能使用继承了，因为Java中不支持多继承。这种方式叫做对象适配器。我们可以使用聚合（关联）来完成适配。 类适配器是由类的继承关系完成的。对象适配器是由类的关联关系纪念性耦合。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://www.hessentec.top/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"桥接模式","slug":"桥接模式","date":"2020-07-09T08:52:58.000Z","updated":"2020-07-09T10:37:16.922Z","comments":true,"path":"2020/07/09/桥接模式/","link":"","permalink":"https://www.hessentec.top/2020/07/09/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"桥接模式桥梁模式的重点在解耦。 定义将抽象和实现解耦，使得两者可以独立的变化。它使用了类间的聚合关系、继承、覆写等常用功能。解决了继承的缺点而提出的设计模式。 实现抽象角色引用实现角色，或者说抽象角色的部分实现是由实现角色完成的。 Abstraction抽象化角色，定义出该抽象角色的行为，同时保存一个对实现化角色的引用。 123456789101112131415public abstract class Abstraction&#123; private Implementor imp; //必须指定实现者 public Abstraction(Implementor imp)&#123; this.imp = imp; &#125; public void request()&#123; this.imp.doSomething(); &#125; public Implementor getImp()&#123; return imp; &#125;&#125; RefindAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正。 12345678910111213public class RefindAbstraction extends Abstraction&#123; public RefindAbstraction(Implementor imp)&#123; super(imp); &#125; @Override public void request()&#123; //.... super.request(); super.getImp().doAnyThing(); &#125;&#125; Implementor实现化角色，接口或者抽象类，定义角色必须的行为和属性。 1234public interface Implementor&#123; public void doSomething(); public void doAnyThing();&#125; ConcreteImplementor具体实现化角色，实现接口或者抽象类定义的方法和属性。 12345678910111213141516171819public class ConcreteImplementor1 implements Implementor&#123; public void doSomething()&#123; // &#125; public void doAnyThing()&#123; // &#125;&#125;public class ConcreteImplementor2 implements Implementor&#123; public void doSomething()&#123; // &#125; public void doAnyThing()&#123; // &#125;&#125; Use123Implementor imp = new ConcreteImplementor1();Abstraction abs = new RefindAbstraction(imp);abs.request(); 应用优点 抽象和实现分离为了解决继承的缺点而提出的设计模式，在该模式下，实现可以不受抽象的约束，不再绑定到固定的抽象层次上。 优秀的扩展能力 可以随意增加抽象和实现。 实现细节对客户透明 由抽象层通过聚合关系完成了封装。 使用场景 不希望或者不适用使用继承的场景继承层次太高，无法更细化设计颗粒等场景，需要考虑使用。 接口或者抽象类不稳定的场景接口或者抽象类不稳定，经常变更时，使用桥梁模式。 重用型要求高的场景设计的颗粒度粤西，被重用的可能性越大。采用继承受到父类的限制，不可能出现太细的粒度。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"桥接模式","slug":"桥接模式","permalink":"https://www.hessentec.top/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰器模式","slug":"装饰器模式","date":"2020-07-07T23:55:26.000Z","updated":"2020-07-08T01:01:30.533Z","comments":true,"path":"2020/07/08/装饰器模式/","link":"","permalink":"https://www.hessentec.top/2020/07/08/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰器模式定义动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更加灵活。 实现ComponentComponent 是一个接口或者抽象类，定义需要被装饰的原始类。 123public abstract class Component&#123; public abstract void operate();&#125; Concrete ComponentComponent 的实现类。 12345678public class ConcreteComponent extends Component&#123; @Override public void operate()&#123; //.... &#125;&#125; Decorator抽象类，用于实现接口或者抽象方法。包含被修饰的Componnet属性。 12345678910111213public abstract class Decorator extends Component&#123; private Component component = null; public Decorator(Component c)&#123; this.component = c; &#125; @Override public void operate()&#123; this.component.operate(); &#125;&#125; Concrete Decorator具体装饰角色 1234567891011121314151617181920212223242526public class ConcreteDecorator1 extends Decorator&#123; public ConcreteDecorator1(Component component)&#123; super(component); &#125; private void method1()&#123; //.... &#125; public void operate()&#123; this.method1(); super.operate(); &#125;&#125;public class ConcreteDecorator2 extends Decorator&#123; public ConcreteDecorator2(Component component)&#123; super(component); &#125; private void method2()&#123; //.... &#125; public void operate()&#123; super.operate(); this.method2(); &#125;&#125; Use1234Component c = new ConcreteComponent();c = new ConcreteDecorator1(c);c = new ConcreteDecorator2(c);c.operate(); 应用优点装饰类和被装饰类可以独立发展，而不会相互耦合。装饰模式是继承关系的一个替代方案。装饰模式可以动态地扩展一个实现类的功能。 缺点当装饰多层时导致系统复杂度高。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"https://www.hessentec.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2020-07-06T23:55:34.000Z","updated":"2020-07-07T06:49:10.955Z","comments":true,"path":"2020/07/07/观察者模式/","link":"","permalink":"https://www.hessentec.top/2020/07/07/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式观察者模式也叫发布订阅模式。 定义定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并且被自动更新。 实现Subject定义被观察者必须实现的职责，必须能够动态的增加、取消观察者。它一般是抽象类或者实现类，仅仅完成作为被观察者必须实现的职责，管理观察者并通知观察者。 12345678910111213141516public abstract class Subject&#123; private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;(); public void addObserver(Observer o)&#123; this.obsVector.add(o); &#125; public void delObserver(Observer o)&#123; this.obsVector.remove(o); &#125; public void notifyObservers()&#123; for(Observer o : this.obsVector)&#123; o.update(); &#125;&#125; ConcreteSubject具体的被观察者，定义被观察者自己的业务，同时定义对哪些事件进行通知。 123456public class ConcreteSubject extends Subject&#123; public void doBusiness()&#123; //... super.notifyObservers(); &#125;&#125; Observer观察者接收到消息后，对接收到的信息进行处理。 123public interface Observer&#123; public void update();&#125; ConcreteObserver具体的观察者，不同的观察者在处理消息的时候的具体定义。 12345public class ConcreteObserver implements Observer&#123; public void update()&#123; //do something when invoked. &#125;&#125; Use1234ConcreteSubject subject = new ConcreteSubject();Observer obs = new ConcreteObserver();subject.addObserver(obs);subject.doBusiness(); 应用优点 观察者和被观察之间是抽象耦合如论增加观察者还是被观察者都非常容易扩展 建立了一套规则的触发机制 缺点效率缺陷，考虑采用异步方式通知。 广播链的问题 A -&gt; B -&gt; C 扩展Java中的观察者java 提供了java.util.Observer接口 和 java.util.Observable 类。被观察者继承java.util.Observable， 观察者实现java.util.Observer.但是在生产环境中考虑到性能一般不会用这种方式来实现。 生产中的观察者一般使用MQ来异步处理本地的如Disruptor","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://www.hessentec.top/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring IOC And DI","slug":"Spring-IOC-And-DI","date":"2020-07-06T12:37:14.000Z","updated":"2020-07-14T09:41:06.697Z","comments":true,"path":"2020/07/06/Spring-IOC-And-DI/","link":"","permalink":"https://www.hessentec.top/2020/07/06/Spring-IOC-And-DI/","excerpt":"","text":"IOC 简史 1983年，Richard E.Sweet 在&lt;&gt;提出好莱坞原则（“不要打电话给我，我会打电话给你”）。 1988年，Rolph E.Johnson 和Brian Foote在《Designing Reusable Classes》中提出控制反转。 1996年，Michael Mattson在《Object-Oriented Frameworks, A survey of methodological issues》将控制反转命名为好莱坞原则。 2004，Martin Fowler在《Inversion Of Control Containers and the Dependency Injection pattern》提出自己对和IOC和DI的理解 2005年，Martin Folower在《Inversion Of Control》中对IOC进一步说明。 Martin 大爷关于IOC的说明 IOC 的实现策略WIKI: In object-oriented programming, there are several basic techniques to implement inversion of control. there are: Using a service locator pattern Using dependency injection constructor injection parameter injection setter injection interface injection Using a contextualized lookup. Using template method design pattern Using Strategy design pattern. EXPERT ONE-ON-ONE J2EE DEVELOPMENT without EJB提到的策略：","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.hessentec.top/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"https://www.hessentec.top/tags/IOC/"},{"name":"DI","slug":"DI","permalink":"https://www.hessentec.top/tags/DI/"}]},{"title":"中介者模式","slug":"中介者模式","date":"2020-07-06T09:04:56.000Z","updated":"2020-07-06T11:57:17.039Z","comments":true,"path":"2020/07/06/中介者模式/","link":"","permalink":"https://www.hessentec.top/2020/07/06/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"中介者模式主要为了降低模块内部之间类的相互引用，防止出现系统或者模块内部过度耦合。 中介者模式也叫调停者模式，一个对象要和N个对象交流特别混乱，这个时候加入一个中心，所有的类都和中心交流，这样就变成了星型拓扑结构。 定义用一个中介对象封装一些列的对象交互，中介者使各对象不需要显示地相互调用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 实现Mediator抽象中介者角色，定义统一的接口，用于各同事角色之间的通信。 123456789101112131415public abstract class Mediator&#123; protected ConcreteColleague1 c1; protected ConcreteColleague2 c2; public ConcreteColleague1 getC1()&#123; return c1;&#125; public ConcreteColleague2 getC2()&#123; return c2;&#125; public void setC1(ConcreteColleague1 c1)&#123; this.c1 = c1; &#125; public void setC2(ConcreteColleague2 c2)&#123; this.c2 = c2; &#125; public abstract void doSomething1(); public abstract void doSomething2();&#125; Concrete Mediator具体中介者角色通过协调各同事角色实现协作行为，因为它必须依赖于各个同事角色。 12345678910public class ConcreteMediator extends Mediator&#123; public void doSomething1()&#123; super.c1.selfMethod1(); super.c2.selfMethod2(); &#125; public void doSomething2()&#123; super.c1.selfMethod1(); super.c2.selfMethod2(); &#125;&#125; Colleague同事角色，每个同事角色都知道中介者角色，而且与其他同事角色通信时，一定要通过中介者角色协作。一种是同事本身的行为叫自发行为，比如改变对象本身的状态，处理自己的行为，与其他同事类或者中介者第二种是依赖行为，必须依赖中介者才能完成的行为。 123456public abstract class Colleague&#123; protected Mediator mediator; public Colleague(Mediator mediator)&#123; this.mediator = mediator; &#125;&#125; 123456789101112131415161718192021222324252627public class ConcreteColleague1 extends Colleague&#123; public ConcreteColleague1(Mediator mediator)&#123; super(mediator); &#125; public void selfMethod1()&#123; &#125; public void depMethod1()&#123; super.mediator.doSomething1(); &#125;&#125;public class ConcreteColleague2 extends Colleague&#123; public ConcreteColleague2(Mediator mediator)&#123; super(mediator); &#125; public void selfMethod1()&#123; &#125; public void depMethod1()&#123; super.mediator.doSomething1(); &#125;&#125; 应用优点减少类之间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，同时降低了类之间的耦合。 缺点中介者模式的缺点是中介者会膨胀，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。 应用机场调度中心每一架飞机都和机场调度中心保持联系。 MVC框架Controller做为一个中介者，把Model和View隔离开，协调MV协同工作，把M运行的结果和V代表的视图融合成一个前端可以展示的页面，减少MV的依赖关系。 媒体网关中介服务","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"中介者模式","slug":"中介者模式","permalink":"https://www.hessentec.top/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"空对象模式","slug":"空对象模式","date":"2020-07-05T23:19:23.000Z","updated":"2020-07-05T23:30:41.024Z","comments":true,"path":"2020/07/06/空对象模式/","link":"","permalink":"https://www.hessentec.top/2020/07/06/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"空对象模式空对象模式时通过空代码实现一个接口或者抽象类的所有方法，以满足开发需求，简化程序。 定义通过实现一个默认无意义的对象来避免null值的出现。为了避免程序中出现判断null的情况而产生的。 实现12345678910111213public interface Animal&#123; public void makeSound();&#125;public class Dog implements Animal&#123; public void makeSound()&#123; System.out.println(\"Wang...\"); &#125;&#125;public class NullAnimal import Animal&#123; public void makeSound()&#123;&#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"解释器模式","slug":"解释器模式","permalink":"https://www.hessentec.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"解释器模式","slug":"解释器模式","date":"2020-07-05T01:34:31.000Z","updated":"2020-07-05T02:41:45.084Z","comments":true,"path":"2020/07/05/解释器模式/","link":"","permalink":"https://www.hessentec.top/2020/07/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"解释器模式解释器模式是一种按照规定语法进行解析的方案。 定义给一门语言，定义它的文法的一种表示，并且定义一个解释器，该解释器使用该表示来解释语言中的句子。 比如Java语言，定义文法的表示是Java的语法。javac编译器看作是解释器，解释器用来将Java“解释为” .class 格式的文件。 实现AbstractExpression抽象解释器，抽象解释器通常只有一个方法， 是生成语法集合的关键，每个语法集合完成指定语法的解析任务，通过递归调用的方式，最终由最小的语法但愿进行解析完成。具体的解释任务由各个实现类完成。具体的解释器分别由TerminalExpression和Non-terminalExpression完成。 1234567891011public abstract class Expression &#123; /** * 解析公式和数值，其中var中的key是公式中的参数，value值是具体的数字。 * @param var * @return */ public abstract int interpreter(HashMap&lt;String,Integer&gt; var);&#125; TerminalExpression终结符表达式实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符的表达式，但是有多个实例，对应不同的终结符。表达式中每个终结符都在栈中产生了一个varExpression。 12345678910111213public class VarExpression extends Expression &#123; private String key; public VarExpression(String key) &#123; this.key = key; &#125; @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return var.get(this.key); &#125;&#125; NoneTerminalExpression非终结符表达式文法中每条规则都对应一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类，非终结表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。 1234567891011121314151617181920212223242526272829303132333435public abstract class SymbolExpression extends Expression &#123; protected Expression left; protected Expression right; public SymbolExpression(Expression left, Expression right) &#123; this.left = left; this.right = right; &#125;&#125;public class AddExpression extends SymbolExpression &#123; public AddExpression(Expression left, Expression right) &#123; super(left, right); &#125; @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) + super.right.interpreter(var); &#125;&#125;public class SubExpression extends SymbolExpression &#123; public SubExpression(Expression left, Expression right) &#123; super(left, right); &#125; @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) - super.right.interpreter(var); &#125;&#125; Context环境角色， 1234567891011121314151617181920212223242526272829303132333435public class Calculator &#123; private Expression expression; public Calculator(String expStr) &#123; Stack&lt;Expression&gt; stack = new Stack&lt;&gt;(); char[] charArray = expStr.toCharArray(); Expression left = null; Expression right = null; for (int i = 0; i &lt; charArray.length; i++) &#123; switch (charArray[i]) &#123; case '+': left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new AddExpression(left, right)); break; case '-': left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left, right)); break; default: stack.push(new VarExpression(String.valueOf(charArray[i]))); break; &#125; &#125; this.expression = stack.pop(); &#125; public int run(HashMap&lt;String, Integer&gt; var) &#123; return this.expression.interpreter(var); &#125;&#125; Use123456789101112131415161718192021222324public static void main(String[] args) throws IOException &#123; String expStr = getExpStr(); HashMap&lt;String, Integer&gt; var = getValue(expStr); Calculator calculator = new Calculator(expStr); System.out.println(calculator.run(var));&#125;private static HashMap&lt;String, Integer&gt; getValue(String expStr) throws IOException &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : expStr.toCharArray()) &#123; if (c != '+' &amp; c != '-') &#123; if (!map.containsKey(String.valueOf(c))) &#123; String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); map.put(String.valueOf(c), Integer.valueOf(in)); &#125; &#125; &#125; return map;&#125;private static String getExpStr() throws IOException &#123; System.out.println(\"Input Expression\"); return new BufferedReader(new InputStreamReader(System.in)).readLine();&#125; 应用优点扩展性良好，修改语法规则只需要修改相应的非终结符表达式就可以了。如果扩展语法，则只要增加非终结符类就可以了。 缺点解释器模式会引起类膨胀，每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可以能产生大量的类文件。解释器模式采用递归调用方式，每个表达式需要知道最终的结果，必须一层层递归，无论是面向对象还是面向过程，递归都是在必要条件下才使用，导致调试复杂。 效率问题，解释器模式使用大量的循环和递归，效率时一个很大的问题。 使用场景重复发生的问题可以解释器模式，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素相同，按照解释器模式终结符表达式相同，非终结符表达式需要定制。 一个简单语法需要解释的场景，解释器模式一般用来解析表标准的字符集，如SQL语法分析。 注意事项尽量不要在重要的模块中使用解释器模式，维护成本太高。尽量使用shell、JRuby、Groovy来替代。 扩展成熟的工具Expression4JMESP: Math Expression String Parser、Jep.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"解释器模式","slug":"解释器模式","permalink":"https://www.hessentec.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"备忘录模式","slug":"备忘录模式","date":"2020-07-03T22:57:09.000Z","updated":"2020-07-04T00:52:36.954Z","comments":true,"path":"2020/07/04/备忘录模式/","link":"","permalink":"https://www.hessentec.top/2020/07/04/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"备忘录模式定义在不破坏封装性的前提下，捕获一个对象的内部状态，并在该状态之外保存这个状态。这样以后就可以将该状态恢复到原来保存的状态。 实现Originator发起人角色，记录当前时刻的内部状态，负责定义哪些属性备份范围的状态，负责创建和恢复备忘录数据。 1234567891011121314151617181920212223242526272829303132public class Boy &#123; private String state = \"\"; public void change()&#123; this.state = \" I Am So Sad.\"; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; /** * 可以创建多个备份 * @return */ public Memento createMemento()&#123; return new Memento(this.state); &#125; /** * 可以选择任意的备份进行恢复 * @param memento */ public void restore(Memento memento)&#123; this.setState(memento.getState()); &#125;&#125; Memento备忘录角色，负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。 12345678910111213141516public class Memento &#123; private String state = \"\"; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; Caretaker备忘录管理员角色，对备忘录进行管理、保存和提供备忘录。 123456789101112public class Caretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125; Use123456789Caretaker caretaker = new Caretaker();caretaker.setMemento(boy.createMemento());System.out.println(\"Now Boy Is : \" + boy.getState());boy.change();System.out.println(\"Now Boy Is : \" + boy.getState());boy.restore(caretaker.getMemento());System.out.println(\"Now Boy Is : \" + boy.getState()); 使用场景 需要保存和恢复数据的相关状态场景 提供一个可回滚的操作 需要监控的副本场景中 数据库连接的事务管理 注意事项 备忘录的生命周期主动管理备忘录的生命周期，不实用就需要立即删除其引用。 备忘录的性能要控制备忘录的历史记录数量，以及大对象的备忘录。 扩展Clone方式的备忘录123456789101112131415161718192021222324252627282930public class Originator implements Cloneable &#123; private String state = \"\"; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Originator createMemento()&#123; return this.clone(); &#125; public void restoreMemento(Originator originator)&#123; this.setState(originator.getState()); &#125; @Override protected Originator clone() &#123; try &#123; return (Originator)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 123456789101112public class Caretaker &#123; private Originator originator; public Originator getOriginator() &#123; return originator; &#125; public void setOriginator(Originator originator) &#123; this.originator = originator; &#125;&#125; 多状态的备忘录模式把整个对象转换成Map，当然也可以序列化、或者直接复制整个对象。 12345678910111213141516public class Memento &#123; private HashMap&lt;String,Object&gt; stateMap; public Memento(HashMap&lt;String, Object&gt; stateMap) &#123; this.stateMap = stateMap; &#125; public HashMap&lt;String, Object&gt; getStateMap() &#123; return stateMap; &#125; public void setStateMap(HashMap&lt;String, Object&gt; stateMap) &#123; this.stateMap = stateMap; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.beans.BeanInfo;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Method;import java.util.HashMap;public class BeanUtils &#123; public static HashMap&lt;String,Object&gt; backupProp(Object bean)&#123; HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;(); try&#123; BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; String fieldName = descriptor.getName(); Method getter = descriptor.getReadMethod(); Object fieldValue = getter.invoke(bean, new Object[]&#123;&#125;); if (!fieldName.equalsIgnoreCase(\"class\"))&#123; result.put(fieldName, fieldValue); &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; public static void restoreProp(Object bean, HashMap&lt;String,Object&gt; propMap)&#123; try&#123; BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; String fieldName = descriptor.getName(); if (propMap.containsKey(fieldName))&#123; Method setter = descriptor.getWriteMethod(); setter.invoke(bean, new Object[]&#123;propMap.get(fieldName)&#125;); &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public class Originator &#123; private String state1 = \"\"; private String state2 = \"\"; private String state3 = \"\"; public String getState1() &#123; return state1; &#125; public void setState1(String state1) &#123; this.state1 = state1; &#125; public String getState2() &#123; return state2; &#125; public void setState2(String state2) &#123; this.state2 = state2; &#125; public String getState3() &#123; return state3; &#125; public void setState3(String state3) &#123; this.state3 = state3; &#125; public Memento createMemento()&#123; return new Memento(BeanUtils.backupProp(this)); &#125; public void restoreMemento(Memento memento)&#123; BeanUtils.restoreProp(this, memento.getStateMap()); &#125;&#125; 多备份的备忘录12345678910111213141516public class Caretaker &#123; Map&lt;String, Memento&gt; map = new LinkedHashMap&lt;&gt;(); public void backup(String version, Memento memento)&#123; map.put(version, memento); &#125; public Memento get(String version)&#123; return map.get(version); &#125; public Map&lt;String,Memento&gt; getAll()&#123; return this.map; &#125;&#125; 优雅的实现Bean 对象专注自己的业务，不需要关心备份和恢复业务。 123456789101112131415161718192021222324252627public class Original implements Cloneable &#123; private String state; private String info; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 备份管理员负责版本的备份与恢复工作，职责明晰。同时要注意历史版本次数，防止版本过多。 1234567891011121314151617181920212223public class Caretacker &#123; private int size = 10; private Map&lt;String, Original&gt; histo = new LinkedHashMap&lt;&gt;(); public boolean backup(String key, Original o) &#123; if (histo.size() &gt;= 10) &#123; return false; &#125; try&#123; histo.put(key,(Original) o.clone() ); &#125;catch (Exception e)&#123; e.printStackTrace(); return false; &#125; return true; &#125; public Original get(String k) &#123; return histo.get(k); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"责任链模式","slug":"责任链模式","permalink":"https://www.hessentec.top/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring 总览","slug":"Spring-总览","date":"2020-07-03T12:32:28.000Z","updated":"2020-07-06T12:37:57.022Z","comments":true,"path":"2020/07/03/Spring-总览/","link":"","permalink":"https://www.hessentec.top/2020/07/03/Spring-%E6%80%BB%E8%A7%88/","excerpt":"","text":"Spring相关内容来源于Spring官方网站与Spring源码。 Spring 5.2.7 Spring框架为企业级应用提供了一个完整的配置开发模型，可以在任何类型的发布平台。Spring专注于企业应用的管道，保证开发团队专注于企业的业务逻辑，而不需要关注发布平台。 功能核心技术 Dependency Injection依赖注入 events 事件 resources 资源管理 i18n 国际化 validation 校验 data binding 数据绑定 type conversion 类型转换 SpEL AOP Aspect Oriented Programming 面向切面编程 测试 Mock Objects: 模拟对象 TestContext framework: 测试上下文框架 Spring MVC Test: MVC测试框架 WebTestClient: web测试客户端 DataAccess transactions: 事务 DAO Support: DAO 支持 JDBC: ORM： Marshalling XML Spring MVCSpring WebFluxIntegration remoting JMS JCA JMX email tasks scheduling cache Languages Kotlin Groovy dynamic languages.","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"}],"tags":[]},{"title":"命令模式","slug":"命令模式","date":"2020-07-03T07:17:03.000Z","updated":"2020-07-03T22:54:03.358Z","comments":true,"path":"2020/07/03/命令模式/","link":"","permalink":"https://www.hessentec.top/2020/07/03/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"命令模式命令模式的封装性非常好，把请求方（Invoker）和执行方（Receiver）分开，扩展性也非常好。 定义将一个请求封装成一个对象，从而使得不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 实现Receiver抽象接收者，定义每个接收者都必须完成的业务。 123public abstract class Receiver&#123; public abstract void doSomething();&#125; 具体的Receiver 1234567public class Concrete1Reveiver extends Receiver&#123; public void doSomething()&#123;&#125;&#125;public class Concrete2Reveiver extends Receiver&#123; public void doSomething()&#123;&#125;&#125; Command不同的命令实现都需要继承该类，实现自己的execute逻辑。 123public abstract class Command&#123; public abstract void execute();&#125; 具体的命令实现类 12345678910111213141516171819public class ConcreteCommand1 extends Command&#123; private Receiver receiver; public ConcreteCommand1(Receiver receiver)&#123; this.receiver = receiver; &#125; public void execute()&#123; this.receiver.doSomething(); &#125;&#125;public class ConcreteCommand2 extends Command&#123; private Receiver receiver; public ConcreteCommand2(Receiver receiver)&#123; this.receiver = receiver; &#125; public void execute()&#123; this.receiver.doSomething(); &#125;&#125; Invoker123456789public class Invoker&#123; private Command command; public void setCommand(Command command)&#123; this.command = command; &#125; public void action()&#123; this.command.execute(); &#125;&#125; Use123Invoker invoker = new Invoker();invoker.setCommand(new ConcreteCommand1(new Concrete1Reveiver()));invoker.action(); 模式应用优点 解耦调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法即可，不需要了解是哪个接收者执行。 可扩展性好Command子类可以非常容易的扩展，调用者Invoker和高层的模块Client不产生严重的代码耦合。 与其他模式混合使用与责任链模式结合，实现命令族解析任务与模版方法结合，减少Command子类膨胀的问题。 缺点Command的子类会随着命令的增多逐步膨胀。 命令的撤销反命令通过相反的命令来实现命令的撤销。 结合备忘录模式结合备忘录模式还原最后状态，折中发昂发适合接收者为状态的变更情况，而不适合事件处理。 代码实例假设有个录音机，录音机面板有三个按钮， play， rewind， stop。 需要根据三个按钮作出相应的反馈。 Receiver1234567891011121314public class AudioPlayer &#123; public void paly()&#123; System.out.println(\"Play\"); &#125; public void rewind()&#123; System.out.println(\"Rewind\"); &#125; public void stop()&#123; System.out.println(\"Stop\"); &#125;&#125; Command不同的Command调用不同的Receiver命令。 12345678910111213141516171819202122232425262728public abstract class Command &#123; protected static AudioPlayer audioPlayer = new AudioPlayer(); public abstract void execute();&#125;public class PlayCommand extends Command &#123; @Override public void execute() &#123; super.audioPlayer.paly(); &#125;&#125;public class RewindCommand extends Command &#123; @Override public void execute() &#123; audioPlayer.rewind(); &#125;&#125;public class StopCommand extends Command &#123; @Override public void execute() &#123; audioPlayer.stop(); &#125;&#125; Invoker用于转发Command 1234567891011public class KeyPad &#123; private Command command; public void setCommand(Command command) &#123; this.command = command; &#125; public void action() &#123; this.command.execute(); &#125;&#125; Use1234567KeyPad keyPad = new KeyPad();keyPad.setCommand(new RewindCommand());keyPad.action();keyPad.setCommand(new StopCommand());keyPad.action(); 如果后期需要增加一个按钮，stopAndRewind()，直接增加一个Command子类即可，其他地方不需要动。 12345678public class StopAndRewindCommand extends Command &#123; @Override public void execute() &#123; audioPlayer.stop(); audioPlayer.rewind(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"责任链模式","slug":"责任链模式","permalink":"https://www.hessentec.top/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"}]},{"title":"模版方法模式","slug":"模版方法模式","date":"2020-07-02T07:04:59.000Z","updated":"2020-07-02T07:40:55.545Z","comments":true,"path":"2020/07/02/模版方法模式/","link":"","permalink":"https://www.hessentec.top/2020/07/02/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模版方法模式抽象类定义一组方法的执行顺序，具体的功能由子类来实现。它仅仅使用了Java的继承机制，但使用非常广泛。一般多个子类有公有的方法，并且逻辑基本相同的时候使用。 定义定义一个操作中的算法框架，再将一些步骤延迟到子类中。使得子类可以不改变算法的结构就可以定义该算法的某些特定步骤。 实现基本方法一些基本的操作，由子类实现具体的逻辑，在模版方法中被调用。 模版方法模版方法可以有一个或者多个，一般是一个具体的方法，包含了基本方法的调用逻辑。 抽象模版类中包含了一个模版方法goToSchool和三个基本方法toSchool, study, goHome.这样，每个学生继承该抽象类实现自己逻辑即可。 123456789101112131415public abstract class StudentBehavor&#123; protected abstract void toSchool(); protected abstract void study(); protected abstract void goHome(); public void goToSchool()&#123; //do something. toSchool(); // do something. study(); // do something. goHome(); // do something. &#125;&#125; 应用优点 封装不变部分，扩展可变部分把认为不变的部分算法封装到父类实现，可变部分通过继承来扩展。 提取公共部分代码，便于维护 行为由父类控制，子类实现基本方法由子类实现，子类可以扩展增加相应的功能，符合开闭原则。 缺点在复杂的项目中，增加代码的阅读难度。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"模版方法模式","slug":"模版方法模式","permalink":"https://www.hessentec.top/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"责任链模式","date":"2020-07-02T03:21:45.000Z","updated":"2020-07-02T06:23:35.810Z","comments":true,"path":"2020/07/02/责任链模式/","link":"","permalink":"https://www.hessentec.top/2020/07/02/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"责任链模式责任链模式的核心在链上， 链是有多个处理者组成的。就像流水线上的质检员。 定义使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 实现抽象事件抽象事件类型表明这类型的事件是需要被处理的。 123public interface IEvent &#123; int getType();&#125; 具体的事件不同类型的子类事件。 123456789101112131415public class EventClick implements IEvent &#123; public int getType() &#123; return 1; &#125;&#125;public class EventEnter implements IEvent &#123; public int getType() &#123; return 2; &#125;&#125;public class EventBlank implements IEvent &#123; public int getType() &#123; return 3; &#125;&#125; 抽象的事件处理器定义了只有Ievent类型的事件会被处理。 123public interface IEventHandler &#123; boolean check(IEvent event);&#125; 具体的事件处理器12345678910111213141516171819202122232425262728293031323334public class ClickEventHandler implements IEventHandler &#123; public boolean check(IEvent event) &#123; if (event.getType() != 1)&#123; return false; &#125; System.out.println(\"Father check Ok. \"); return true; &#125;&#125;public class EnterEventHandler implements IEventHandler &#123; public boolean check(IEvent event) &#123; if (event.getType() == 2) &#123; System.out.println(\"Husband Ok.\"); return true; &#125; return false; &#125;&#125;public class BlankEventHandler implements IEventHandler &#123; public boolean check(IEvent event) &#123; if (event.getType() != 3) &#123; return false; &#125; System.out.println(\"Son Ok\"); return true; &#125;&#125; 事件处理链用于组织事件处理器，符合条件的处理器处理完成后或者没有处理器处理都会停止。 123456789101112131415public class EventHandlerChain &#123; private List&lt;IEventHandler&gt; eventChains = new ArrayList&lt;IEventHandler&gt;(); public void add(IEventHandler eventHandler) &#123; eventChains.add(eventHandler); &#125; public boolean check(IEvent event) &#123; for (IEventHandler eventChain : this.eventChains) &#123; if (eventChain.check(event)) &#123; return true; &#125; &#125; return false; &#125;&#125; Use可以随意组织责任链的顺序，然后检查需要检查的类型。 12345678EventHandlerChain chain = new EventHandlerChain();chain.add(new ClickEventHandler());chain.add(new EnterEventHandler());chain.add(new BlankEventHandler());chain.check(new EventClick());chain.check(new EventEnter());chain.check(new EventBlank()); 应用优点将请求和处理分开。请求着可以不用知道是谁处理的，处理者可以不用知道请求着的全貌。两者解耦，提高了系统的灵活性。 缺点性能问题， 最差的情况下，请求从头遍历到尾，链条特别长的时候，性能损耗是个大的问题。因此在使用的过程中要注意责任链的长短。调试不方便。 在广告系统中，由不同的事件来触发不同类型的广告时根据责任链模式来处理。每个Handler可以专注自己的业务处理逻辑。具体Handler还可以抽象一个抽象类，把公用的逻辑写在抽象类里面，每个具体的实现类只负责业务的处理即可（优化为模版方法模式）。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"责任链模式","slug":"责任链模式","permalink":"https://www.hessentec.top/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"}]},{"title":"迭代器模式","slug":"迭代器模式","date":"2020-07-01T13:00:53.000Z","updated":"2020-07-01T14:34:35.764Z","comments":true,"path":"2020/07/01/迭代器模式/","link":"","permalink":"https://www.hessentec.top/2020/07/01/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"迭代器模式迭代器模式提供了遍历容器的方便性，容器只要管理增减元素即可，需要遍历的时候交由迭代器进行。 比如Set、Map、List等容器的iterator。 定义迭代器是为容器服务的，它提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。 实现Iterator抽象迭代器负责定义访问和遍历元素的接口。first() 获取第一个元素；next() 访问下一个元素；hasNext() 是否还有下一个； 12345public interface Iterator&lt;E&gt;&#123; E next(); boolean hasNext(); boolean remove();&#125; ConcreteIterator具体迭代器要实现迭代器接口，完成容器元素的遍历。 12345678910111213141516171819public class ConcreteIterator implements Iterator&lt;E&gt;&#123; private Vector&lt;E&gt; v = new Vector&lt;&gt;(); public int cursor = 0; public ConcreteIterator(Vector _vector)&#123; this.v = _vector; &#125; public boolean hasNext()&#123; return this.cursor != this.v.size(); &#125; public E next()&#123; return this.hasNext() ? this.v.get(this.cursor++) : null; &#125; public boolean remove()&#123; this.v.remove(this.cursor); return true; &#125;&#125; Aggregate抽象容器角色负责提供创建具体迭代器角色的接口， 必然提供一个类似于createIterator（）的方法。 12345public interface Aggregate&lt;E&gt;&#123; void add(E e); void remove(E e); Iterator iterator();&#125; Concrete Aggregate具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。 123456789101112public class ConcreteAggrate implements Aggregate&lt;E&gt;&#123; Vector v = new Vector(); public void add(E e)&#123; this.add(e); &#125; public Iterator&lt;E&gt; iterator()&#123; return new ConcreteIterator&lt;&gt;(this.v); &#125; public void remove(E e)&#123; this.remove(e); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"https://www.hessentec.top/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"组合模式","date":"2020-07-01T11:38:46.000Z","updated":"2020-07-09T10:15:53.150Z","comments":true,"path":"2020/07/01/组合模式/","link":"","permalink":"https://www.hessentec.top/2020/07/01/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"组合模式也叫合成模式或者部分整体模式，主要用来描述部分与整体的关系。 定义将对象组合成树形结构以表示部分整体的层次结构，使得用于对单个对象和组合对象的使用具有一致性。 Component定义参加组合对象的共有方法和属性，可以定义一些默认的行为或者属性。 1234567891011121314151617181920public abstract class Component&#123; private Component parent = null; private ArrayList&lt;Component&gt; list = new ArrayList&lt;&gt;(); public void add(Component c)&#123; c.parent = this; this.list.add(c); &#125; public void remove(Component c)&#123; this.list.remove(c); &#125; public List&lt;Component&gt; getChildren()&#123; return this.list; &#125; public Component getParent()&#123; return this.parent; &#125;&#125; Composite树枝对象，作用是组合树枝节点和叶子结点形成一个树形结构。 123public class Composite extends Component&#123;&#125; Leaf叶子对象，下面没有分支，最小的遍历单位。 123public class Leaf extends Component&#123;&#125; 应用优点 高层模块调用简单一颗属性结构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，也就是说高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。 节点自由度增加使用组合模式后，如果想增加一个树枝节点、树叶节点都非常容易。如何开闭原则，利于维护。 缺点（安全模式）直接使用了实现类(可以扩展)。与依赖倒置原则冲突，限制了接口的影响范围。 扩展透明的组合模式以上的例子就是透明的组合模式，吧用来组合使用的方法放到抽象类中，无论叶子对象还是树枝对象都有相同的结构，通过getChildren();判断当前节点是否为叶子节点还是根节点。 透明模式的好处是遵循了依赖倒置原则 安全的组合模式安全模式是将叶子节点和树枝节点彻底分开，树枝节点单独拥有用来组合的方法。 Component定义参加组合对象的共有方法和属性，可以定义一些默认的行为或者属性。 123456public abstract class Component&#123; private Component parent = null; public Component getParent()&#123; return this.parent; &#125;&#125; Composite树枝对象，作用是组合树枝节点和叶子结点形成一个树形结构。 123456789101112131415public class Composite extends Component&#123; private ArrayList&lt;Component&gt; list = new ArrayList&lt;&gt;(); public void add(Component c)&#123; c.parent = this; this.list.add(c); &#125; public void remove(Component c)&#123; this.list.remove(c); &#125; public List&lt;Component&gt; getChildren()&#123; return this.list; &#125;&#125; Leaf叶子对象，下面没有分支，最小的遍历单位。 123public class Leaf extends Component&#123;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"组合模式","slug":"组合模式","permalink":"https://www.hessentec.top/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"}]},{"title":"访问者模式","slug":"访问者模式","date":"2020-06-30T11:39:35.000Z","updated":"2020-06-30T13:46:56.160Z","comments":true,"path":"2020/06/30/访问者模式/","link":"","permalink":"https://www.hessentec.top/2020/06/30/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"访问者模式访问者模式是一种集中规整模式，适合用于重构项目时（重构时需求已经清晰，原有的功能点也明确）通过访问者模式可以很容易达到功能集中化。还可以与其他模式混编建立一套自己的过滤器和拦截器。 定义封装一些用于某种数据结构中的各个元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的新操作。 角色Visitor 抽象访问者抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。 1234public interface IVisitor&#123; public void visit(ConcreteElement1 el1); public void visit(ConcreteElement2 el2);&#125; ConcreteVisitor 具体访问者影响访问者访问到一个类后该做什么事情。 12345678public class Visitor implements IVisitor&#123; public void visit(ConcreteElement1 el1)&#123; el1.doSomething(); &#125; public void visit(ConcreteElement2 el2)&#123; el2.doSomething(); &#125;&#125; Element 抽象元素接口或者抽象类，声明接受哪一类访问者访问。抽象元素有两类方法， 一类是本身的业务逻辑。另一类是允许访问者来访问的方法。 123456public abstract class Element&#123; //业务逻辑 public abstract void doSomething(); //接受访问者 public abstract void accept(IVisitor visitor);&#125; ConcreteElement 具体元素实现accept方法， 通常是 visitor.visit(this)模式。 123456789101112public class ConcreteElement1 extends Element&#123; public void doSomething()&#123;&#125; public void accept(IVisitor visitor)&#123; visitor.visit(this); &#125;&#125;public class ConcreteElement2 extends Element&#123; public void doSomething()&#123;&#125; public void accept(IVisitor visitor)&#123; visitor.visit(this); &#125;&#125; ObjectStructure结构对象元素生产者，一般容纳在多个不同类、不同接口的容器，如List/Set/Map。 12345public class ObjectStructure&#123; public static Element createElement()&#123; return new Random().nextInt(10) &gt; 5 ? new ConcreteElement1() : new ConcreteElement2(); &#125;&#125; 使用123for(int i = 0; i &lt; 10 ; i++)&#123; ObjectStructure.createElement().accept(new Visitor());&#125; 优点 符合单一职责原则 优秀的扩展性 灵活 缺点 违背了迪米特法则，Element具体的细节需要公布给Visitor 具体元素变更比较困难，元素增加/减少字段Visitor都需要修改 违背了依赖倒置原则，访问者依赖的是具体的元素，而不是抽象元素。 使用场景当一个对象结构包含很多类对象，它们有不同的接口，需要对这些对象实施一些依赖于其具体类的操作。 双分派1234567891011121314151617181920public abstract class AbsActor&#123; public void act(Role role)&#123; System.out.println(\"Actor can act any role.\"); &#125; public void act(KungFuRole role)&#123; System.out.println(\"Actor can act Kungfu Role.\"); &#125;&#125;public class YongActor extends AbsActor&#123; public void act(KungFuRole role)&#123; System.out.println(\"Yong Man Lov Act KungFu Role.\"); &#125;&#125;public class OldActor extends AbsActor&#123; public void act(KungFuRole role)&#123; System.out.println(\"Old Man Can Not Act KungFu Role.\") &#125;&#125; 12345678910111213public interface Role&#123; public void accept(AbsActor actor);&#125;public class KungFuRole extends Role&#123; public void accept(AbsActor actor)&#123; actor.act(this); &#125;&#125;public class IdiotRole extends Role&#123; public void accept(AbsActor actor)&#123; actor.act(this); &#125;&#125; 1234AbsActor actor = new OldActor();Role role = new KungFuRole();actor.act(role); //oldActor.act(Role)actor.act(new KungFuRole()); //oldActor.act(KungFuRole); 1234AbsActor actor = new OldActor();Role role = new KungFuRole();role.accept(actor); //KungFuRole.accept(OldActor); //OldActor.act(KungFuRole)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"访问者模式","slug":"访问者模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"状态模式","slug":"状态模式","date":"2020-06-29T12:18:02.000Z","updated":"2020-07-03T05:38:52.332Z","comments":true,"path":"2020/06/29/状态模式/","link":"","permalink":"https://www.hessentec.top/2020/06/29/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"状态模式在状态模式中， 类的行为时给予它的状态改变的。折中类型的设计模式属于行为型模式。 定义当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 实现抽象状态角色State接口或者抽象类，负责对象状态的定义，并且封装环境角色以实现状态切换。 12345678910111213public interface IState &#123; void open(); void close(); void run(); void stop();&#125;public abstract class BaseState implements IState &#123; protected Car context; public void setContext(Car context) &#123; this.context = context; &#125;&#125; 具体状态角色ConcreteState每个具体状态必须完成两个职责：本状态下要做的事情以及本状态如何过渡到其他状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class OpenState extends BaseState &#123; public void open() &#123; super.context.setCurrentState(Car.OPEN_STATE); System.out.println(\"车门已开启\"); &#125; public void close() &#123; super.context.setCurrentState(Car.CLOSE_STATE); System.out.println(\"关闭车门。。。\"); &#125; public void run() &#123; System.out.println(\"开门状态下不允许飙车start\"); &#125; public void stop() &#123; System.out.println(\"开门状态下不允许飙车Stop\"); &#125;&#125;public class StopState extends BaseState &#123; public void open() &#123; super.context.setCurrentState(Car.OPEN_STATE); System.out.println(\"停车后开启车门\"); &#125; public void close() &#123; super.context.setCurrentState(Car.CLOSE_STATE); System.out.println(\"停车后关闭车门\"); &#125; public void run() &#123; super.context.setCurrentState(Car.RUN_STATE); System.out.println(\"停车后再次跑起来\"); &#125; public void stop() &#123; super.context.setCurrentState(Car.STOP_STATE); System.out.println(\"停车后。。停止不同\"); &#125;&#125;public class RunState extends BaseState &#123; public void open() &#123; System.out.println(\"飙车时不能开门\"); &#125; public void close() &#123; System.out.println(\"飙车时车门已关闭\"); &#125; public void run() &#123; super.context.setCurrentState(Car.RUN_STATE); System.out.println(\"飙车Run\"); &#125; public void stop() &#123; super.context.setCurrentState(Car.STOP_STATE); System.out.println(\"飙车 stop\"); &#125;&#125;public class CloseState extends BaseState &#123; public void open() &#123; super.context.setCurrentState(Car.OPEN_STATE); System.out.println(\"开启车门。。。\"); &#125; public void close() &#123; System.out.println(\"车门已经关闭！\"); &#125; public void run() &#123; this.context.setCurrentState(Car.RUN_STATE); System.out.println(\"汽车开始运行。。。\"); &#125; public void stop() &#123; this.context.setCurrentState(Car.STOP_STATE); System.out.println(\"汽车停止。\"); &#125;&#125; 环境角色Context定义客户端需要的接口，并且负责具体状态的切换。 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。 12345678910111213141516171819202122232425262728293031public class Car implements IState &#123; public static final BaseState OPEN_STATE = new OpenState(); public static final BaseState CLOSE_STATE = new CloseState(); public static final BaseState RUN_STATE = new RunState(); public static final BaseState STOP_STATE = new StopState(); private BaseState currentState; public Car() &#123; this.setCurrentState(CLOSE_STATE); &#125; public BaseState getCurrentState() &#123; return currentState; &#125; public Car setCurrentState(BaseState currentState) &#123; this.currentState = currentState; this.currentState.setContext(this); return this; &#125; public void open() &#123; this.currentState.open(); &#125; public void close() &#123; this.currentState.close(); &#125; public void run() &#123; this.currentState.run(); &#125; public void stop() &#123; this.currentState.stop(); &#125;&#125; 使用结合建造者模式将已有的状态按照一定的顺序再重新组装。 1234567891011121314Car car = new Car();car.setCurrentState(Car.CLOSE_STATE);car.run(); //汽车开始运行。。。car.stop(); //飙车 stopcar.run(); //停车后再次跑起来car.open(); //飙车时不能开门car.stop(); //飙车 stopcar.open(); //停车后开启车门car.close(); //关闭车门。。。 应用优点 结构清晰避免过多的switch case和if else，降低了程序的复杂性，提高系统的可维护性。 遵循设计原则遵循了开闭原则以及单一职责原则，每个状态都是一个子类，要增加状态就要增加子类，修改状态时只修改一个子类即可。 封装性良好状态变换防止到类的内部来实现，外部调用不需要知道类内部如何实现状态和行为的变换。 缺点 状态过多时子类膨胀 使用场景 行为跟随状态改变而改变的场景 条件、分支判断语句的替代","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"状态模式","slug":"状态模式","permalink":"https://www.hessentec.top/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式","slug":"代理模式","date":"2020-06-28T12:25:10.000Z","updated":"2020-07-15T09:36:32.266Z","comments":true,"path":"2020/06/28/代理模式/","link":"","permalink":"https://www.hessentec.top/2020/06/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式代理模式也叫委托模式，许多其他的模式如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了代理模式。在日常应用中，代理模式可以提供非常好的访问控制。 定义为其他对象提供一种代理以控制这个对象的访问。 比如，我们的DB的访问权限不能直接公开，一般会公开一个接口来提供对这些数据。 实现抽象主题Subject可以是抽象类或者接口，普通的业务类型定义。 123public interface Subject&#123; public void request();&#125; 具体主题RealSubject委托角色或者被代理角色。业务逻辑的具体执行者。 12345public class RealSubject implements Subject&#123; public void request()&#123; //do something. &#125;&#125; 代理主题Proxy代理类、委托类， 负责对真实角色的调用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。 123456789101112131415161718192021222324public class Proxy implements Subject&#123; private Subject subject = null; public Proxy()&#123; this.subject = new Proxy(); &#125; public Proxy(Subject subject)&#123; this.subject = subject; &#125; public void request()&#123; this.before(); this.subject.request(); this.after(); &#125; private void before()&#123; //before &#125; private void after()&#123; //after. &#125;&#125; 应用优点 职责清晰真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事物，通过后期的代理完成一件事物，附带的结果就是编程简洁清晰。 扩展性好具体主题角色是随时都会发生变化的，只要它实现了接口，代理类可以在不做任何修改的情况下使用。 智能化用于动态代理。 扩展普通代理客户端只能访问代理角色，而不能访问真实角色。屏蔽了真实角色的变更对高层模块的影响。该模式适合对扩展性要求较高的场合。一般通过编程规范类约束来禁止new一个真实的角色。 这种方式调用者只需要知道代理即可， 不需要知道代理了谁。 普通代理的实现者： 123456789101112public class GamePlayer implements IGamePlayer&#123; private String name = \"\"; public GamePlayer(IGamePlayer _gamePlayer, String _name)throws Exception&#123; if(_gamePlayer == null || !(_gamePlayer instanceof GameProxy))&#123; throw new Exception(\"Create Not Allowed!\"); &#125; this.name = _name; &#125; public void killMonster()&#123; //do... &#125;&#125; 普通代理的代理者： 1234567891011121314public class GamePlayerProxy implements IGamePlayer&#123; private IGamePlayer gamePlayer = null; public GamePlayerProxy(String name)&#123; try&#123; gamePlayer = new GamePlayer(this,name); &#125;catch(Exception e)&#123; //TODO &#125; &#125; public void killMonster()&#123; this.gamePlayer.killMonster(); &#125;&#125; 强制代理只有通过真实角色指定的代理类才可以访问。 1234public interface IGamePlayer&#123; void killMonster(); public IGamePlayer getProxy();&#125; 1234567891011121314public class GamePlayer implements IGamePlayer&#123; private String name = \"\"; private IGamePlayer proxy = null; public GamePlayer(String _name)&#123; this.name = _name; this.proxy = new GamepPlayerProxy(this); &#125; public IGamePlayer getProxy()&#123; return this.proxy; &#125; public void killMonster()&#123; //do... &#125;&#125; 123456789public class GamePlayerProxy implements IGamePlayer&#123; private IGamePlayer gamePlayer = null; public GamePlayerProxy(IGamePlayer _gamePlayer)&#123; this.gamePlayer = _gamePlayer; &#125; public void killMonster()&#123; this.gamePlayer.killMonster(); &#125;&#125; 动态代理在实现阶段不需要关心代理谁， 在运行阶段才指定代理哪个对象。 通过InvocationHandler接口，所有方法都由该Handler来接管实际的业务处理。 在不改变已有代码结构的情况下增强或者控制对象的行为。 动态代理Handler类： 123456789public class MyInvocationHandler implements InvocationHandler&#123; private Object target = null; public MyInvocationHandler(Object _obj)&#123; this.target = _obj; &#125; public Object invoke(Object proxy, Method method, Object[] args)throws Throwable&#123; return method.invoke(this.target, args); &#125;&#125; 通知接口与实现 12345678public interface IAdvice&#123; public void exec();&#125;public class BeforeAdvice implements IAdvice&#123; public void exec()&#123; //.... &#125;&#125; 动态代理类： 12345678public class DynamicProxy&lt;T&gt;&#123; public static &lt;T&gt; T newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)&#123; if(condition)&#123; //在condition连接点执行BeforeAdvice通知。 (new BeforeAdvice()).exec(); &#125; return (T)Proxy.newProxyInstance(loader, interface, h); &#125;&#125; Client: 1234Subject subject = new RealSubject();InvocationHandler handler = new MyInvocationHandler(subject);Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), handler);proxy.killMonster(); 扩展 CGLib 12345678910public class LogInterceptor implements MethodInterceptor &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"Before Interceptor1\"); Object result = methodProxy.invokeSuper(o, objects); System.out.println(\"After Interceptor1\"); return result; &#125;&#125; 12345678910public class LogInterceptor2 implements MethodInterceptor &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"Before Interceptor2\"); Object result = methodProxy.invokeSuper(o, objects); System.out.println(\"After Interceptor2\"); return result; &#125;&#125; 123456789101112public class LogCallBackFilter implements CallbackFilter &#123; public int accept(Method method) &#123; if (\"upgrade\".equals(method.getName()))&#123; System.out.println(\"Upgrade Filter\"); return 0; &#125; System.out.println(\"Kill Monster Filter\"); return 1; &#125;&#125; 1234567891011121314LogInterceptor logInterceptor = new LogInterceptor();LogInterceptor2 logInterceptor2 = new LogInterceptor2();Enhancer enhancer = new Enhancer();enhancer.setSuperclass(GamePlayer.class);enhancer.setCallbacks(new Callback[]&#123;logInterceptor,logInterceptor2, NoOp.INSTANCE&#125;);enhancer.setCallbackFilter(new LogCallBackFilter());IGamePlayer gamePlayer = (IGamePlayer)enhancer.create(new Class[]&#123;String.class&#125;, new Object[]&#123;\"Lisi\"&#125;);gamePlayer.killMonster();gamePlayer.upgrade(); ASM AOP 扩展阅读cglib动态代理、asm学习笔记 Java动态代理详解","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"https://www.hessentec.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]},{"title":"策略模式","slug":"策略模式","date":"2020-06-28T10:41:18.000Z","updated":"2020-06-29T14:33:58.285Z","comments":true,"path":"2020/06/28/策略模式/","link":"","permalink":"https://www.hessentec.top/2020/06/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式策略模式使用的就是面向对象的继承和多态机制。 定义定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 实现Strategy 抽象策略角色策略算法的抽象，通常是接口，定义每个策略或者算法必须具有的方法和属性。 123public interface Strategy&#123; void doSomething();&#125; ConcreteStrategy 具体策略角色实现抽象策略的具体算法。 1234567891011public class ConcreteStrategy1 implements Strategy&#123; public void doSomething()&#123; //Do Strategy1. &#125;&#125;public class ConcreteStrategy2 implements Strategy&#123; public void doSomething()&#123; //Do Strategy2. &#125;&#125; Context 封装角色封装上下文，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。策略模式的重点就是封装角色，它借用了代理模式的思路。 123456789public class Context&#123; private Strategy strategy = null; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public void doAny()&#123; this.strategy.doSomething(); &#125;&#125; Use123Strategy strategy = new ConcreteStrategy1();Context context = new Context(strategy);context.doAny(strategy); 应用优点 算法可以自由切换只需要实现策略接口类，通过封装角色对其进行封装即可。 避免使用多重条件判断123456if (condition1)&#123; strategy1.do();&#125;else if(condition2)&#123; strategy2.do();&#125; // ..... 扩展性好 缺点 策略类数量多 所有策略类都需要对外暴露上层模块必须知道有哪些策略， 然后才能决定使用哪一个策略，与迪米特法则相违背。(迪米特法则：一个类对于其他类知道的越少越好) 注意事项当具体的策略数量超过一定个数时，考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则会带来很大的系统维护成本。 使用场景 多个类只有在算法或者行为上稍有不同的场景 算法需要自由切换的场景 需要屏蔽算法规则的场景 策略枚举当策略枚举不经常发生变化时可以使用。 12345678910111213141516171819202122public enum StrategyEnum &#123; ADD(\"+\") &#123; @Override public int exec(int a, int b) &#123; return a + b; &#125; &#125;, SUB(\"-\") &#123; @Override public int exec(int a, int b) &#123; return a - b; &#125; &#125;; private String opt; StrategyEnum(String opt) &#123; this.opt = opt; &#125; abstract int exec(int a, int b);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://www.hessentec.top/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"对象池模式","slug":"对象池模式","date":"2020-06-24T09:13:34.000Z","updated":"2020-06-28T10:41:59.732Z","comments":true,"path":"2020/06/24/对象池模式/","link":"","permalink":"https://www.hessentec.top/2020/06/24/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"对象池模式一种特殊的工厂对象，一个对象池包含一组已经初始化过且可以使用的对象。用户可以从池中取得对象，并对其进行操作，在不需要的时候将其归还给对象池。 使用对象池的目的是为了提升性能，当需要创建比较耗费时间的对象时尤为明显。 角色和职责对象池的管理者管理者来维护对象池，包括初始化对象池、扩充对象池的大小、获取对象时的策略、重置归还对象的状态。 12345678910111213141516171819202122232425262728public class PoolMgr&#123; private int init ; private int max; private int factor; private Colection c; // public void init()&#123; //init &#125; //根据策略来动态的生成对象。。 //如果对象不足可以增加对象池的对象，或者blocking直到有对象释放。 public Object aquire()&#123; return c.remove(); &#125; public void release(Object o)&#123; if(o == null) return; reset(o); c.add(o); &#125;&#125; 对象池的使用者使用者从管理者处获取对象，使用完成后必须归还对象避免一致占用。 123456Object o = null;try&#123; o = PoolMgr.getInstance(); &#125;finaly&#123; PoolMgr.release(o); &#125; 优点复用池中的对象，消除创建/回收对象所产生的内存开销，CPU开销以及IO开销。常见的有：Socket的链接池、线程池、数据库连接池等。 缺点多线程并发环境中，需要考虑线程安全问题，需要在数据结构上进行同步或者为锁竞争产生阻塞，这种开销处理不好会比创建销毁独享的开销高很多。由于池中的对象数量有限，对象池小可能会成为性能瓶颈，太大占用内存资源高；轻量级对象的创建/销毁不需要使用对象池，徒增系统的复杂度； Common Pool2Commons Pool2核心部分由三个基础接口和相关的实现类实现： PooledObject池化对象，对池中的对象进行封装，封装对象的状态和一些其他信息。PooldedObject 有两个实现类，DefaultPoolObject时普通通用的实现，PooledSoftReference使用SoftReference封装了对象，供SoftReferenceObjectPool使用。 12345678910111213141516171819202122232425262728293031323334353637public interface PooledObject&lt;T&gt; extends Comparable&lt;PooledObject&lt;T&gt;&gt; &#123; // 获取封装的对象 T getObject(); // 对象创建的时间 long getCreateTime(); // 对象上次处于活动状态的时间 long getActiveTimeMillis(); // 对象上次处于空闲状态的时间 long getIdleTimeMillis(); // 对象上次被借出的时间 long getLastBorrowTime(); // 对象上次返还的时间 long getLastReturnTime(); // 对象上次使用的时间 long getLastUsedTime(); // 将状态置为 PooledObjectState.INVALID void invalidate(); // 更新 lastUseTime void use(); // 获取对象状态 PooledObjectState getState(); // 将状态置为 PooledObjectState.ABANDONED void markAbandoned(); // 将状态置为 PooledObjectState.RETURNING void markReturning();&#125; PooledObjectFactory 池化对象工厂，负责对象的创建、初始化、销毁和验证工作，Factory对象由ObjectPool持有并使用。因为对象的创建、初始化、销毁和仰正的工作无法通用，Commons Pool2并没有提供PooledObjectFactory的默认子类实现，只提供了抽象子类BasePooledObjectFactory可以实现create和wrap两个方法。 12345678910111213141516public interface PooledObjectFactory&lt;T&gt; &#123; // 创建一个池对象 PooledObject&lt;T&gt; makeObject() throws Exception; // 销毁对象 void destroyObject(PooledObject&lt;T&gt; p) throws Exception; // 验证对象是否可用 boolean validateObject(PooledObject&lt;T&gt; p); // 激活对象，从池中取对象时会调用此方法 void activateObject(PooledObject&lt;T&gt; p) throws Exception; // 钝化对象，向池中返还对象时会调用此方法 void passivateObject(PooledObject&lt;T&gt; p) throws Exception;&#125; ObjectPool 持有对象并提供取/还等操作. 12345678910111213141516171819202122232425 public interface ObjectPool&lt;T&gt; &#123; &#x2F;&#x2F; 从池中获取一个对象，客户端在使用完对象后必须使用 returnObject 方法返还获取的对象 T borrowObject() throws Exception, NoSuchElementException, IllegalStateException; &#x2F;&#x2F; 将对象返还到池中。对象必须是从 borrowObject 方法获取到的 void returnObject(T obj) throws Exception; &#x2F;&#x2F; 使池中的对象失效，当获取到的对象被确定无效时（由于异常或其他问题），应该调用该方法 void invalidateObject(T obj) throws Exception; &#x2F;&#x2F; 池中当前闲置的对象数量 int getNumIdle(); &#x2F;&#x2F; 当前从池中借出的对象的数量 int getNumActive(); &#x2F;&#x2F; 清除池中闲置的对象 void clear() throws Exception, UnsupportedOperationException; &#x2F;&#x2F; 关闭这个池，并释放与之相关的资源 void close(); ...&#125; 对象池配置对象池配置提供了对象池初始化所需要的参数，Common Pool2中的基础配置类时BaseObjectPoolConfig, 有GenericObjectPoolConfig和GenericKeyedObjectPoolConfig，分别为GenericObjectPool和GenericKeyedObjectPool使用。 参数 解释 默认值 lifo 连接池存放池对象的方式； true:放在空闲队列的嘴钱买呢， false:放在空闲队列的最后面 true fairness 从池中获取/返还对象时是否使用公平锁机制 false maxWaitMillis 获取资源的等待时间。blockWhenExhausted为true时有效。-1代表无时间限制，一致阻塞到有可用的资源 minEvictableIdleTimeMillis 对象空闲的最小时间，打到此值后空闲对象可能会被移除，-1表示不移除 30分钟 softMinEvictableIdletimeMillis 对象空闲的最小时间，并且池中之少保留有minidle所指定的个数 numTestsPerEvictionRun 资源回收线程执行一次回收操作回收资源的个数 3 evictionPolicyClassName 资源回收策略 org.apache.commons.pool2.impl.DefaultEvictionPolicy testOnCreate 创建对象时是否调用factory.validateObject false testOnBorrow 获取对形势是否调用factory.validateObject false testOnReturn 返还对象时是否调用factory.validateObject false timeBetweenEvictionRunsMills 回收资源线程的执行周期，默认-1表示不启用回收资源线程 -1 blockWhenExhausted 资源耗尽时，是否阻塞等待获取资源 true testWhileIdel 池中的限制对象是否由逐出器验证，无法验证的对象将从池中删除销毁 false 池化对象的状态 参数值 描述 IDEL 在池中，处于空闲状态 ALLOCATED 被使用中 EVICTION 正在被逐出器验证 VALIDAITTON 正在验证 INVALID 驱逐测试或者验证失败并将被销毁 ABANDONED 对象被客户端拿出后，长时间未返回池中，或者没有调用use方法，被标记为抛弃 Demo12345678910111213141516171819public class StringBufferFactory extends BasePooledObjectFactory&lt;StringBuffer&gt; &#123; // 创建一个新的对象 @Override public StringBuffer create() &#123; return new StringBuffer(); &#125; // 封装为池化对象 @Override public PooledObject&lt;StringBuffer&gt; wrap(StringBuffer buffer) &#123; return new DefaultPooledObject&lt;&gt;(buffer); &#125; // 使用完返还对象时将 StringBuffer 清空 @Override public void passivateObject(PooledObject&lt;StringBuffer&gt; pooledObject) &#123; pooledObject.getObject().setLength(0); &#125;&#125; 使用 12345678910111213141516171819202122232425262728293031323334353637383940414243 // 创建对象池配置GenericObjectPoolConfig config = new GenericObjectPoolConfig();// 创建对象工厂PooledObjectFactory factory = new StringBufferFactory();// 创建对象池ObjectPool&lt;StringBuffer&gt; pool = new GenericObjectPool&lt;&gt;(factory, config);StringReader in = new StringReader(\"abcdefg\");StringBuffer buf = null;try &#123; // 从池中获取对象 buf = pool.borrowObject(); // 使用对象 for (int c = in.read(); c != -1; c = in.read()) &#123; buf.append((char) c); &#125; return buf.toString();&#125; catch (Exception e) &#123; try &#123; // 出现错误将对象置为失效 pool.invalidateObject(buf); // 避免 invalidate 之后再 return 抛异常 buf = null; &#125; catch (Exception ex) &#123; // ignored &#125; throw e;&#125; finally &#123; try &#123; in.close(); &#125; catch (Exception e) &#123; // ignored &#125; try &#123; if (null != buf) &#123; // 使用完后必须 returnObject pool.returnObject(buf); &#125; &#125; catch (Exception e) &#123; // ignored &#125;&#125; 参考：Apache Common Pool2 对象池应用浅析一个广为人知但鲜有人用的技巧：对象池","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"对象池模式","slug":"对象池模式","permalink":"https://www.hessentec.top/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"原型模式","date":"2020-06-24T03:20:07.000Z","updated":"2020-06-24T09:25:09.837Z","comments":true,"path":"2020/06/24/原型模式/","link":"","permalink":"https://www.hessentec.top/2020/06/24/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式不通过new关键字来产生一个对象，而通过对象复制来生产对象的模式，原型模式的核心是clone方法，通过该方法进行对象的拷贝。 也就是先生产出一个包含大量共有信息的类对象，然后拷贝出副本修正细节信息，建立一个完整的个性对象。 定义用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 优缺点 性能好原型模式是内存二进制流侧拷贝，要比直接new一个对象性能好很多，特别在一个循环体内产生大量的对象时，原型模式可以更好的体现其优点。 逃避构造函数的约束直接在内存中拷贝，构造函数不会执行。优点和缺点都是减少了约束。 使用场景需要频繁的new一个对象，并且该对象需要繁琐的数据准备时；一个对象要提供给其他对象访问，各个调用者可能需要修改其值时； 原型模式一般与工厂方法模式一起出现，通过clone的方法来创建对象，然后由工厂方法提供给调用者。 实现123456789101112public class PrototypeClass implements Cloneable&#123; @Override public PrototypeClass clone()&#123; PrototypeClass p = null; try&#123; p = (PrototypeClass)super.clone(); &#125;catch(CloneNotSupportedException e)&#123; //TODO &#125; return p; &#125;&#125; 注意事项构造函数不会被执行Object类的clone方法原理是从内存中（堆内存）以二进制流的方式进行拷贝，重新分配一个内存快，构造函数是不会被执行的。 浅拷贝Object类提供的方法clone只是拷贝本对象，对于其内部的数组、引用对象都不拷贝还是指向原声对象的内部元素地址。 1234567891011121314public class PrototypeClass implements Cloneable&#123; public ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); @Override public PrototypeClass clone()&#123; PrototypeClass p = null; try&#123; p = (PrototypeClass) super.clone(); &#125;catch(CloneNotSupportedException e) ) &#123; // &#125; return p; &#125;&#125; 深拷贝深拷贝需要拷贝对象自身外，还需要拷贝对象的所有引用的对象。 通过clone方式实现： 123456789101112131415public class PrototypeClass implements Cloneable&#123; public ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); @Override public PrototypeClass clone()&#123; PrototypeClass p = null; try&#123; p = (PrototypeClass) super.clone(); p.arrayList = (ArrayList&lt;String&gt;) this.arrayList.clone(); &#125;catch(CloneNotSupportedException e) ) &#123; // &#125; return p; &#125;&#125; 通过序列化方式来实现，通过序列化将对象(该对象的类必须实现Serializable接口)写到一个流中，然后再从流里把对象读出来以实现深克隆。 123456789public static &lt;T extends Serializable&gt; T clone(T t) throws Exception &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(t); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); return (T)ois.readObject();&#125; clone与final的冲突当使用clone方法的时候，类的成员变量不可以增加final关键字。 拓展：Java提高篇——对象克隆（复制）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://www.hessentec.top/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者模式","slug":"建造者模式","date":"2020-06-23T11:29:40.000Z","updated":"2020-06-23T14:27:50.937Z","comments":true,"path":"2020/06/23/建造者模式/","link":"","permalink":"https://www.hessentec.top/2020/06/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式建造者模式与工厂模式关注点不同，建造者模式关注零件的组装过程，工厂模式注重零件的创建过程。 定义建造者模式也叫生成器模式， 它将一个复杂对象的构建与它的表示分离，使得同样的建造构建过程可以创建不同的表示。 优点 封装性良好使用建造者模式可以使得客户端不需要知道产品内部组成的细节。 建造者独立，易扩展不同的实现类Builder是相互独立的，对系统的扩展有利。 便于控制细节风险由于建造者独立，因此可以个性化，修改一个建造者不会对其他模块产生影响。 缺点 产品的组成部分必须相同，限制了其使用范围 产品内部变化复杂时，需要增加很多建造者类 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时； 多个部件或者零件都可以装配到一个对象中，但是产生的运行结果不同时； 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能； 实现Product 产品类12345public class Product&#123; public void doSomething()&#123; &#125;&#125; Builder抽象建造者1234public abstract class Builder&#123; abstract void setPart(); //设置个性部分 abstract Product buildProduct();//建造产品&#125; ConcreteBuilder 具体建造者12345678public class ConcreteBuilder extends Builder&#123; public void setPart()&#123; //... &#125; pbulic Product buildProduct()&#123; return new Product(); &#125;&#125; Director 导演类导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。当建造者模式比较庞大时，导演类可以有多个。 123456789public class Director&#123; public Product buildProductA()&#123; Builder b = new ConcreteBuilder(); b.setPart(); return b.buildProduct(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"建造者模式","slug":"建造者模式","permalink":"https://www.hessentec.top/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"前后端分离","slug":"前后端分离","date":"2020-06-22T12:37:02.000Z","updated":"2020-06-22T14:31:18.845Z","comments":true,"path":"2020/06/22/前后端分离/","link":"","permalink":"https://www.hessentec.top/2020/06/22/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/","excerpt":"","text":"动静分离技术：CDN、负载均衡： 实现手段： 1） lvs / lb / 四层数据包， 速度快，不解包。 2） 反向代理（nginx 、 Node.js 七层 URI/location 建立三次握手，请求传递、转发 存储ip、请求uri、次数、时间等， ） Load Balance 健康检查 算法： 随机 轮训 哈希 最少连接数 权重/动态权重多级缓存防穿透 限流熔断降级灰度发布 服务无状态：分布式问题 update user set status = 2 where status = 1 and id = 1;","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"抽象工厂模式","slug":"抽象工厂模式","date":"2020-06-21T23:51:26.000Z","updated":"2020-07-13T09:11:17.180Z","comments":true,"path":"2020/06/22/抽象工厂模式/","link":"","permalink":"https://www.hessentec.top/2020/06/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"抽象工厂模式抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，抽象工厂模式可以生产多个等级的产品。 概念产品等级：不同产品的种类就是不同的产品等级（电视机和洗衣机就是不同的产品等级）产品族：一个具体工厂生产的不同等级的产品（工厂生产的电视机和洗衣机属于一个产品族） 定义一种为访问类提供一个创建一组相关或者相互依赖对象的接口，且访问类无需指定所需要产品的具体类就能得到同族的不同等级的产品。 使用场景1） 客户端不依赖于产品类实例如何被创建、实现2） 强调一系列相关的产品（同一产品族）一起使用创建对象需要大量的代码3） 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。一个对象族都有相同的约束，则可以使用抽象工厂模式。 实现产品角色实现抽象产品：Product，定义产品的规范，描述产品的主要特性和功能，抽象工厂模式有多个抽象产品。具体产品：ConcreteProduct，实现抽象产品角色所定义的接口由具体工厂来创建，与具体工厂之间是一对多的关系。 123456789101112131415161718192021222324252627282930public abstract Product&#123; //all product base filds &amp; methods. abstract int on(); abstract int off();&#125;public abstract AbstractTvProduct extends Product&#123; abstract int switchChannel();&#125;public abstract AbstractFridgeProduct extends Product&#123; abstract int increaseTemp(); abstract int decreaseTemp();&#125;public HaierTVProduct extends AbstractTvProduct&#123;&#125;public HaierFridgeProduct extends AbstractFridgeProduct&#123;&#125;public TCLTVProduct extends AbstractTvProduct&#123;&#125;public TCLFridgeProduct extends AbstractFridgeProduct&#123; &#125; 工厂角色实现抽象工厂：Abstract Factory，提供了创建产品的接口，包含多个创建产品的方法,可以创建多个不同等级的产品。具体工厂：实现抽象工厂中的多个抽象方法，完成具体产品的创建。 1234567891011121314151617181920212223public interface IFactory&#123; Product createTV(); Product createFridge();&#125;public class HaierFactory implements IFactory&#123; Product createTV()&#123; return new HaierTVProduct(); &#125; Product createFridge()&#123; return new HaierFridgeProduct(); &#125;&#125;public class TCLFactory implements IFactory&#123; Product createTV()&#123; return new TCLTVProduct(); &#125; Product createFridge()&#123; return new TCLFridgeProduct(); &#125;&#125; 优缺点 隔离了具体类的生成，使得客户并不需要知道什么被创建，具有良好的封装性。 如果要扩展产品族（有新的工厂要生产电视和冰箱时）的时候，只需要增加具体的产品类和实现工厂方法即可，原有的代码不需要变动，符合开闭原则。 如果要扩展产品等级时，从抽象产品到工厂类，原有的代码都需要变动，违背了开闭原则。 参阅：抽象工厂模式（详解版）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"抽象工厂模式","slug":"抽象工厂模式","permalink":"https://www.hessentec.top/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"分布式ID生成器","slug":"分布式ID生成器","date":"2020-06-20T01:26:44.000Z","updated":"2020-06-22T07:17:01.707Z","comments":true,"path":"2020/06/20/分布式ID生成器/","link":"","permalink":"https://www.hessentec.top/2020/06/20/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"1)资源锁细粒度化 将100个资源拆分成10份。 这10份分别上锁，应用场景如秒杀。 2）业务使用锁细粒度化 只对需要的资源加锁，避免大范围加锁。 3）无锁化（真无锁，假无锁） ThreadLocal 真无锁 CAS 假无锁4）异步+线程池 Completeable hystrix/sentinel 限流 Leaf / Snowflake 缺点： 1）依赖于时间，需要ntp 2）依赖于NodeId和AreaID的分发，用ZK解决 通过zk的顺序性分配唯一的node和area 基于Mysql的发布基于Mysql的优化 基于雪花算法 基于ZK","categories":[{"name":"分布式","slug":"分布式","permalink":"https://www.hessentec.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"ID生成器","slug":"分布式/ID生成器","permalink":"https://www.hessentec.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ID%E7%94%9F%E6%88%90%E5%99%A8/"}],"tags":[]},{"title":"工厂方法模式","slug":"工厂方法模式","date":"2020-06-19T13:51:15.000Z","updated":"2020-07-13T09:05:05.118Z","comments":true,"path":"2020/06/19/工厂方法模式/","link":"","permalink":"https://www.hessentec.top/2020/06/19/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"场景 new 对象的替代方案 需要灵活、可扩展的框架时 在异构项目中，从外部产生的对象 测试驱动开发框架下使用。测试驱动开发 -TDD 工厂方法模式定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；Creator为抽象的创建类，即抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。 优点 良好的封装，代码结构清晰，降低模块间的耦合； 良好的扩展性； 屏蔽具体的产品类，只要接口不变，系统中上层模块就不需要发生变化。 高层模块只需要知道产品的抽象类，不关心实现类，符合迪米特法则；只依赖产品的抽象，符合倒置原则；使用产品子类替换父类时也没有问题，符合里氏替换原则； 缺点对于不同类型的产品都要增加不同类型的工厂来管理，增加代码的复杂性 实现通用实现产品类： 123456789101112public abstract class Product&#123; public abstract void method1(); public void method2()&#123;&#125;&#125;public class Product1 extends Product&#123; public void method1()&#123;&#125;&#125;public class Product2 extends Product&#123; public void method1()&#123;&#125;&#125; 工厂类： 12345678910111213141516public abstract class Factory&#123; public abstract &lt;T extends Product&gt; T create(Class&lt;T&gt; c);&#125;public class ConcreteFactory extends Factory&#123; public &lt;T extends Product&gt; T create(Class&lt;T&gt; c)&#123; Product p = null; try&#123; p = (Product)Class.forName(c.getName()).newInstance(); &#125;catch(Exception e)&#123; &#125; return (T)p; &#125;&#125; 使用： 12Factory factory &#x3D; new ConcreteFactory();Product p &#x3D; factory.createt(Product1.class); 缩小为简单工厂去掉抽象的Factory类，create()方法变为静态方法即可。 123456789101112public void Factory&#123; public static &lt;T extends Product&gt; T create(Class&lt;T&gt; c)&#123; Product p = null; try&#123; p = (Product)Class.forName(c.getName()).newInstance(); &#125;catch(Exception e)&#123; &#125; return (T)p; &#125;&#125; 调用代码： 1Product p = Factory.create(Product1.class); 升级为多个工厂类遇到复杂情况下，一个工厂类初始化需要耗费很多资源，这样可以将工厂类细化拆分。 123456789101112public class Factory1 extends Factory&#123; public static Product create()&#123; return new Product1(); &#125;&#125;public class Factory2 extends Factory&#123; public static Product create()&#123; return new Product2(); &#125;&#125; 这样的好处是职责清晰，结构简单，但是可扩展性和可维护性差了些。一般情况下，再增加一个协调类，避免调用者直接与各个子工厂类交流，协调类的作用是封装子工厂类，对高层模块提供统一的访问接口。 替代单例模式通过反射的方式来创建唯一一个实例 延迟初始化一个对象被使用完毕后，并不立即释放，工厂类保持其初始状态，等待再次被使用。 延迟加载框架可以被扩展为，限制某个产品类的最大实例化数量（如链接池的最大链接数量） 123456789101112131415161718public class ProductFactory&#123; private static final Map&lt;String,Product&gt; pMap = new HashMap(); public static synchronized Product createProduct(String type) throws Exception&#123; Product p = null; if(pMap.containsKey(type))&#123; p = pMap.get(type); &#125;else&#123; if(type.equals(\"Product1\"))&#123; p = new Product1(); &#125;else&#123; p = new Product2(); &#125; &#125; return product; &#125;&#125; 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 https://www.zhihu.com/question/24843188 https://www.jianshu.com/p/83ef48ce635b https://blog.csdn.net/buyulian/article/details/79203880 https://blog.csdn.net/qianhaifeng2012/article/details/52014773 https://www.cnblogs.com/aspirant/p/8980573.html http://www.akathink.com/2016/08/01/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"https://www.hessentec.top/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-06-18T14:20:29.000Z","updated":"2020-06-23T13:12:58.090Z","comments":true,"path":"2020/06/18/单例模式/","link":"","permalink":"https://www.hessentec.top/2020/06/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“混乱”。 要求生成唯一序号的场景 整个项目中需要一个共享数据，如计数器 创建对象要消耗过多资源（IO访问或者数据库资源等） 定义大量的静态常量和静态方法的工具类 定义确保一个类只有一个实例，而且自行实例化并且向整个系统提供这个实例。 优点单例模式在内存中只有一个实例，减少了内存开支。当一个对象需要频繁地创建、销毁时，而且创建或者销毁时的性能无法优化时，单例模式的优势非常明显。 缺点没有接口，无法扩展，没有接口也不能使用Mock方式虚拟对象。在并行开发环境中，单例模式没有完成无法进行测试。与单一职责原则冲突，单例模式把业务逻辑和单例混合在一个类中。 注意事项高并发情况下，单例模式的线程同步问题。 提前加载12345678910public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 延后加载123456789101112131415161718public class Singleton&#123; private volatile static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 枚举123public enum Singleton&#123; instance;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://www.hessentec.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis集群","slug":"Redis集群","date":"2020-06-18T12:03:20.000Z","updated":"2020-06-18T14:02:18.174Z","comments":true,"path":"2020/06/18/Redis集群/","link":"","permalink":"https://www.hessentec.top/2020/06/18/Redis%E9%9B%86%E7%BE%A4/","excerpt":"","text":"IDC机房硬件设备选购方案 1.1 生产环境中选购依据 价格 性能 冗余 1.1.1 生产环境负载均衡系统架构设备选购方案 负载均衡： LVS1 DELL R610 1U CPU E52 8G * 2/4 硬盘 SAS 146 * 2 RAID1 LVS2 DELL R610 1U CPU E52 8G * 2/4 硬盘 SAS 146 * 2 RAID1 1.1.2 Web层硬件选择RAID www主站1 业务2 DELL R730 2U CPU E5 * 2 8G(16G/32G) SAS 300G * 2 RAID0 www主站2 业务2 DELL R730 2U CPU E5 * 2 8G(16G/32G) SAS 300G * 2 RAID0 1.1.3 数据库层硬件以及RAID Mysql主库1-1 DELL R730 2U CPU E52 8/16/32 SAS 300G * 6 RAID10(兼顾冗余/速度） Mysql主库1-2 DELL R730 2U CPU E52 8/16/32 SAS 300G * 6 RAID10(兼顾冗余/速度） Mysql从库1-1 DELL R730 2U CPU E52 8/16/32 SAS 300G * 6 RAID0/5 Mysql从库1-2 DELL R730 2U CPU E52 8/16/32 SAS 300G * 6 RAID0/5 Mysql从库2-1 DELL R730 2U CPU E52 8/16/32 SAS 300G * 6 RAID0/5 Mysql从库2-2 DELL R730 2U CPU E52 8/16/32 SAS 300G * 6 RAID0/5 1.1.4 存储层硬件以及RAID DELL R610 E5 * 2 16/32G SAS 10K 2T * 6 不做RAID交叉备份/ RAID5DELL R730 E5 * 2 16/32G SAS 10K 2T * 6 RAID5折中方案 备份服务器一般考虑容量和冗余，对性能要求不高。 1.1.5 NFS硬件以及RAID NFS1 DELL R730 E5 8G * 2 SAS 15K 600G * 6 RAID10/RAID5/RAID0NFS2 DELL R730 E5 8G * 2 SAS 15K 600G * 6 RAID10/RAID5/RAID0 1.1.6 GFS、MFS分布式存储 NFS1 DELL R730 E5 8G * 2 SAS 15K 600G * 6 RAID10/RAID5/RAID0NFS2 DELL R730 E5 8G * 2 SAS 15K 600G * 6 RAID10/RAID5/RAID0 1.1.7 监控管理/网关层硬件以及RAID DELL R610/R430 E5*1 8/16G 146 SAS * 2 RAID1 1.1.8 网络设备 全千兆设备/网线华为 H3C CISCO DLINK 都需要带有远程管理卡 4+1 Redis搭建主机规划： 序号 主机名称 角色 数量 IP内网 IP外网 端口 软件 备注 1 Redis-Master-01 Node01 1 10.0.0.1 6379 Centos7.7 – 1 Redis-Master-02 Node02 1 10.0.0.2 6379 Centos7.7 – 1 Redis-Master-03 Node03 1 10.0.0.3 6379 Centos7.7 – 1 Redis-slave-01 slave01 1 10.0.0.4 6389 Centos7.7 – 1 Redis-slave-02 slave02 1 10.0.0.5 6389 Centos7.7 – 1 Redis-slave-03 slave03 1 10.0.0.6 6389 Centos7.7 – 1234567bind 10.0.0.1port 6379pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pidcluster-enabled yesdaemonize yescluster-config-file nodes-63679.conf appendonly yes ES安装cd /etc/yum.repos.d/vim elasticsearcg.repoyum makecache &amp;&amp; yum install -y elasticsearch","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.hessentec.top/categories/Redis/"},{"name":"集群部署","slug":"Redis/集群部署","permalink":"https://www.hessentec.top/categories/Redis/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"}],"tags":[]},{"title":"设计模式和原则","slug":"设计模式和原则","date":"2020-06-18T08:40:27.000Z","updated":"2020-07-13T09:30:05.584Z","comments":true,"path":"2020/06/18/设计模式和原则/","link":"","permalink":"https://www.hessentec.top/2020/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%88%99/","excerpt":"","text":"创建软件应用程序时为了满足不断变化和发展的需求，一个成功的应用程序应该提供一种简单的方法来扩展它以满足不断变化的期望。 SOLID设计原则单一职责原则有且仅有一个原因引起类的变更。 问题：Class IUser 负责两个不同的职责,职责1维护User的属性(id, name, age)，职责2维护DB操作（save/update/delete/find）.当由于职责1需求发生改变要增加一个sex的时候，有可能会导致原本运行正常的职责2功能发生故障。 解决方法：将IUser拆分为 UserInfo和UserDao。 优点：降低类的复杂性，一个类只负责一项职责；提高类的可读性，提高系统的可维护性；降低变更引起的风险，当修改一个接口的功能时，可以降低对其他功能的影响。 开闭原则一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。也就是说通过扩展来实现变化，而不是通过修改已有的代码来实现变化。 可以通过抽象约束、封装变化来实现开闭原则。通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 里氏替换原则派生类型必须完全可替代其基类型。在设计模块和类时，必须确保派生类型从行为的角度来看是可替代的。当派生类型被其父类替换时，其余代码就像它是自类型那样使用它。 子类必须完全实现父类的方法 子类可以有自己的个性 覆盖或者实现父类的方法时，输入参数可以被放大 腹泻或者实现父类的方法时，输出结果可以被缩小 接口隔离原则客户端不应该依赖于它所不需要的接口。接口隔离原则减少了代码耦合，使软件更强壮，更易于维护和扩展。接口隔离原则要求接口的定义和设计尽量的细化。 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性，但是如果过小，会造成接口数量过多，使设计复杂化。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，不需要的方法隐藏起来，只有专注地为一个模块提供定制服务，才能建立最小依赖关系。 提高内聚，减少对外交互。使接口用最少的方法完成最多的事情。 依赖倒置原则高级模块不应该依赖低级模块，两者都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，器依赖关系是通过接口或者抽象类产生。 接口或者抽象类不依赖实现类 实现类依赖接口或者抽象类 创建型模式(6/6) 单例模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 对象池模式 行为型模式(12/12) 策略模式 状态模式 访问者模式 迭代器模式 责任链模式 模版方法模式 命令模式 备忘录模式 解释器模式 观察者模式 中介者模式 空对象模式 结构型模式(7/7) 代理模式 组合模式 装饰器模式 桥接模式 适配器模式 门面模式 享元模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"设计原则","slug":"设计模式/设计原则","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"设计原则","slug":"设计原则","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"常用JVM参数","slug":"常用JVM参数","date":"2020-06-17T13:46:30.000Z","updated":"2020-06-17T14:19:26.326Z","comments":true,"path":"2020/06/17/常用JVM参数/","link":"","permalink":"https://www.hessentec.top/2020/06/17/%E5%B8%B8%E7%94%A8JVM%E5%8F%82%E6%95%B0/","excerpt":"","text":"HotSpot 虚拟机常用配置 配置 说明 -Xms1g 最小堆内存 -Xmx4g 最大堆内存 -XX:+UseG1GC 使用G1垃圾回收器 -Xss256k 每个线程栈大小256k -XX:MetaspaceSize=256m 元数据区大小256M -XX:MaxMetaspaceSize=256m 元数据区最大256M -XX:MaxGCPauseMillis=500 GC最大停顿毫秒数 -XX:+DisableExplicitGC 禁用代码中显式调用GC，System.gc()将会失效 -XX:+UnlockExperimentalVMOptions 解锁实验参数 -XX:+UseStringDeduplication GC的同时做重复字符串消除，只用于G1 -XX:InitiatingHeapOccupancyPercent=60 启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45. -XX:ParallelGCThreads=8 设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同. -XX:G1MixedGCCountTarget=4 设置在标记周期完成之后混合收集的数量，以维持old region（也就是老年代）中，最多有G1MixedGCLiveThresholdPercent的存活对象。默认值为8，混合收集的数量将维持在这个值之内。（JVM build &gt; 23） -XX:MaxTenuringThreshold=7 年老代的最大临界值(tenuring threshold). 默认值为 15. -XX:+UseGCLogFileRotation 滚动记录GC日志文件 -XX:NumberOfGCLogFiles=5 GC日志文件数量为5个 -XX:GCLogFileSize=64M 单个GC日志文件大小64M -Xloggc:/app/data/logs/gc-date +%Y%m%d-%H-%M.log GC日志文件存储目录和名称 -XX:+PrintGCDetails 打印GC详情 -XX:+PrintGCDateStamps 打印GC时时间戳 -XX:+PrintHeapAtGC GC时打印堆信息 -XX:+PrintAdaptiveSizePolicy 自适应大小策略，每次 GC 后会重新计算 Eden、From 和 To 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。 -XX:+UseFastAccessorMethods -XX:SoftRefLRUPolicyMSPerMB=0 softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"调优","slug":"调优","permalink":"https://www.hessentec.top/tags/%E8%B0%83%E4%BC%98/"},{"name":"参数","slug":"参数","permalink":"https://www.hessentec.top/tags/%E5%8F%82%E6%95%B0/"}]},{"title":"常用监控与故障处理工具","slug":"常用监控与故障处理工具","date":"2020-06-16T14:17:33.000Z","updated":"2020-06-17T13:44:45.184Z","comments":true,"path":"2020/06/16/常用监控与故障处理工具/","link":"","permalink":"https://www.hessentec.top/2020/06/16/%E5%B8%B8%E7%94%A8%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/","excerpt":"","text":"命令行工具jps列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟唯一ID（与操作系统进程ID一致）。 jps [option] [hostid] 选项 作用 -q 只输出lvmid，省略主类的名称 -m 输出虚拟机启动时传递给主类main（）的参数 -l 输出主类的全名，如果是jar包，则输出jar路径 -v 输出虚拟机启动时的jvm参数 jstat用于监视虚拟机各种运行状态信息的命令行工具。显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。 jstat [option vimid [interval[s|ms] [count]]][protocal:][//]lvmid[@hostname[:port]/servername] 选项 作用 -class 监视类加载、卸载数量、总空间以及类装载耗费的时间 -gc 监视Java堆状况，包括Eden、Survivor、老年代、永久代的容量，已用空间，垃圾收集时间 -gccapacity 监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到最大最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -gccause 与-gcutil功能一样，会额外输出导致上一次垃圾收集产生的原因 -gcnew 监视新生代垃圾收集情况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 -gcold 监视老年代垃圾收集状况 -gcoldcapacity 与-gcold相同，输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出即时编译器编译过的方法、耗时等信息 -printcompilation 输出已经被即时编译的方法 每隔1s查询一次2105的gc情况，查询10次。jstat -gc 2105 1000 10 jstat -gcutil 2105 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 0.00 6.20 41.42 47.20 16 0.105 3 0.472 0.577 jinfo实时查看和调整虚拟机各项参数。 12345678910111213141516Usage: jinfo [option] &lt;pid&gt; (to connect to running process) jinfo [option] &lt;executable &lt;core&gt; (to connect to a core file) jinfo [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: -flag &lt;name&gt; to print the value of the named VM flag -flag [+|-]&lt;name&gt; to enable or disable the named VM flag -flag &lt;name&gt;&#x3D;&lt;value&gt; to set the named VM flag to the given value -flags to print VM flags -sysprops to print Java system properties &lt;no option&gt; to print both of the above -h | -help to print this help message jmap用于生成堆转储快照，查询finalize执行队列、Java堆和方法区的详细信息（空间使用率、当前使用收集器类型） 生成堆转储文件的方式： 1234-XX:+HeapDumpOnOutOfMemoryError 在虚拟机内存溢出异常出现后自动生成堆转储快照文件。-XX:HeapDumpOnCtrlBreak 使用ctrl+Break 生成堆转储快照文件kill -3 pid 生成堆转储快照文件jmap -dump:format&#x3D;b,file&#x3D;heap.dump 3120 选项 作用 -dump 生成java堆转储快照，格式为-dump:[live,]format=b,file=,live子参数说明是否只dump出存活对象 -finalizerinfo 显示再F-Queue中等待Finalizer线程执行finalize方法的对象。只有在Linux平台有效 -heap 显示Java堆详细信息，使用回收器类型、参数配置、分代状况，只在Linux平台下有效 -histo 显示堆中对象统计信息，包括类、实例数量、合计容量 -permstat 在以ClassLoader为统计口径显示永久代内存状态。只在Linux下有效 -F 当虚拟机进程对-dump选项没有响应时，可以使用-F强制生成dump快照，只在Linux下有效 jhat用于分析jmap生成的堆转储快照。 jhat heap.dump jhat功能相对简陋，分析工作耗时且耗费硬件资源，一般不在本机使用。替代方案：VisualVM、Eclipse Memory Analyzer、IBM HeapAnalyzer。 jstack生成虚拟机当前时刻的线程快照。目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。 123456789101112131415Usage: jstack [-l] &lt;pid&gt; (to connect to running process) jstack -F [-m] [-l] &lt;pid&gt; (to connect to a hung process) jstack [-m] [-l] &lt;executable&gt; &lt;core&gt; (to connect to a core file) jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt; (to connect to a remote debug server)Options: -F to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing. Prints additional information about locks -h or -help to print this help message 高级工具JConsole基于JMX的可视化监视、管理工具。 JHSDB基于服务性代理实现的进程外调试工具。服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言实现的API集合。 VisualVM多合一故障处理工具，不需要被监视的程序基于特殊Agent执行，通用性强，对应用程序的实际性能影响较小，可以直接在生产环境使用。 Java Mission Control可持续在线监控工具。 arthas阿里巴巴提供的性能分析工具https://alibaba.github.io/arthas/","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"常用工具","slug":"常用工具","permalink":"https://www.hessentec.top/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"故障排查","slug":"故障排查","permalink":"https://www.hessentec.top/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"}]},{"title":"Linux查看Swap","slug":"Linux查看Swap","date":"2020-06-12T10:39:54.000Z","updated":"2020-06-16T09:31:32.131Z","comments":true,"path":"2020/06/12/Linux查看Swap/","link":"","permalink":"https://www.hessentec.top/2020/06/12/Linux%E6%9F%A5%E7%9C%8BSwap/","excerpt":"","text":"123456789101112131415161718#!&#x2F;bin&#x2F;bash# Get current swap usage for all running processes# Erik Ljungstrom 27&#x2F;05&#x2F;2011SUM&#x3D;0OVERALL&#x3D;0for DIR in &#96;find &#x2F;proc&#x2F; -maxdepth 1 -type d | egrep &quot;^&#x2F;proc&#x2F;[0-9]&quot;&#96; ;do PID&#x3D;&#96;echo $DIR | cut -d &#x2F; -f 3&#96; PROGNAME&#x3D;&#96;ps -p $PID -o comm --no-headers&#96; for SWAP in &#96;grep Swap $DIR&#x2F;smaps 2&gt;&#x2F;dev&#x2F;null| awk &#39;&#123; print $2 &#125;&#39;&#96; do let SUM&#x3D;$SUM+$SWAP done echo &quot;PID&#x3D;$PID - Swap used: $SUM - ($PROGNAME )&quot; let OVERALL&#x3D;$OVERALL+$SUM SUM&#x3D;0doneecho &quot;Overall swap used: $OVERALL&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.hessentec.top/categories/Linux/"},{"name":"VIM","slug":"Linux/VIM","permalink":"https://www.hessentec.top/categories/Linux/VIM/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.hessentec.top/tags/linux/"},{"name":"swap","slug":"swap","permalink":"https://www.hessentec.top/tags/swap/"}]},{"title":"分布式ID生成器","slug":"分布式ID","date":"2020-06-11T12:38:52.000Z","updated":"2020-06-11T13:10:59.296Z","comments":true,"path":"2020/06/11/分布式ID/","link":"","permalink":"https://www.hessentec.top/2020/06/11/%E5%88%86%E5%B8%83%E5%BC%8FID/","excerpt":"","text":"Centos 简单优化安装基本工具1yum install -y wget vim net-tools lrzsz 删除UUID123vim ifcfg-ens33vim ifcfg-eth0vim em1 配置静态IP12345IPADDR&#x3D;10.0.0.130GATEWAY&#x3D;10.0.0.2NETMASK&#x3D;255.255.255.0DNS1&#x3D;10.0.0.2DNS2&#x3D;1.2.4.8 关闭防火墙以及NetworkManager和SELINX12345systemctl restart networksystemctl stop firewalldsystemctl disable firewalldsystemctl stop NetworkManagersystemctl disable NetworkManager 替换YUM源1234yum clean all &amp;&amp; yum makecachecd &#x2F;etc&#x2F;yum.repos.d&#x2F;mv CentOS-Base.repo CentOS-Base.repo.bakvim CentOS-Base.repo","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"编译与优化","slug":"编译与优化","date":"2020-06-11T11:41:40.000Z","updated":"2020-06-17T14:19:48.964Z","comments":true,"path":"2020/06/11/编译与优化/","link":"","permalink":"https://www.hessentec.top/2020/06/11/%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/","excerpt":"","text":"编译 前端编译器： JDK的Javac 、EclipseJDT中的增量式编译器（ECJ） 即时编译器：HotSpot虚拟机的C1\\c2编译器、Graal编译器 提前编译器：JDK的Jaotc、GNU Compiler for Java, Excelsisor JET. 前端编译器编译过程分为1个准备过程和3个处理过程：1）初始化插入式注解处理器2）解析与填充符号表 语法、词法分析词法分析是将源代码的字符流转变为标记集合的过程，单个字符是程序编写的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记。 语法分析时根据标记序列构造抽象语法树的过程，抽象语法树是用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表程序代码中的一个语法结构。例如包、类型、修饰符、运算符、接口、返回值、代码注释等。 经过词法和语法分析生成语法树以后，编译器后续的操作都建立在抽象语法树之上。 填充符号表符号表是一组符号地址和符号信息构成的数据结构，符号表中所登记的信息在编译的不同阶段都要被用到。如，在语义分析过程中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，对符号名进行地址分配时，符号表是地址解析分配的直接依据。 3）注解处理器 插入式注解处理器可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器（javac）的工作过程。 如果在处理注解期间对语法树进行过修改，编译器将回到解析以及填充符号表的过程重新处理，知道所有插入式注解处理器都没有再对语法树进行修改位置，每次循环称为一个轮次。 4）语义分析与字节码生成 语义分析过程分为标注检查和数据以及控制流分析两个步骤。 在经过语法分析后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查，譬如进行类型检查、控制流检查、数据流检查等等。 标注检查检查的内容包括变量是用钱是否已经被声明、变量与赋值之间的数据类型是否能够匹配等等。常量折叠：int a = 1 + 1 ; ==&gt; int a = 2; 数据流以及控制流分析数据流分析以及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检查异常都被正确处理了等问题。编译器的数据以及控制流分析与类加载时的数据以及控制流分析的目的基本哈桑一致，但是校验范围有所区别。 解语法糖Java语言的语法糖包含泛型、变长参数、自动装箱拆箱等，Java虚拟机在运行时并不知节支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程称为解语法糖。 字节码生成 字节码生成阶段需要把前面哥哥步骤生成的信息转化成字节码指令写到磁盘中外，还要进行少量的代码添加和转换工作。如实例构造器&lt;init&gt;()方法和&lt;cinit&gt;()方法的添加。如果用户代码中没有提供任何构造函数，那么编译器将会添加一个没有参数的、可访问性与当前类型一致的默认构造函数，这个工作在填充符号表阶段已经完成。 编译器会把语句块、变量变量初始化、调用父类的实例构造器方等操作收敛到&lt;init&gt;()和&lt;cinit&gt;()方法中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序执行， 语法糖泛型、自动装箱、拆箱、遍历循环、变长参数和条件编译、内部类、枚举类、断言、数值直面量、枚举和字符串的switch、try with resource， lambda等。 泛型类型擦除 自动装箱、拆箱和循环遍历1）大于127的值不会自动拆箱2）没有遇到运算符的情况下不会自动拆箱3）equals方法不处理数据转型 变长参数条件编译Java编译器将所有编译但愿的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间可以互相提供符号信息。 根据条件中布尔值常量值的真假，编译器将把分支中不成立的代码块消除掉。 后端编译当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存。当程序启动以后，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，减少解释器的中间损耗，获得更高的效率。 即时编译器即时编译器将运行比较频繁的代码块或者方法编译成本地机器吗，并且对这段代码进行优化。 在Hotspot中内置了2个即时编译器 Client Compiler、 Server Compiler。 虚拟机会根据自身版本与宿主机的硬件性能自动选择运行模式，也可以使用-client 或者 -Server 来强制指定虚拟机运行在客户端模式或者服务端模式。 解释模式(Interperted Mode)：-Xint编译模式(Compiled Mode): -Xcomp混合模式(Mixed Mode): -Xmixed (默认) 编译器编译本地代码需要占用程序运行时间，位了打到响应速度与运行效率之间打到最佳平衡，HotSpot在编译子系统中加入了分层编译的功能。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次：第0层，程序春解释执行，并且解释器不开启性能监控。第一层：使用客户端编译器将字节码编译为本地代码，进行简单可靠的稳定优化，不开启性能监控功能。第二层：使用客户端编译器执行，仅开启方法以及回边次数统计等优先的性能监控功能。第三层：使用客户端编译器执行，开启全部性能监控，除了第2层的痛就之外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。第四层：使用服务端编译器将字节码编译为本地代码，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。 实施分层编译后， 解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，用客户端编译器获得更高的编译速度，用服务端编译器来获取更好的编译质量，在解释执行的时候也无需额外承担手机性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时， 客户端编译器可先采用简单优化来为它争取更多的编译时间。 编译对象与触发条件被编译的热点代码有：被多次调用的方法和被多次执行的循环体。这两种情况编译的目标对象都是整个方法体，而不是单独的循环体。 基于采样的热点探测周期性的检查线程的调用栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点方法。优点：简单高效，容易获取方法的调用关系缺点：不能精确确认方法的忍睹，容易受到线程阻塞或者外界因素影响扰乱热点探测。 基于计数器的热点探测为每个方法建立计数器，统计方法的执行次数，如果超过一定的阈值就认为它是热点方法。优点：结果精确严谨缺点：每个方法建立并维护计数器，不能直接获取到方法的调用关系。HotSpot为每个方法准备了两类计数器：方法调用计数器和回边计数器（在循环边界往回跳）,当调用次数超过设定的阈值，就会触发即时编译。-XX:CompileThreshold 来设定触发即时编译的阈值。默认设置下，方法调用计数器统计的是相对执行瓶绿，当一个时间段内调用次数不足以提交即时编时，这个方法的调用计数器就会被减半（衰减），可以使用-XX:-UseCounterDecay关闭热度衰减。可以设置-XX:CounterHalfLifeTime设置半衰周期的时间，单位是秒。 当方法被调用时，首先检查该方法是否被即使编译器编译过，是则优先使用编译后的版本执行，否则将方法调用的计数器加一，然后判断方法调用计数器与回边计数器值之和是否超过阈值，超过则像即时编译器提交该方法的代码编译请求。如果没有做过任何设置，执行引擎默认不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成。当编译工作完成后，这个方法的调用入口地址会被系统自动改写成新值，下次调用该方法时就会使用已编译版本。 回边计数器：统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”,回边计数器的目的是为了触发栈上的替换编译。回边计数器没有热度衰减过程。 编译过程一般情况下，方法调用产生的标准编译请求和栈上替换编译请求，在虚拟机编译器未完成编译之前，都将按照解释方式执行代码，编译动作在后台的编译线程完成。设置-XX:-BackgroundCompilation禁止后台编译，禁止后触发即时编译条件时，执行线程向虚拟机提交编译请求后一致阻塞等待，直到编译过程完成后再开始执行编译器输出的本地代码。 服务端编译器效率较低，但是编译速度远超传统的静态优化编译器，相对于客户端编译器编译输出的代码质量有很大的提交，可以大幅降低本地代码的执行时间，从而抵消掉额外的编译水间开销。 即时编译的缺点1）占用程序运行时间2）占用程序运算资源 提前编译器提前编译器的分支：与传统C、C++编译器类似，在程序运行之前把程序代码编译成机器码的静态翻译工作；把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接加载进来使用。 编译器优化技术方法内联最重要的优化技术之一。 逃逸分析最前沿的优化技术之一。 栈上分配支持方法逃逸，但不支持线程逃逸 标量替换如果一个数据已经无法在分解为更小的数据表示时（原始数据类型），这些数据就可以称为标量。标量替换就是将用到的成员变量恢复为原始类型来访问的过程。加入逃逸分析可以证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候可能不去创建这个对象，而改为直接创建它的若干个被这个的方法使用的成员变量来替代，成员变量存储在栈上。 同步消除：如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定不会有竞争，对这个变量的同步措施也可以安全地消除掉。 公共子表达式消除语言无关的经典优化技术。如果一个表达式E之前已经被计算过，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。 数组边界检查消除语言相关的经典优化技术。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"编译","slug":"编译","permalink":"https://www.hessentec.top/tags/%E7%BC%96%E8%AF%91/"},{"name":"优化","slug":"优化","permalink":"https://www.hessentec.top/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"内存分配与回收","slug":"内存分配与回收","date":"2020-06-10T14:32:46.000Z","updated":"2020-06-12T14:35:10.856Z","comments":true,"path":"2020/06/10/内存分配与回收/","link":"","permalink":"https://www.hessentec.top/2020/06/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/","excerpt":"","text":"Java技术体系的自动内存管理最根本目标是自动化地给对象分配内存以及自动回收分配给对象的内存。《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪种垃圾收集器，以及虚拟机中与内存相关的参数设定。 HotSpot虚拟机中对象的分配原则对象优先在Eden分配在大多数情况下，对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时，虚拟机将发起一次minorGC。当survivor区的空间无法存放Eden区的对象时，就会通过担保机制提前转移到老年代去。 -Xms:20M 堆内存初始值20M-Xmx:20M 堆内存最大20M-Xmn10M 新生代占用10M（剩下的10M留给老年代）-XX:SurvivorRatio=8 决定了新生代Eden区与一个Survivor区的空间比例是8:1:1 大对象直接进入老年代大对象是需要大量连续内存空间的Java对象，如很长的字符串或者元素数量很多的数组。 在分配空间时，如果对象比较大，就会提前触发垃圾收集，以获取足够的连续空间才能存放该对象， 当复制对象时大对象意味着高额的内存复制开销。 -XX:PretenureSizeThreshold=3145728 （大于3M的对象会直接分配到老年代中）该参数只对Serial和ParNew两款收集器有效。 长期存活的对象将进入老年代内存回收时必须决策那些存活对象应该存放在新生代，哪些存活对象存放在老年代。虚拟机为每个对象定义了一个对象年龄（Age）存储在对象头重。 对象通常在Eden区诞生，如果经过一次MinorGC后仍然存活，并且能被Survivor容纳的话，会被移动到Survivor空间，并且将对象的年龄设置为1岁。对象在Survivor中每经过一次MinorGC，Age增加1， 当年龄增加到一定程度的时候，该对象会被移动到老年代中。可以通过-XX:MaxTenuringThreshold设置（默认为15次）。 动态对象年龄判定如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需等到-XX:MaxTenuringThreshold中要求的年龄。 也就是当前Survivor空间大小为1M，有两个Age=1且大小为256k的对象时，这两个对象就会直接进入老年代。 空间分配担保在发生MinorGC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果条件成立，那么这次MinorGC时安全的；；如果不成立，虚拟机会先查看-XX:HandlerPromotionFailure参数的设置值是否允许担保失败 如果允许担保失败，继续检查老年代最大可用的连续空间是否大于历次今生到老年代对象的平均大小 大于，尝试进行一次MinorGC； 小于，或者-XX:HandlePromotionFailure不允许冒险，则变更为FullGC。 在JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代总大小或者历次晋升的平均大小，就会进行MinorGC，否则就进行FullGc。-XX:HandlePromotionFailure参数不在生效。 垃圾的回收 哪些内存需要回收 什么时候回收 如何回收 如何判断对象已死 引用计数器 可达性分析算法（固定可作为GCRoot的对象有） 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如每个线程背调用的方法堆栈中使用的参数、局部变量、临时变量 在方法区中类静态属性引用的对象，如Java类的引用类型静态变量 在方法区中常量引用的对象，如字符串常量池中的引用 在本地方法栈中JNI引用的对象 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器 所有背同步锁持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 对象的引用 强引用，如Object obj = new Object(); 无论任何情况下，只要强引用关系存在，垃圾收集器就永远不会回收掉背引用的对象。 软引用，描述有用但非必须的对象，被软引用关联的对象在系统将要发生内存溢出前会把这些对象例如回收范围内进行二次回收。（SoftReference） 弱引用，描述非必须对象，被弱引用的对象只能生存到下一次垃圾收集发生位置。无论内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用，一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的时为了能在这个对象被收集器回收时受到一个系统通知（NIO用的RdirectMemory） 垃圾收集器算法分代收集理论建立在两个分代假说上：1）弱分代假说，绝大数对象都是朝生夕灭的。2）强分代假说，经过越多次收集过程的对象月难消亡。3）（推理假说）跨代引用假说，跨代引用相对于同代来说仅占极少数。 分代收集区域 部分收集（Partial GC） 新生代收集（Minor GC/ Yong GC） 老年代收集（Major GC / Old GC）（只有CMS会单独回收老年代） 混合收集(Mixed GC)，目前只有GC存在混合回收行为。 整堆收集(Full GC) 标记清除算法标记需要被回收的对象后，回收掉所有被标记的对象；或者标记不需要被回收的对象，同一回收未被标记的对象。 缺点：不稳定，标记清除的性能随着对象的增多而降低；空间碎片化问题，肯能会导致在分配较大对象时无法找到足够的连续空间内存不得不提前触发另一次垃圾收集动作。 标记复制算法为了解决标记清除算法面对大量可回收对象时执行效率低的问题。 优点：只需要复制少数存活对象，简单高效缺点：浪费内存空间。 根据弱分代假说，以及实际情况，大部分的对象在第一次垃圾回收时就会被回收，因此并不需要按照1:1的比例来划分新生代的内存空间。内存被分为较大的Eden区和较小的两个Survivor区域，HotSpot默认比例是8:1:1。打给你Survivor空间不足容纳一次MinorGC后存活的对戏那个时，就需要依赖其他内存区域进行分配担保。 标记整理算法根据老年代对象的存亡特征以及强分代假说提出的算法。将所有存活的对象向内存空间的一端移动，然后直接清理掉边界以外的内存。 吞吐量：赋值器和收集器的效率总和。如果在清理时移动，必然会影响到对象回收的效率。如果清理时不移动，必然会影响到对象分配的效率。 常见的垃圾收集器Serial / SerialOldSerial收集器是最古老的收集器，使用标记拷贝算法，在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。优点：在内存较小的桌面应用或者Client模式下，额外内存消耗最小，简单高效。 SerialOld同样是单线程收集起，使用标记整理算法。当CMS收集起发生失败时会转为SerialOld工作。 PS / POParalle Scavenge/ Paralle Old 的目标是达到一个可控的吞吐量。 ParalleScavenge 同样是基于标记-复制算法，支持多线程并发收集，吞吐量 = （运行用户代码时间）/(运行用户代码时间+运行垃圾收集时间)-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间-XX:GCTimeRatio 控制垃圾收集时间占总时间的比率-XX:+UseAdaptiveSizePolicy 就不需要人工指定新生代的大小，Eden于Survivor的比例，以及晋升老年代的大小，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 ParalleOld 收集老年代，基于标记整理算法。 ParNew / CMSParNew是Serial收集器的多线程并行版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集起完全一致。 CMD是一种以获取最短回收停顿时间为目的的收集器。符合希望系统停顿时间尽可能短，以给用户带来良好交互体验的需求。他是一种标记-清除算法实现的。包含四个步骤：1）初始标记2）并发标记3）重新标记4）并发清除 其中初始标记和重新标记这两个步骤仍需要STW。初始标记仅仅只是标记一下GC Roots能直接关联到的对象、速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长，但不需要停顿用户线程，可以与垃圾收集线程一起并发运行；重新标记为了修正并发标记期间因为用户程序继续运行导致标记产生变动的部分，这个阶段比初始标记耗时稍长；并发清除，清理删除掉标记阶段判断已经死亡的对象，不需要移动哦存活对象，因此这个阶段也是与用户线程同时并发。 CMS缺点：1） 耗CPU资源2） 无法处理浮动垃圾，由于预留的内存无法分配新对象时，有可能出现回收失败而导致退化到Serial Old的模式收集。3）分配占用大空间的对象时，会出现老年代还有很多剩余空间，但是无法找到足够大的连续空间分配对象，不得不提前触发FullGC。提供了两个参数优化，但是JDK1.9之后已经废弃：-XX:UseCMS-CompactAtFullCollection 不得不进行FullGC时开启内存碎片的合并整理。-XX:CMSFullGCsBefore-Compaction，要求CMS收集器在执行过若干次不整理空间的FullGC之后，下一次进入FullGC前进行碎片整理。 Garbage FirstG1时一款主要面向服务端应用的垃圾收集器。 在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。 G1面向堆内存任何部分来组成回收集（CollectionSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的MixedGC模式。 G1把连续的Java堆内存划分为多个大小相等的独立区域（Region），每个Region都可以根据需要扮演 新生代的Eden空间Survivor空间，或者老年代空间。收集器能够对不同角色的Region采用不同的=策略取处理，这样无论是新创建的对象还是存活了一段时间、经过多次收集的旧对象都能获得很好的收集再熬过。 Region中有一类Humongous区域专门存放大对象。 G1认为只要大小超过了一个Region容量的一般的对象就可以判定为大对象。每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围1MB～32MB，且应为2的N次幂。那些超过了整个Region容量的超级大对象，会被存放在N个连续的HumongousRegion之中，G1的大多数行为都把HumongousRegion作为老年代的一部分进行看待。 G因为将Region作为单词回收的最小单元，所以可以建立可预测的停顿时间模型。每次根据用户设置的停顿时间-XX:MaxGCPauseMillis， 优先处理回收价值收益最大的那些Region。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在悠闲的时间内获取尽可能高的收集效率。 需要解决的问题1）跨Region引用的对象： 每个Region都维护自己的记忆集避免全堆作为GCRoots扫描， 这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集是一种Hash表，Key时别的Region的起始地址，Value时一个集合，里面存储的元素时卡表的索引号。这种双向的卡表结构记录了我指向谁和谁指向了我，因此G1只少需要耗费大约10%～20%的额外内存来维持收集工作。 2）在并发阶段如何保证收集线程与用户线程互不干扰地运行？用户线程在改变对象引用关系的时候，必须保证不能打破原本的对象图结构，导致比阿吉结果出现错误，CMS使用增量更新算法，G1使用原始快照算法来实现。 垃圾收集对用户线程的影响还体现在回收过程中心窗卷对象的内存分配上，程序要继续运行就肯定会持续有新对象呗创建，G1位每个Region设计了两个名为TAMS（TOp at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时心分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象时被隐式标记过的，不纳入回收范围。如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致FullGC而产生长时间的STW。 3）如何建立可靠的停顿模型G1的停顿预测模型时以衰减均值为理论基础实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可以测量的步骤话费的成本，并分析得出平均值，标准偏差、可行度等统计信息，衰减平均值时比普通的平均值更容易受到新数据的影响，平均值更容易受到新数据的影响，平均值代表整体平均状态，衰减均值代表最近的平均状态。 Region的统计状态越新越能决定器回收的价值。通过这些信息预测现在开始回收的话，哪些region组成回收集采可以在不超过期望停顿时间的约束下获得最高的收益。 G1的回收步骤初始标记 只标记一下GCRoots能直接关联到的对象，并且修改TAMS指针的值，让下一个阶段的用户线程并发运行时，能正确滴在可用的Region中分配新对象。这个阶段需要停顿线程，但是耗时短，而且是借用进行MinorGC的时候同步完成，所以G1收集器在这个阶段实际并没有额外的停顿。 并发标记从GCRoots开始对对子红对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但是可以和用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。 最终标记对用户线程做另外一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 筛选回收负责更新Region的统计数据，对哥哥Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的Region的全部空间，对存活对象移动时必须暂停用户线程，但是由多条线程完成的。 G1从整体上来看是基于标记整理算法，但从局部来看时基于标记复制算法。无论如何，这两种算法意味着G1再与性期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发限一次收集。 G1位了垃圾收集产生的内存占用以及额外的执行副在都比CMS搞。内存占用是由于双向卡表占用空间大。CMs只记录了老年代到新生代的卡表记录。 负载：CMS用写后屏障维护更新卡表；G1除了使用写后屏障维护卡表外，位了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发前的指针变化。 原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点。 CMS的写屏障是同步操作，G1使用的是消息队列，把写前屏障和写后屏障中要做的事情都放在队列里，再异步处理。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"内存分配","slug":"内存分配","permalink":"https://www.hessentec.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"GC","slug":"GC","permalink":"https://www.hessentec.top/tags/GC/"}]},{"title":"线程和并发","slug":"线程和并发","date":"2020-06-08T10:44:20.000Z","updated":"2020-06-15T11:50:13.466Z","comments":true,"path":"2020/06/08/线程和并发/","link":"","permalink":"https://www.hessentec.top/2020/06/08/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%B9%B6%E5%8F%91/","excerpt":"","text":"目前线程是java中进行处理器资源调度的最基本单位。（Loom项目正在尝试改变线程这一重量级的实现） 实现线程的方式主要有三种： 使用内核线程1:1实现；内核系统就是由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。 使用用户线程1:n实现； 使用用户线程价轻量级进程混合实现（n：M实现） Java线程的实现《Java虚拟机规范》中没有限定使用哪种线程模型来实现，主流平台上的主流商用Java虚拟机线程模型普遍都给予操作系统原生线程模型来实现（1:1的线程模型） Java线程调度线程调度是指系统为线程分配处理器使用权的过程，调度方式分为两种： 协同式线程调度线程的执行时间由线程本身来控制，线程把自己的工作执行完之后，同志系统切换到另外一个线程。 抢占式线程调度每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。Java可以使用thread.yield()方法主动让出执行时间，但是并不能主动获取执行时间。 线程的优先级我们并不能在程序中通过优先级来完全准确判断一组状态都为Ready的线程先执行哪一个？ 状态转换Java语言定义了6中线程状态，在任意一个时间点中， 一个线程只能有且只有一种状态，并且可以通过特定的方法在不同状态之间转换。 新建：new，创建后尚未启动的线程处于新建状态； 运行：runnable，包括操作系统线程状态中的Running和Ready， 等待：Waiting，处于这种状态的线程不会被分配处理器执行时间，它们需要被其他线程显示唤醒。以下方法可以让线程无限期等待： 没有设置timeout参数的Object.wait()方法； 没有设置timeout参数的Thread.join()方法； LockSupport.part()方法； 限期等待：处于这种状态的线程也不会被分配处理器执行时间，在一定时间后会有系统自动唤醒。 Thread.sleep() 设置了Timeout的Object.wait() 设置了Timeout的Thread.join() LockSupport.parkNanos(); LockSupport.parkUntil(); 阻塞：Blocked，在程序等待进入同步区域的时候，线程将进入阻塞状态。 结束: Terminated，已终止线程的线程状态，线程已经结束执行。 线程安全当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要执行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。 也就是代码本身封装了所有必要的正确性保障手段，令调用者无序关心多线程下的调用问题，更无需自己实现任何措施来保证多线程环境下的正确调用。 不可变在Java语言中，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。 只要一个不可变的对象被正确的构建出来，那其外部的可见状态永远都不会改变，永远都不会看到他在多个线程之中处于不一致的状态。 绝对线程安全绝对的线程安全除了对象本身外， 还需要在调用端做相应的同步措施。 相对线程安全保证这个对象在单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。在Java中，相对线程安全的类型有Vector、HashTable、Collections.synchronizedCollection(); 线程兼容对象本身并不是线程安全的， 但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中可以安全使用。Vector、HashTable、ArrayList、HashMap等都是线程兼容的。 线程对立如果两个线程同时持有一个线程对象，一个尝试去中断线程、一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在思索的风险。（Thread类的suspend和resume方法），常见的对立操作还有System.in() System.out()和System.runFinalizersOnExit(); 线程安全的实现方法互斥同步用互斥来实现同步。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。因此它面临的问题是进行线程阻塞和唤醒所带来的性能开销，因此也叫阻塞同步。属于一种悲观的并发策略。 synchronized（非公平锁）java.util.concurrent.locks.LockReentrantLock（非公平锁） 可重入锁比synchronized增加了一些高级功能： 等待可中断当持有锁的线程长期不释放所得时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁多个线程在等待同一个锁的时候，必须按照申请锁的时间顺序依次获得锁。 锁绑定多个条件一个ReentrantLock对象可以同时绑定多个Condition对象， 多次调用newCondition()即可。 非阻塞同步基于硬件冲突检测的乐观并发策略，也就是说先进性操作，如果没有其他线程争用共享数据，操作成功；如果共享数据被争用，产生冲突，那么再进行其他的补偿措施，最常用的补偿措施就是不断重试，直到成功。这种方式不需要阻塞线程，因此也叫无锁编程。常用的具有原子性的硬件操作和冲突检测指令有： 测试并设置（Test-And-Set） 获取并增加（Fetch-And-Increment） 交换（Swap） 比较并交换（Compare And Swap） 加载链接/条件存储（Load-Linked/ Store-Conditional） Java中暴露出来的是CAS指令，当CAS指令执行时，当且仅当内存地址V的值符合预期值A时，处理器才会用新的值B更新内存地址V的值，该过程是一个原子操作，执行期间不会被其他线程中断。 CAS存在的ABA问题，大部分情况下不会影响程序并发的正确性，如果需要解决该问题，传统的互斥同步可能会比原子类更为高效。 无同步方案如果可以让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的。 可重入代码如果一个方法的返回结果是可预测的，只要输入了相同的数据，就就能返回相同的结果，那么它就满足可重入性的要求，当然他就是线程安全的。可重入代码不依赖于全局变量、存储在队上的数据和公用的系统资源，用到的状态量都由参数重传入，比调用非可重入的方法等。 线程本地存储如果一段代码中使用的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。这样就可以把共享数据的可见范围限制在一个线程之内。常见的有生产者消费者模式（Web交互模型）。ThreadLocal的使用。 锁优化自旋锁和自适应自旋互斥同步的时候需要对线程进行挂起和恢复，但是挂起和恢复需要陷入内核态来完成。因此当一个线程获取锁的时候，如果暂时没有获取到，那么让他稍微等一会儿，但不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁。 如果锁被占用很长的时间，那么自旋的线程只会白白消耗处理器资源。因此自旋等待时间必须有一定的限度。如果自旋超过了限定的次数，仍然没有成功获得锁，就应当使用传统方式去挂起线程。 自旋锁的实现几种自旋锁的java实现认真的讲一讲：自旋锁到底是什么看完你就明白的锁系列之自旋锁 锁消除虚拟机即使编译器在运行时，判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当作栈上的数据对待，认为他们是线程私有的，消除同步锁的过程。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的， 可以把加锁同步的范围扩展到整个操作序列的外部。 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 Hotspot对象头分为两部分：1）用于存储对象自身运行的数据，如哈希吗，GC分代年龄。这部分数据的长度在32位和64位的Java虚拟机中分别占用32个或者64比特。这部分是实现轻量级锁和偏向锁的关键。2）用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分存储数组长度。 由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，MarkWord被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态服用自己的存储空间。在32位的Hotspot虚拟机中，对象未被锁定的状态下，MarkWord的32个比特空间有25个比特用于存储对象的哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特股定位0（表示未进入偏向模式）。对象除了违背锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种状态。 如果代码即将进入同步块的时候，如果此同步对象没有被锁定（标志位位01），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（LockRecord）的空间,用于存储锁对象目前的MarkWord的拷贝。 然后虚拟机将使用CAS操作尝试把对象的markword更新为指向LockRecord的指针。如果这个更新成功，那么代表该线程拥有了这个对象的锁，并且对像MarkWord的锁标志位将转变为00，表示此对象处于轻量级锁定状态。 如果更新操作失败，意味着至少存在一个线程与当前线程竞争获取该对象的锁。虚拟机首先检查对象的MarkWord是否只想当前线程的栈帧，如果是，说明线程已经拥有了这个对象的锁，那么直接进入同步块继续执行，否则说明这个对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那么轻量级锁不再有效，必须要膨胀为重量级锁，锁标志的状态变为10， 此时Markword中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态。 它的解锁过程也是通过CAS来进行的，如果对象的MarkWord仍然指向线程的锁记录，那就用CAS操作把对象当前的MarkWord和线程中复制的DisplacedMarkWord替换回来，如果替换成功，说明解锁成功。替换失败，说明有其他线程尝试过获取该锁，需要在释放锁的同时唤醒被挂起的线程。 如果没有竞争，轻量级锁能通过CAS操作成功避免使用互斥量的开销；如果存在竞争，除了互斥量本身开销外，还额外发生了CAS操作的开销，因此性能更差。 偏向锁用于消除数据在无竞争情况下的同步，连CAS都去掉了，进一步提高程序的运行性能。偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一致没有被其他的线程获取，则持有偏向锁的线程永远不需要再同步。 如果当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的MarkWord中。如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块是，虚拟机都可以不再进行任何同步操作。 一旦出现另外一个线程尝试获取这个锁的情况，偏向模式马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（把偏向模式设置为0），撤销后标志位恢复到为锁定或者轻量级锁定的轧辊台，后续的同步操作按照轻量级锁执行。 当进入偏向状态是，MarkWord大部分的空间都用于存储持有锁的线程ID，这部分空间占用了原有存储对象Hash码的位置。当一个对象已经计算过一次一致性哈希码后，它就再也无法进入偏向锁状态。当一个对象正在处于偏向锁状态时，受到计算hash码的请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。 在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类中有字段可以记录非加锁状态下的MarkWork，其中自然可以存储原来的哈希码。 偏向锁可以提高带有同步但无竞争的程序性能，但如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[]},{"title":"IO-2","slug":"IO-2","date":"2020-06-07T12:37:05.000Z","updated":"2020-06-07T14:36:42.472Z","comments":true,"path":"2020/06/07/IO-2/","link":"","permalink":"https://www.hessentec.top/2020/06/07/IO-2/","excerpt":"","text":"多路复用器：select/poll/epoll man 2 select man 2 poll 2.链路层，3网络层，4传输层封存あ记忆","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"分布式锁","slug":"分布式锁","date":"2020-06-06T01:10:02.000Z","updated":"2020-06-06T03:06:00.089Z","comments":true,"path":"2020/06/06/分布式锁/","link":"","permalink":"https://www.hessentec.top/2020/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"1) 可重入锁CAS2）同步：3）信号量公平锁、非公平锁、读写锁、自旋锁分布式锁， 悲观锁、乐观锁, 锁续租","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[]},{"title":"字节码执行引擎","slug":"字节码执行引擎","date":"2020-06-04T22:56:36.000Z","updated":"2020-06-07T02:07:51.747Z","comments":true,"path":"2020/06/05/字节码执行引擎/","link":"","permalink":"https://www.hessentec.top/2020/06/05/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/","excerpt":"","text":"当代码被编译成二进制字节码，由Classloader加载到内存，经过加载、验证、准备、解释后将数据转化为JVM可以接受的格式存储到方法区，并在堆内存中创建一个Class对象，作为外部访问的入口。接下来就由字节码执行引擎来解释执行代码。 《Java》虚拟机规范中规定了Java虚拟机字节码执行引擎的概念模型，输入字节码二进制流，输出执行结果。 在不同的虚拟机实现中，执行引擎在执行字节码的时候会有两种： 解释执行（Sun Classic 虚拟机） 编译执行（Jrockit） 两种兼备 (HotSpot) 运行时栈帧结构栈帧是用于支持虚拟机方法进行调用和执行的数据结构，每个方法从调用开始到执行结束的过程，都对应一个栈帧从虚拟机栈中入栈到出栈的过程。 栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 栈帧中需要多大的局部变量表、多深的操作数栈在编译Java的时候就已经计算出来存放在方法表的Code属性中。 局部变量表用于存放方法参数和方法内部定义的局部变量。 在代码被编译成Class文件时，在方法的Code属性中max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽应该可以存放一个boolean、byte、char、short、int、float、reference、returnAddress这8种不超过32位数据类型（对于超过32位的long和double，则使用两个32位的变量槽）。 引用类型： 通过引用可以找到这个对象在堆中的数据存放的起始地址或者索引； 找到对象所属类型在方法区中的存储类型； returnAddress是为字节码指令jsr、jsr_w 和ret服务，指向了一条字节码指令的地址，一些jvm使用这几条指令来实现异常处理时的跳转。现在全部改为采用异常表来代替。 当一个方法被调用的时候，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，如果是实例方法局部变量表第0位索引的变量槽存放的是this。 以恰当的变量作用域来控制变量的回收时间才是最优雅的解决方法，而不是使用完后就将其引用赋予null， 因为这仅仅是基于虚拟机的概念模型层面作出的优化，虚拟机的具体实现不同，解释执行与编译执行结果都不同。 操作数栈一个后入先出的栈，同局部变量表一样，操作数栈的最大深度也在编译的时候就被写入到Code属性的max_stacks数据项中。32位数据类型所占用的栈容量是1， 64位数据类型所占的栈容量是2. 通过将操作数入栈出栈来进行算术运算；通过操作数栈将方法的参数进行传递； 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用时为了支持方法调用过程中的动态连接。 Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令以常量池指向方法的符号引用作为参数。 这些符号引用一部分在类加载阶段或者第一次使用会被转化为直接引用；另一部分在每次运行期间都转化为直接引用，这部分称为动态连接； 方法返回地址当一个方法退出以后，必须返回到最初方法被调用时的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，来帮助恢复主调方法的执行状态。 一个方法的退出有两种方式：第一种是执行引擎遇到方法返回的字节码指令；主调方法的PC计数器的值就可以作为返回地址。另一种是遇到了异常，并且在本方法的异常表中没有搜索到匹配的异常处理器导致方法退出； 方法调用方法调用阶段的任务是确认被调用方法的版本。Class文件的编译过程不包含传统程序语言的连接步骤，一切方法调用在Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址。因此一些调用需要在加载期间，甚至到运行期间才能确定目标方法的直接引用。 解析在类加载的解析阶段，将静态方法和私有方法对应的符号引用转化为直接引用。因为静态方法与类关联，私有方法不可能被继承或者重写，在编译阶段即可确定。 字节码指令集设计了不同的指令调用不同类型的方法： invokestatic, 调用静态方法 invokespecial, 调用实例构造器方法，私有方法，父类中的方法。 invokevirtual, 用于调用所有的虚方法（被final修饰的方法） invokeinterface,用于调用接口方法，会在运行时再确定一个实现接口的对象 invokedynamic, 在运行时动态解析出调用点限定符引用的方法。 前四条指令，分派逻辑都固化在Java虚拟机内部，invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。 只要能被invokestatic 和 invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本。Java语言中符合这个条件的方法有静态方法、构造方法、私有方法、父类方法和被final修饰的方法,这五种方法被称为非虚方法，其他的被称为虚方法。 解析调用是一个静态的过程， 在类加载的解析阶段就把涉及的符号引用转换为明确的直接引用，不必延迟到运行期再去完成。 分派 静态分派所有依赖静态类型来决定方法执行版本的分派叫做静态分派。静态分派的典型应用表现是方法重载。方法重载发生在同一个类中，方法名称相同，参数列表不同。 动态分派与实现在运行期根据时机类型确定方法执行版本的分派过程叫动态分派，它就是Java语言中方法重写的本质。多态的根源在于虚方法调用指令invokevirtual的执行逻辑，因此多态只对方法有效，对字段无效（字段永远不参与多态）。 动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接受着类型方法元数据中搜索合适的目标方法， 单分派和多分派方法的接收者（要被执行的方法的所有者叫接收者）与参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择；多分派是根据多个宗量对目标方法进行选择； Java中的解释执行与编译执行 在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树。 对于C/C++来说，词法、语法分析以后到后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整有意义的编译器去实现，这类就是编译执行。 对于Java来说，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再便利语法树生成线性的字节码指令流的过程。 基于栈的指令集与给予寄存器的指令集 基于栈的指令集零地址指令，依赖操作数栈进行工作，优点是可移植性高，不与具体的硬件绑定。编译器实现简单。缺点是速度慢。 给予寄存器的指令集而地址指令集，物理硬件直接支持的指令集架构，依赖寄存器工作。 虚拟机最终会对执行过程作出一系列优化来提高性能， 实际的情况会和盖面模型差距非常大，差距产生的根本原因是虚拟机中解析起和即时编译起都会对输入的字节码进行优化，即使解释其中也不是按照字节码指令去逐条执行的。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"字节码执行引擎","slug":"字节码执行引擎","permalink":"https://www.hessentec.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"}]},{"title":"etcd","slug":"etcd","date":"2020-06-04T13:34:15.000Z","updated":"2020-06-04T14:30:39.437Z","comments":true,"path":"2020/06/04/etcd/","link":"","permalink":"https://www.hessentec.top/2020/06/04/etcd/","excerpt":"","text":"培养良好的生活、学习、工作习惯。 相关概念： Etcd coreOS RancherOS 主机规划： 要求：主机名称规范、IP段相邻、备注明确 主机序号 名称 内网IP 外网IP CPU核数 内存大小 备注 01 etcd-node-master-01 10.0.0.1 外网IP 2 4G 备注 02 etcd-node-slave-02 10.0.0.2 外网IP 2 4G 备注 03 etcd-node-slave-03 10.0.0.3 外网IP 2 4G 备注 设置主机名称123hostnamectl set-hostname etcd-node-master-01hostnamectl set-hostname etcd-node-slave-02hostnamectl set-hostname etcd-node-slave-03 修改内网IP地址：1vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 重启网关：1systemctl restart network 防火墙设置：12firewall-cmd --zone&#x3D;public --add-port&#x3D;2379&#x2F;tcp --permanentfirewall-cmd --reload YUM安装：1yum install -y etcd 验证&amp;查看版本12rpm -qa etcdetcdctl -v 修改配置：分别修改3个主机的配置文件/etc/etcd/etcd.conf 注意！修改前一定要备份！ cp /etc/etcd/etcd.conf /etc/etcd/etcd.conf.bak 12345678ETCD_LISTEN_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2380&quot;ETCD_LISTEN_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2379,http:&#x2F;&#x2F;127.0.0.1:2379&quot;ETCD_NAME&#x3D;MasterETCD_INITIAL_ADVERTISE_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2380&quot;ETCD_ADVERTISE_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;10.0.0.1:2379&quot;ETCD_INITIAL_CLUSTER&#x3D;“Master&#x3D;http:&#x2F;&#x2F;10.0.0.1:2380,Node02&#x3D;http:&#x2F;&#x2F;10.0.0.2:2380,Node03&#x3D;http:&#x2F;&#x2F;10.0.0.3:2380&quot;ETCD_INITIAL_CLUSTER_TOKEN&#x3D;&quot;etcd-cluster&quot;ETCD_INITIAL_CLUSTER_STATE&#x3D;&quot;new&quot; 重启etcd服务1systemctl restart etcd 查看Etcd集群1etcdctl member list Etcd 测试12etcdctl set name testetcdctl get name 扩展概念123456789101112131415161718负载均衡：区域负载均衡：DNS硬件负载均衡：F5&#x2F;A10软件负载均衡：Nginx&#x2F;LVS&#x2F;HAProxy磁盘阵列：raid防火墙技术：硬件&#x2F;软件NTP（Network Time Protocal）是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化tongbuwang。Radis的分布式缓存;mysql主从、读写分离、高可用、分库分表；MHA备份elk ci&#x2F;cdcentos8 &#x2F; podman","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Etcd","slug":"Java技术栈/Etcd","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Etcd/"}],"tags":[{"name":"Etcd","slug":"Etcd","permalink":"https://www.hessentec.top/tags/Etcd/"}]},{"title":"JVM运行时数据区域","slug":"JVM运行时数据区域","date":"2020-06-02T13:01:41.000Z","updated":"2020-06-04T00:26:33.272Z","comments":true,"path":"2020/06/02/JVM运行时数据区域/","link":"","permalink":"https://www.hessentec.top/2020/06/02/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"当一个类加载到内存后，JVM运行时数据区域都需要存储什么东西呢？ 1）类的格式信息、主次版本号、 常量池、字段、方法、属性信息需要存储，这部分数据需要每个线程共享； 当类加载器将静态的二进制字节码从类文件加载到内存后，对内容进行验证、解析转换为符合JVM存储的数据格式。 2）生成的Class类对象和代码运行时动态创建的对象和数组需要存储； 通过loading、linking、initializing后生成的Class对象，做为程序访问这个类的入口， 以及程序运行时产生的对象和数组，都有可能会被不同的线程引用和访问，因此这部分区域的数据也需要线程共享。3）每个线程的线程数据需要存储和每个线程下方法的方法数据需要存储； 当线程创建的时候需要有一个线程栈来存放线程信息，以及PC计数器记录当前线程正在执行的代码行号。 还有JVM本地线程执行时需要的本地线程栈存放本地线程的执行情况。 《Java虚拟机规范》规定了如下内存区域来存储数据 共享区域 堆区 方法区 运行时常量池 线程私有区域 JVM线程栈 本地方法栈 PC计数器 堆区 几乎所有的对象以及数组都存放在堆区。 方法区 用于存储已经被虚拟机加载的类型信息、常量、静态变量、及时编译器变异后的代码缓存等数据。 运行时常量池 运行时常量池是方法区的一部分，用于存放编译期或者运行期生成的各种字面量和符号引用。 Java虚拟机栈 每个线程会生成一个线程栈，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口信息。 局部变量表局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、long 、float、double）、引用类型、returnAddress类型。 这些数据类型在局部变量表中的存储空间以局部变量槽来表示（64位的long和double占用2个变量槽，其余数据类型占用1个变量槽）。局部变量表所需的内存空间在编译期完成分配，因此当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是确定的。在运行期间是不会改变局部变量表的大小（槽的多少）。 本地方法栈与虚拟机栈作用类似，为虚拟机使用到的本地方法服务。 PC计数器 当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 对于JDK1.8以后HotSpot虚拟机改用与Jrokit、J9一样与本地内存中实现的元空间（Meta-space）来实现方法区。无论是原空间还是永久代，他们只是方法区的实现，字符串常量池和静态变量的存储逻辑上仍然属于方法区。元空间使用的是物理内存、永久代使用的是JVM内存。因此元空间的大小只受限于物理内存。 HotSpot 虚拟机对象的创建与引用对象的创建1） 在new一个对象的时候，先需要通过类加载检查，然后虚拟机为新生对象分配内存。 对象所需要的内存大小在类加载完成后便可以完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。 指针碰撞假设内存规整，将使用过的在一边，空闲的在一边，中间放一个指针作为分界点的指示器，所分配内存就是把指针向空闲空间方向挪动一段与对象相等的距离。使用Serial、ParNew带压缩整理过程的GC收集器时，采用指针碰撞，简单高效； 空闲列表假设内存不规整，是一块块不连续的，那么就需要维护一个列表记录哪块内存可用，哪块内存不可用，在分配的时候在列表中找一块足够大的空间划分给对象实例，并更新列表上的记录。使用CMS基于清除算法的收集器时，理论上只能采用复杂的空闲列表来分配内存。 Thread Local Allocation Buffer在堆中创建对象是特别频繁的事情，并且涉及到多线程的访问。如何保证高效且安全的申请空间？ 同步或者CAS+失败重试的方式保证更新操作的原子性； 为每个线程在堆中预先分配一小块内存，通过-XX:+/-UseTLAB 设定； 2）分配完内存后，为内存空间初始化零值以及必要的设置。初始化零值可以保证对象实例字段在Java对象中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。之后设置这个对象的类型、关联类的元数据信息、GC分代年龄信息等。 3）执行 &lt;init&gt;() 方法，将对象进行初始化。 对象的内存布局在Hotspot虚拟机中，对象在内存中的存储布局划分为三个部分 对象头（Header） 一部分是对象自身运行时数据，HashCode, GC分代年龄，锁状态标志，线程持有锁，偏向线程ID,偏向时间戳（数组长度）。 一部分是类型指针，指向它的类型元数据的指针，用来确定是哪个类的实例。 实例数据（Instance Data）字段的存储顺序受到虚拟机分配策略（-XX:FieldsAllocationStyle）和字段在源码中的顺序影响。默认相同宽度的字段被分配到一起存放，父类中定义的变量会出现在子类之前。使用+XX:CompactFields=true字类中较窄的变量也会插入到父类变量的空隙之中。 填充（Padding）为了满足硬件的性能需求和提高垃圾回收时指针扫描的方便性。HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8个字节的整数倍（任何对象的大小必须是8个字节的整数倍）。 对象的访问定位对象在堆中创建好了，Java程序会通过栈上局部变量表中的reference字段来引用堆上的对象。 句柄访问Java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自具体的地址信息。好处：reference中存储的事稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针。 直接指针reference中存储的是对象的地址。好处是速度快，节约了指针定位的时间开销。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"运行时区域","slug":"运行时区域","permalink":"https://www.hessentec.top/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F/"}]},{"title":"JVM内存模型","slug":"JVM内存模型","date":"2020-06-02T12:11:09.000Z","updated":"2020-06-08T10:41:45.604Z","comments":true,"path":"2020/06/02/JVM内存模型/","link":"","permalink":"https://www.hessentec.top/2020/06/02/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"计算机为了提升效率，增加了多内核，并且为每个内核增加了自己的高速缓存，而他们又共享同一个主内存。 除了增加高速缓存外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，但保证结果与顺序执行的结果一致。 与处理器的乱序执行优化类似，Java虚拟机的即时编译器也有指令重排序优化。 Java内存模型《Java虚拟机规范》中曾试图定义一种Java内存模型来屏蔽各种硬件和操作系统的内存访问差异。 主内存与工作内存Java内存模型的主要目的是定义程序中各种变量的访问规则（关注虚拟机中把变量存储到内存和从内存中取出变量的底层细节。）Java内存模型规定了所有的变量都存储在主内存（除线程私有的以外）。线程的工作内存保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存的数据。不同的线程之间也无法直接访问对方工作内存的变量，线程之间变量值的传递均需要通过主内存来完成。 内存间交互操作关于主内存与工作内存之间的交互协议，Java内存模型中定义了8种的操作。 Java虚拟机实现时必须保证每种操作都是原子的，不可再分的（对于double和long来讲，load、store、、read、write允许有例外）。 lock ： 锁定，作用于主内存的变量，把一个变量标识为一条线程独占的状态。 unlock: 解锁，作用于主内存的变量，把一个处于锁定状体的变量释放出来，释放后的变量才可以被其他线程锁定。 read: 读取，作用于主内存的变量，把一个变量的值从主内存传输到工作内存，以便随后的load动作使用。 write: 写入，作用于主内存的变量，把store操作从工作内存中得到的变量值存放到主内存变量中。 load: 载入，作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use：使用，作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign: 赋值，作用于工作变量，把一个从执行引擎接收的值赋给工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store: 存储，把工作内存中一个变量的值传送到内存中，以便随后的write操作使用。 Java内存模型规定必须满足如下规则： 1) 不允许read 和 load、store和write操作单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写单主内存不接受2）不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。3）不允许一个线程在没有发生assign操作就把数据从线程的工作内存同步回主内存中。4) 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load\\assign）的变量,即对一个变量进行use之前必须使用load， 使用store之前必须使用assign。。5）一个变量在同一个时刻内只允许一个线程对其进行lock操作， 但lock操作可以被同一个线程重复执行多次， 多次执行lock后， 只有执行相同次数的unlock操作，变量才会被解锁。6)对一个变量执行unlock之前， 必须先把此变量同步回主内存中（执行store、write操作） volatile型变量的特殊规则volatile是Java虚拟机最轻量级的同步机制。它有两个特性：1）保证此变量对于所有线程的可见性（一个线程修改了这个变量的值，其他线程立即可见，也就是每个线程在使用被volatile修饰的变量时，都会强制从主内存中同步该变量的值到工作内存中） 在不符合以下两条规则的场景中，仍然需要通过加锁来保证原子性（synchronized、java.util.concurrent中的锁或者原子类）： 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值； 变量不需要与其他状态变量共同参与不变约束； 2） 禁止指令重排序优化 volatile变量读操作的性能与普通变量几乎没有差别，但是写操作会慢些， 因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 Singleton DoubleCheck12345678910111213141516public class Singleton &#123; private Singleton() &#123;&#125; private volatile static Singleton instance &#x3D; null; public static Singleton getInstance() &#123; if (instance &#x3D;&#x3D; null) &#123; synchronized (Singleton.class) &#123; if (instance &#x3D;&#x3D; null) &#123; instance &#x3D; new Singleton(); &#x2F;&#x2F;warning &#125; &#125; &#125; return instance; &#125;&#125; 在上面的代码中，instance = new Singleton()最终会被编译成多条汇编指令。（1）为Singleton的实例分配内存。（2）调用Singleton的构造函数，初始化成员变量（3）将instance对象指向分配的内存空间。 或者可能被重排序为(1)、(3)、（2）， 也就是当分配内存后，如果没有对instance 加volatile，将instance对象指向分配的内存空间后，另外一个线程可以读到未被初始化的对象。 针对long和double类型变量的特殊规则Java内存模型要求lock、unlock、read、write、 load、assign、use、store这8种操作都具有原子性，但是对于64位数据类型的long 和double, 在模型中定义了一条宽松的规定， 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为2次32为的操作来执行，也就是虚拟机自己选择是否要保证64位数据类型的load、store、read、write这四个操作的原子性。 经过实际的测试，在目前的主流平台下商用的64位Java虚拟机中并不会出现非原子性访问行为，但是对于32位的Java虚拟机（如32位的X86Hotspot）存在非原子性访问的风险。 因此，在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码的时候一般不需要因为这个原因刻意把用到的long和double变量专门声明位volatile。 原子性、可见性与有序性原子性（Atomicity）有Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write。因此基本数据类型的访问都是具备原子性的。 如果应用场景需要一个更大范围的保证，需要使用锁、或者synchronized关键字来保证原子性。（lock、unlock并没有直接开放给用户使用）。 可见性（visibility）可见性就是当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。 volatilevolatile的特殊规则保证了新值立即能同步到主内存，以及每次使用前都立即从主内存刷新。而普通变量则不能保证“立即”。 synchronized同步块的可见性时由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得。 final被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么在其他线程中就能看见final字段的值。 this引用逃逸，其他线程有可能通过这个引用访问到“初始化了一般”的对象。 有序性如果在本线程中观察，所有的操作都是有序的（线程内似表现为串行的语义）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟现象）； Java语言提供了volatile和sychronized两个关键字来保证线程之间的有序性。volatile：本身包含了禁用指令重排序的语义；synchronized：一个变量在同一时刻只允许一个线程对其进行lock操作； 先行发生原则先行发生原则：判断数据是否存在竞争，线程是否安全的重要手段。 程序次序规则：在一个线程内，按照控制流顺序（分支、循环等），书写在前面的操作先行发生在书写在后面的操作； 管程锁定规则：一个unlock的操作先行发生在后面对同一个锁的操作。 volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作； 线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作； 线程的中止规则：线程中所有的操作都先行发生于此线程的终止检测，可以通过thread.join()方法是否结束、thread.isAlive()返回值来检测线程是否已经停止； 线程的终端规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过thread.interrupted()检测是否有中断发生； 对象终结规则：一个对象初始化完成（构造函数执行结束）先行发生于他的finalize()方法的开始； 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出，操作A先行发生于操作C。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"JMM","slug":"JMM","permalink":"https://www.hessentec.top/tags/JMM/"}]},{"title":"类加载器和类加载机制","slug":"ClassLoader","date":"2020-05-31T23:34:37.000Z","updated":"2020-06-04T00:26:39.606Z","comments":true,"path":"2020/06/01/ClassLoader/","link":"","permalink":"https://www.hessentec.top/2020/06/01/ClassLoader/","excerpt":"","text":"Java代码要在JVM中正常运行，首先要先编译成.class文件，由类加载器将其加载到内存中。之后由类编译器来编译执行。在加载的过程中需要注意什么呢？1）什么时候需要加载一个类呢？2）随便任何一个文件都是否可以被加载呢，它的加载过程是什么样的？3）类加载器需要对内存中的内容做什么工作才可以被JVM直接使用？ 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Class类型，这就是虚拟机的类加载机制。—《深入理解Java虚拟机》 12类型的加载、链接和初始化过程都是在程序运行期间完成的。Java可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 类的加载时机 Java虚拟机规范并没有规定什么时候加载类，但是规定了什么时候初始化一个类。 虚拟机规范严格规定了有且只有5中情况必须立即对类进行“初始化”。 1）遇到new、getstatic、putstatic、invokestatic； 2）初始化类的时候，对父类进行初始化； 3）JVM执行的时候，对主类进行初始化； 4）使用java.lang.reflect包的方法对类进行反射调用时； 5）使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandler实例最后解析结果是REF_getstatic, REF_putstatic, REF_invokestatic时，对该类进行初始化； 6) jdk1.8中子类实现的接口中定义了default方法时； 类的加载过程类的加载过程总共分为：Loading（加载）、Linking（连接）、Initializing（初始化）、Using（使用）、Unloading（卸载）。其中 Linking阶段 分为 Verification（验证）、Preparation（准备）、Resolution（解析）。 加载加载阶段的成果是生成Class类对象，并将该对象存储在堆中。Class对象作为访问该对象数据的访问入口。加载的步骤：1） 根据类的全限定名读取类的二进制字节流；2） 对二进制字节流进行解析转换，并将类信息存储在方法区中；3） 堆中生成Class类对象，作为程序访问方法区中的类型数据的外部接口； 注意：数组类不通过类加载器创建，由java虚拟机直接在内存中动态构造出来的。数组的元素类型（去掉所有维度）要靠类加载器加载完成。数组的组件类型（去掉一个维度）是引用类型，数组将被标识在加载该组建类型的类加载器的类名称空间上。如果数组的组件类型不是引用类型，Java虚拟机会把数组标记为与引导类加载器关联。 验证验证加载的类信息是否符合Java虚拟机规范，类的实现和继承、方法的执行、对象和方法的可访问性等等，主要分为四个阶段： 1）文件格式的验证 主要对Class文件中内容进行验证，是否符合Java虚拟机规范。 比如魔数、常量池的类型、指向常量的索引值是否存在或者类型是否正确等等； 这个阶段的验证是基于二进制字节流进行的，只有通过了验证才会被允许进入Java虚拟机的内存方法区存储。 2）元数据验证 对字节码描述信息进行语义分析，保证描述信息符合《Java语言规范》比如: 这个类是否有父类、父类是否允许继承（被final修饰）； 这个类是否实现了父类所要求实现的所有方法； 类中的字段、方法是否与父类产生矛盾； 3）字节码验证 对类的方法体进行验证，保证任何跳转指令都不会跳转到方法体以外的字节码指令上； 保证类型转化都是有效的. 4）符号引用验证 虚拟机在解析阶段将符号引用转化为直接引用的时候，对符号引用进行验证； 符号引用中通过字符串描述的全限定名能否找到对应的类； 在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段； 符号引用中的类、字段、方法的可访问性是否可以被当前类访问； 符号引用阶段抛出的异常有：IllegalAccessError、NoSuchFieldError、NoSuchMethodError； 准备准备阶段是正式为类中定义的变量分配内存并设置类变量初始值的阶段； 对于类变量（静态属性），设置的是“零值”，真正赋值是在初始化阶段；对于常量（final static），会被设置为ConstantValue属性所指定的初始值。 对于常量，Javac时会为value生成ConstantValue属性。 解析解析阶段是Java虚拟机将常量池的符号引用替换为直接引用的过程。《Java虚拟机规范》并没有规定何时进行解析。 符号引用：可以无歧义的定位到目标即可；与虚拟机的内存布局无关；引用的目标不一定已经加载到虚拟机中；必须遵循《Java虚拟机规范》； 直接引用：直接可以指向目标的指针、偏移量，或者可以间接定位到目标的句柄；与虚拟机的内存布局直接相关；直接引用的目标一定已经加载到虚拟机内存中； 解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符号引用进行。 类、接口解析：虚拟机的完整解析过程：1）如果不是一个数组类型，虚拟机将会把全限定名传给当前类的加载器去加载，在加载的过程中，由于元数据验证、字节码验证的需要，又可能出发其他相关类的加载动作。2）如果是一个数组类型，并且数组的元素类型为对象，那么会按照第一点的规则加载数组元素类型。如果是基础数据类型包装类，那么由虚拟机生成一个代表该数组唯独和元素的数组对象；3）前面两部解析OK后进行符号引用验证，确定当前类是否有加载类的访问权限。 如果一个类拥有另外一个类的访问权限，那么至少有一条是成立的：1）被访问类是public的，并且与访问类处于同一个模块；2）被访问类是public的，不与访问类处于同一个模块，但是被访问类的模块允许访问类访问；3）被访问类不是public的，但是与访问类处于同一个包中 字段解析对字段表内class_index项中索引的CONSTANT_Class_Info符号引用进行解析（即字段所属类） 1）先查找当前类是否包含了简单名称与描述符与目标相匹配2）从下往上的顺序查找实现的接口类3）从下往上的顺序查找父类4）都无法查找到，抛出java.lang.NoSuchFieldError. 如果查找成果返回了引用，将会对这个字段进行权限验证，对于不具备权限的访问会抛出IllegalAccessError； 方法解析解析出方法表class_index项中索引的方法所属的类或者接口的符号引用。具体的解析过程与字段解析类似。 接口方法解析与方法解析类似。 初始化这个阶段Java虚拟机才真正开始执行类中编写的程序代码。程序在这个阶段初始化类变量和其他资源。 初始化阶段也是执行&lt;clinit&gt;()的过程。&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的；编译器收集顺序是由语句在源文件中出现的顺序决定的；静态语句块中智能访问到定义在静态语句块之前的变量；定义在静态语句块后的变量，静态语句块可以赋值，但是不能访问；Java虚拟机保证父类的&lt;clinit&gt;() 总是优先于子类的&lt;clinit&gt;()执行； 如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器可以不为这个类生成clinit()方法。 类加载器类加载器主要通过一个类的全限定名来获取描述该类的二进制字节流，它处于Java虚拟机的外部，方便让应用程序自己决定如何获取所需的类。 对于任意一个类，必须由加载它的类加载器与类本身来确定在Java虚拟机中的唯一性。每个类加载器都拥有一个独立的类名称空间。 类加载器的双亲委派模型 双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应有自己的父“类加载器”。当类加载器需要加载一个类的时候，首先看该类是否已经被加载，如果没有被加载则尝试着让父“类加载器”去加载，如果没有父“类加载器”则让bootstrapClassLoader作为父“类加载器”，如果父“类加载器”加载失败，则使用自己的find_class方法去加载。 启动类加载器（Bootstrap Class Loader）启动类加载器负责加载&lt;JAVA_HOME&gt;\\lib 目录下的jar包（按名字识别，名字不符合的类库存放在lib目录下也不会被加载），也可以指定 -Xbootclasspath参数指定加载目录。启动类加载器无法被java程序直接引用。 扩展类加载器（Extension Class Loader）扩展类加载器负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录下的jar包，或者被java.ext.dirs指定的路径这种的所有类库。这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码实现的。 应用程序类加载器（Application Class Loader）负责加载用户类路径上的所有类库。这个类加载器是在sun.misc.Launcher$AppClassLoader实现。 定制自己的类加载器123456789101112131415161718192021222324252627282930313233public class CustomClassLoader extends ClassLoader &#123; public CustomClassLoader(ClassLoader parent) &#123; super(parent); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String path = \"/classes/\"; try &#123; InputStream ins = new FileInputStream(path + name.replace(\".\", File.separator) + \".class\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; byte[] classData = baos.toByteArray(); return defineClass(name, classData, 0, classData.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] args) throws Exception &#123; CustomClassLoader classLoader = new CustomClassLoader(null); Class clazz = classLoader.loadClass(\"com.*.ClassLoader\"); System.out.println(clazz.getClassLoader()); System.out.println(clazz.getClass()); &#125;","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://www.hessentec.top/tags/ClassLoader/"},{"name":"类加载机制","slug":"类加载机制","permalink":"https://www.hessentec.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"}]},{"title":"类文件结构","slug":"类文件结构","date":"2020-05-29T06:44:50.000Z","updated":"2020-06-04T00:26:39.602Z","comments":true,"path":"2020/05/29/类文件结构/","link":"","permalink":"https://www.hessentec.top/2020/05/29/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"Java虚拟机规范规定Class文件格式统一采用一种类似于C语言结构体的伪结构体来存储数据，这种伪结构体存储两种数据类型：无符号数和表。 无符号数：属于基本的数据类型，以u1、u2、u4、u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码结构构成的字符串值。 表：由多个无符号数或者其他表作为数据项构成的符合数据类型，所以表都习惯性地以_info结尾。表用于描述有层次关系的符合结构的数据，整个Class文件就是一张表，由下表中数据项构成。 类型 名称 个数 u4 Magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flag 1 u2 this_class 1 u2 super_class 1 u2 interface_count 1 u2 interfaces interface_count u2 fields_count 1 field_info fields fields_count u2 method_count 1 method_info methods methods_count u2 attributes_count 1 attribute_info attributes attributes_count 魔数每个Class文件的头四个字节称为魔数，其值的16进制表示为0xCAFEBABE（换算为二进制为1100 1010 1111 1110 1011 1010 1011 1110），虚拟机在加载类时分析该文件是否为Class文件。 版本号第5、6个字节表示次版本号。第7、8个字节表示主版本号。高版本的JDK能够向下兼容低版本的Class文件，虚拟机会拒绝执行超过其版本的Class文件。 常量池常量池中存放两大类常量： 字面量常量：比较接近Java语言层面的常量概念，比如字符串和被声明为final的常量值。对于范围在-127～128之间的包装类型也是常量。 符号引用常量：属于编译原理方面的概念，包含 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 常量池的大小不固定，用两个字节表示，第零项空出来，为了满足某些指向常量池的索引值的数据“不引用任何一个常量池项目”。 常量池的每一项常量都是一个表，这个表的第一位都是一个u1类型的标识位。 下面是常量池中的14种项目类型： 下面是常量池中的14种项目类型的结构表： 常量池中数据项类型 类型标志 类型描述 CONSTANT_Utf8 1 UTF-8编码的Unicode字符串 CONSTANT_Integer 3 int类型字面值 CONSTANT_Float 4 float类型字面值 CONSTANT_Long 5 long类型字面值 CONSTANT_Double 6 double类型字面值 CONSTANT_Class 7 对一个类或接口的符号引用 CONSTANT_String 8 String类型字面值 CONSTANT_Fieldref 9 对一个字段的符号引用 CONSTANT_Methodref 10 对一个类中声明的方法的符号引用 CONSTANT_InterfaceMethodref 11 对一个接口中声明的方法的符号引用 CONSTANT_NameAndType 12 对一个字段或方法的部分符号引用 访问标志访问标志标示了当前类的修饰符，比如 public / final / super / interface / enum / abstract / annotation / synthetic 标志名称 标志值 含义 ACC_PUBLIC 0x00 01 是否为Public类型 ACC_FINAL 0x00 10 是否被声明为final，只有类可以设置 ACC_SUPER 0x00 20 是否允许使用invokespecial字节码指令的新语义． ACC_INTERFACE 0x02 00 标志这是一个接口 ACC_ABSTRACT 0x04 00 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 ACC_SYNTHETIC 0x10 00 标志这个类并非由用户代码产生 ACC_ANNOTATION 0x20 00 标志这是一个注解 ACC_ENUM ０x40 00 标志这是一个枚举 类索引、父类索引、接口索引集合 类索引：this_class, 用于确定这个类的全限定名 父类索引：super_class, 父类索引用于确定这个类的父类的全限定名 接口索引集合：interfaces, 用于描述这个类实现了哪些接口 字段表集合字段表集合（field_info）用于描述接口或者类中声明的变量，包含类变量和实例变量，但不包含方法内部声明的局部变量。 |类型|名称|数量||—-|—-|—-|—-||u2 |access_flag|1|访问修饰符||u2 |name_index | 1| 字段的简单名称,如String str = “123”, str就是简单名称||u2 |descritpor_index|1| 字段或者方法的描述符||u2 |attributes_count |1 | ||attribute_info | attributes | attributes_count| | 访问修饰符 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为public ACC_PRIVATE 0x0002 字段是否为private ACC_PROTECTED 0x0004 字段是否为protected ACC_STATIC 0x0008 字段是否为static ACC_FINAL 0x0010 字段是否为final ACC_VOLATILE 0x0040 字段是否为volatile ACC_TRANSTENT 0x0080 字段是否为transient ACC_SYNCHETIC 0x1000 字段是否为由编译器自动产生 ACC_ENUM 0x4000 字段是否为enum 描述符：描述符的作用是用来描述字段的数据类型、方法的参数列表（数量、类型、顺序）和返回值。根据描述符的规则：基本数据类型以及代表无返回值的void类型都用一个大写的字符来表示;而对象类型则用字符L加对象的全限定名来描述; 标志符号 含义 B byte C char D double F float I int J long S short Z boolean V void 按照先参数列表后返回值的顺序描述，参数列表按照顺序放在”()”内部，String toString()描述为V()java.lang.String L 对象类型 [ 数组类型 [I: 代表int[], [[I:代表int[][] 方法表集合Class 文件中对方法的描述和对字段的描述完全是一致的， 方法表中的结构和字段表中的接口一样。 因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有ACC_VOLATILE和ACC_TRANSIENT。 但是增加了synchronized,native,abstract,strictfp(strict float point, 精确的浮点数)关键字的修饰符。对于方法里的代码，经过编译器变异常字节码指令后，存放在方法属性表中一个名为code的属性里。 标志名称 标志值 含义 ACC_PUBLIC 0x00 01 方法是否为public ACC_PRIVATE 0x00 02 方法是否为private ACC_PROTECTED 0x00 04 方法是否为protected ACC_STATIC 0x00 08 方法是否为static ACC_FINAL 0x00 10 方法是否为final ACC_SYHCHRONRIZED 0x00 20 方法是否为synchronized ACC_BRIDGE 0x00 40 方法是否是有编译器产生的方法 ACC_VARARGS 0x00 80 方法是否接受参数 ACC_NATIVE 0x01 00 方法是否为native ACC_ABSTRACT 0x04 00 方法是否为abstract ACC_STRICTFP 0x08 00 方法是否为strictfp （strict-float-point,精准的浮点数） ACC_SYNTHETIC 0x10 00 方法是否是有编译器自动产生的 属性表集合在Class文件、字段表、方法表中都可以携带自己的属性表集合（attribute_info）,用于描述某些场景的专有信息。 不强制要求各属性表的顺序，只要不与已有属性表重名即可。任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机在运行时会忽略不认识的属性。 属性名称 使用位置 含义 Code 方法表 Java代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量池 Deprecated 类，方法，字段表 被声明为deprecated的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClass 类文件 内部类列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 StackMapTable Code属性 JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 Signature 类，方法表，字段表 用于支持泛型情况下的方法签名 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 用于存储额外的调试信息 Synthetic 类，方法表，字段表 标志方法或字段为编译器自动生成的 LocalVariableTypeTable 类 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类，方法表，字段表 为动态注解提供支持 RuntimeInvisibleAnnotations 表，方法表，字段表 用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotation 方法表 作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法 RuntimeInvisibleParameterAnnotation 方法表 作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数 AnnotationDefault 方法表 用于记录注解类元素的默认值 BootstrapMethods 类文件 用于保存invokeddynamic指令引用的引导方式限定符 对于看了文章还有点懵的同学，看这里的视频讲解，忽略广告。《全网最牛JVM字节码结构分析、Class类文件核心结构》。","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"Class结构","slug":"Class结构","permalink":"https://www.hessentec.top/tags/Class%E7%BB%93%E6%9E%84/"}]},{"title":"Java虚拟机","slug":"Java虚拟机","date":"2020-05-28T12:59:14.000Z","updated":"2020-06-24T14:18:39.296Z","comments":true,"path":"2020/05/28/Java虚拟机/","link":"","permalink":"https://www.hessentec.top/2020/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"","text":"注：本系列为《深入理解Java虚拟机》的读书笔记。少量来源于网络，视频教材。 如何设计一个虚拟机假设自己要写一个虚拟机，应该考虑什么？ 12345虚拟机要运行什么？如何把规范的文件内容读取到内存中？读取到内存中的数据如何存储？如何执行这些规范文件中的数据翻译成操作系统认识的指令？执行完成后如何清理？ 虚拟机的主要功能以及组成虚拟机要运行代码，这些代码要定制一个规范，这样虚拟机才可以根据制定好的规范去解析和执行。对于Java虚拟机来讲，它要读取的文件就是Class类文件。我们需要一段代码把Class类文件内容读取到内存中，同时要注意判断，读取的文件内容是否符合Class类文件的规范，同时文件内容是否会危害到虚拟机。把文件内容读取到内存中后，如何存放、方便管理和使用，同时要保证性能、安全性。把这些文件内容“翻译”为操作系统认识的指令，并且操控这些指令按照预定的“规则”运行，达到可预期的结果。为了提升效率需要考虑多线程和并发。执行完成后，清理不需要的内存空间，以便其他程序使用(JVM规范中并没有规定垃圾回收部分)。 JVM虚拟机不包含ClassLoader部分 虚拟机相关知识传送门 类文件结构 类加载器和类加载机制 JVM运行时数据区域 字节码执行引擎 JVM 内存模型 线程和并发 内存分配与回收 编译与编译优化技术 常用监控与故障处理工具 常用的JVM参数 扩展阅读：深入理解Java虚拟机到底是什么 Java虚拟机是一种抽象的计算机，它模拟了一套自己的硬件体系结构（处理器、堆栈、指令集和寄存器）。不同的平台有着不同的实现版本，屏蔽了平台的差异性。使得不同平台上的虚拟机可以运行被javac编译的同一份.class文件。 关于JVM的面试题：24个Jvm面试题总结及答案常见JVM面试题及答案整理2020年JVM面试题吐血整理【过年必看】总结的JVM面试题面试必问的JVM应该怎么学（面试题含答案）大厂面试经：高频率JVM面试问题整理！2019年JVM面试都问了什么？快看看这22道面试题！（附答案解析）JVM 面试题 68 问，面试又可以多扯一个小时了！【搞定Jvm面试】 Java 内存区域揭秘附常见面试题解析","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"}]},{"title":"sublime快捷键","slug":"sublime快捷键","date":"2019-05-29T10:38:27.000Z","updated":"2020-06-04T00:26:39.598Z","comments":true,"path":"2019/05/29/sublime快捷键/","link":"","permalink":"https://www.hessentec.top/2019/05/29/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Editcmd + [ | Left Indentcmd + ] | Right Indentcmd + ctrl + up | Swap line upcmd + ctrl + down | swap line downcmd + shift + d | Duplicate linecmd + J | Jone Lines.cmd + Left | Beginning Of Linecmd + Right | End of Linecmd + ctrl + / | Toggle comment blockctrl + K | Delete To End.ctrl + shift + K | Delete Linectrl + T | swap words.cmd + shift + Enter | Insert line beforecmd + Enter | insert line aftercmd + option + T | Special charactersctrl + D | delete word after Selectioncmd + D | Expand selection to words.ctrl + cmd + G | Expand all selection to wordscmd + L | expand selection to lineEsc | Single selection , cancle multiple selection.ctrl + shift + up | add previous linectrl + shift + down | add next line.cmd + shift + L | 将选中的区域分割成多行选中状态(多光标操作状态)|Split into linesoption + mouse | 多重光标选中cmd + shift + J | 已缩进层级为依据，一层层向外选中|Expand selection to indentation.ctrl + shift + M 将匹配括号中的内容选中|。 Findcmd + F | findcmd + G | find nextcmd + shift + F | find in filescmd + shift + E | 缓存用于替换的内容，方便之后的替换cmd + E | 缓存用于查找的内容，方便之后的查找。cmd + option + E | replace Next Go Tocmd + P | go to Anythingcmd + R | go to Symbolcmd + G | Go to line.ctrl + M | jump to matching bracket()cmd + F2 | Toggle bookmarkF2. | Jump to Next bookmark.cmd + shift + F2 | clear all bookmarks.cmd + option + right | Next File","categories":[{"name":"生产力","slug":"生产力","permalink":"https://www.hessentec.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"sublime快捷键","slug":"生产力/sublime快捷键","permalink":"https://www.hessentec.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"tags":[{"name":"生产力","slug":"生产力","permalink":"https://www.hessentec.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"sublime","slug":"sublime","permalink":"https://www.hessentec.top/tags/sublime/"},{"name":"快捷键","slug":"快捷键","permalink":"https://www.hessentec.top/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"Linux命令-交集、并集、差集","slug":"Linux命令-交集、并集、差集","date":"2019-05-29T10:23:15.000Z","updated":"2020-06-04T00:26:39.589Z","comments":true,"path":"2019/05/29/Linux命令-交集、并集、差集/","link":"","permalink":"https://www.hessentec.top/2019/05/29/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/","excerpt":"","text":"Linux 命令 两个文件比对，求交集，并集，差集。 a.txt1234567aaaaabbbbbcccccdddddeeeeefffffggggg b.txt12345678aaaaaccccceeeeegggggiiiiijjjjjkkkkklllll 方法1: sort交集： $sort a.txt b.txt | uniq -d 1234aaaaaccccceeeeeggggg 并集： sort a.txt b.txt | uniq 1234567891011aaaaabbbbbcccccdddddeeeeefffffgggggiiiiijjjjjkkkkklllll 差集： sort a.txt b.txt b.txt | uniq -u 123bbbbbdddddfffff 说明： sort 先给文件排序。-d 显示次数大于一次的行-u 显示次数仅为一次的行 方法2: comm comm a.txt b.txt 1234567891011 aaaaabbbbb cccccddddd eeeeefffff ggggg iiiii jjjjj kkkkk lllll 显示三列：第一列：a中有，b没有。a差b comm -2 -3 a.txt b.txt第二列：a没有，b有。 b差a comm -1 -3 a.txt b.txt第三列：ab都有 a交b comm -1 -2 a.txt b.txt 大小写互转注意： 以下命令Mac OS无效 sed ‘s/[a-z]/\\u&amp;/g’sed ‘s/[A-Z]/\\l&amp;/g’ 拆解每一行中固定关键字的列sed ‘s/.(action=[a-zA-Z]{1,}).(cmd=[_a-zA-Z-]{1,})./\\1 \\2/‘注意：在次数匹配时：1）圆括号必须转义2）花括号必须转义","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.hessentec.top/categories/Linux/"},{"name":"Linux命令 - 交集、并集、差集","slug":"Linux/Linux命令-交集、并集、差集","permalink":"https://www.hessentec.top/categories/Linux/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.hessentec.top/tags/Linux/"},{"name":"comm","slug":"comm","permalink":"https://www.hessentec.top/tags/comm/"},{"name":"sort","slug":"sort","permalink":"https://www.hessentec.top/tags/sort/"}]},{"title":"VIM命令整理","slug":"VIM命令整理","date":"2019-05-29T10:13:01.000Z","updated":"2020-05-29T10:20:38.174Z","comments":true,"path":"2019/05/29/VIM命令整理/","link":"","permalink":"https://www.hessentec.top/2019/05/29/VIM%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/","excerpt":"","text":"Alive12345678I: Insert ModeEsc: Nomal ModeQ : Quite With Out Save.WQ : Write And QuiteHJKL: Left Down Up Right.X: Cut CharacterDD: Delete LineP: Pesta Character Felling Better123456789101112a: 在光标后插入o: 在当前行后插入一个新行O: 在当前行前插入一个新行cw: 删除从光标所在位置后到一个单词结尾的字符 c2w, c3w.Moving0 &#x2F; ^ 光标移动到行首（不是blank的位置）$ &#x2F; g_ 光标移动到行尾（不是blank的位置）&#x2F;pattern 定位到pattern的区域Pestap: pestau : undoctrl+r : redo Better,Faster,Stronger12345678910112d : delete two lines.100idesu[Esc]: insert 100 times desu.4p : pesta 4 times.% : swap &#123;&#125;#&#x2F;* : 向上／下搜索当前光标所在的单词0y$ ：移动到行首，开始copy，一直到本行最后一个字符。d: delete and copyv: select and copygU: 变大写 and copygu: 变小写 And copy 块操作1234^ -&gt; 到开头Ctrl-v -&gt; 开始块操作Ctrl-d -&gt; 向下移动I– [Esc]-&gt; 插入– vim超能力123456789在当前行移动光标：0: 到行首^: 到本行的第一个非blank字符$: 到行尾g_：到本行最后一个非blank字符fa：到下一个为a的字符处， fs到下一个为s的字符处t，；到逗号前的第一个字符，ta到a前的第一个字符3fa：当前行查找第三个出现的adt，：删除多有的内容，一直到逗号出现。 区域选择12345678910a 和 iaction 可以是任何命令，d：delete， y：copy， v：view modeobject 可以是：w：word， s：statement， p：paragraph，也可以是特殊的字符。例如字符串：(map (+) (&quot;foo&quot;)),光标在o上。vi” : foova” : “foo”vi) : “foo”va) : (“foo”)v2i): map (+) (“foo”)v2a): (map (+) (“foo”)) 可视化选择12345######缩进######使用v／V进入可视化模式J ： 把所有的行链接起来变成一行&lt;&#x2F;&gt;：左右缩进&#x3D; ：自动缩进 12345######行后追加######ctrl+v ： 进入可视化编辑模式选中相应的行（j或者ctrl+d 或者／pattern 或者%）$到行最后A(append,在行尾追加)， 输入字符串， 按ESC","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.hessentec.top/categories/Linux/"},{"name":"VIM","slug":"Linux/VIM","permalink":"https://www.hessentec.top/categories/Linux/VIM/"}],"tags":[]}],"categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Mysql","slug":"Java技术栈/Mysql","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Mysql/"},{"name":"Java","slug":"Java技术栈/Java","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java/"},{"name":"数据库","slug":"Java技术栈/数据库","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Spring","slug":"Java技术栈/Spring","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Spring/"},{"name":"Reids","slug":"Java技术栈/Reids","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Reids/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"设计模式/结构型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"设计模式/行为型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"设计模式/创建型模式","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"分布式","slug":"分布式","permalink":"https://www.hessentec.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"ID生成器","slug":"分布式/ID生成器","permalink":"https://www.hessentec.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ID%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"Redis","slug":"Redis","permalink":"https://www.hessentec.top/categories/Redis/"},{"name":"集群部署","slug":"Redis/集群部署","permalink":"https://www.hessentec.top/categories/Redis/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"name":"设计原则","slug":"设计模式/设计原则","permalink":"https://www.hessentec.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"Java虚拟机","slug":"Java技术栈/Java虚拟机","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hessentec.top/categories/Linux/"},{"name":"VIM","slug":"Linux/VIM","permalink":"https://www.hessentec.top/categories/Linux/VIM/"},{"name":"Etcd","slug":"Java技术栈/Etcd","permalink":"https://www.hessentec.top/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/Etcd/"},{"name":"生产力","slug":"生产力","permalink":"https://www.hessentec.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"sublime快捷键","slug":"生产力/sublime快捷键","permalink":"https://www.hessentec.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/sublime%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Linux命令 - 交集、并集、差集","slug":"Linux/Linux命令-交集、并集、差集","permalink":"https://www.hessentec.top/categories/Linux/Linux%E5%91%BD%E4%BB%A4-%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.hessentec.top/tags/Mysql/"},{"name":"Java","slug":"Java","permalink":"https://www.hessentec.top/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://www.hessentec.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://www.hessentec.top/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://www.hessentec.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"Spring","slug":"Spring","permalink":"https://www.hessentec.top/tags/Spring/"},{"name":"资源管理","slug":"资源管理","permalink":"https://www.hessentec.top/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"},{"name":"生命周期","slug":"生命周期","permalink":"https://www.hessentec.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"作用域","slug":"作用域","permalink":"https://www.hessentec.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"依赖处理","slug":"依赖处理","permalink":"https://www.hessentec.top/tags/%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/"},{"name":"Spring-BeanFactory","slug":"Spring-BeanFactory","permalink":"https://www.hessentec.top/tags/Spring-BeanFactory/"},{"name":"依赖注入","slug":"依赖注入","permalink":"https://www.hessentec.top/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"name":"依赖查找","slug":"依赖查找","permalink":"https://www.hessentec.top/tags/%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/"},{"name":"Spring-Bean","slug":"Spring-Bean","permalink":"https://www.hessentec.top/tags/Spring-Bean/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://www.hessentec.top/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"享元模式","slug":"享元模式","permalink":"https://www.hessentec.top/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"name":"外观模式","slug":"外观模式","permalink":"https://www.hessentec.top/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"name":"适配器模式","slug":"适配器模式","permalink":"https://www.hessentec.top/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"桥接模式","slug":"桥接模式","permalink":"https://www.hessentec.top/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"https://www.hessentec.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://www.hessentec.top/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://www.hessentec.top/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"IOC","slug":"IOC","permalink":"https://www.hessentec.top/tags/IOC/"},{"name":"DI","slug":"DI","permalink":"https://www.hessentec.top/tags/DI/"},{"name":"中介者模式","slug":"中介者模式","permalink":"https://www.hessentec.top/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"解释器模式","slug":"解释器模式","permalink":"https://www.hessentec.top/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"责任链模式","slug":"责任链模式","permalink":"https://www.hessentec.top/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"name":"模版方法模式","slug":"模版方法模式","permalink":"https://www.hessentec.top/tags/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"https://www.hessentec.top/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"组合模式","slug":"组合模式","permalink":"https://www.hessentec.top/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"name":"访问者模式","slug":"访问者模式","permalink":"https://www.hessentec.top/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"状态模式","slug":"状态模式","permalink":"https://www.hessentec.top/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","permalink":"https://www.hessentec.top/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.hessentec.top/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"对象池模式","slug":"对象池模式","permalink":"https://www.hessentec.top/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://www.hessentec.top/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"建造者模式","slug":"建造者模式","permalink":"https://www.hessentec.top/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"抽象工厂模式","slug":"抽象工厂模式","permalink":"https://www.hessentec.top/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"https://www.hessentec.top/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://www.hessentec.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"设计原则","slug":"设计原则","permalink":"https://www.hessentec.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"name":"JVM","slug":"JVM","permalink":"https://www.hessentec.top/tags/JVM/"},{"name":"调优","slug":"调优","permalink":"https://www.hessentec.top/tags/%E8%B0%83%E4%BC%98/"},{"name":"参数","slug":"参数","permalink":"https://www.hessentec.top/tags/%E5%8F%82%E6%95%B0/"},{"name":"常用工具","slug":"常用工具","permalink":"https://www.hessentec.top/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"故障排查","slug":"故障排查","permalink":"https://www.hessentec.top/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"},{"name":"linux","slug":"linux","permalink":"https://www.hessentec.top/tags/linux/"},{"name":"swap","slug":"swap","permalink":"https://www.hessentec.top/tags/swap/"},{"name":"编译","slug":"编译","permalink":"https://www.hessentec.top/tags/%E7%BC%96%E8%AF%91/"},{"name":"优化","slug":"优化","permalink":"https://www.hessentec.top/tags/%E4%BC%98%E5%8C%96/"},{"name":"内存分配","slug":"内存分配","permalink":"https://www.hessentec.top/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"GC","slug":"GC","permalink":"https://www.hessentec.top/tags/GC/"},{"name":"字节码执行引擎","slug":"字节码执行引擎","permalink":"https://www.hessentec.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"name":"Etcd","slug":"Etcd","permalink":"https://www.hessentec.top/tags/Etcd/"},{"name":"运行时区域","slug":"运行时区域","permalink":"https://www.hessentec.top/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F/"},{"name":"JMM","slug":"JMM","permalink":"https://www.hessentec.top/tags/JMM/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://www.hessentec.top/tags/ClassLoader/"},{"name":"类加载机制","slug":"类加载机制","permalink":"https://www.hessentec.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"name":"Class结构","slug":"Class结构","permalink":"https://www.hessentec.top/tags/Class%E7%BB%93%E6%9E%84/"},{"name":"生产力","slug":"生产力","permalink":"https://www.hessentec.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"sublime","slug":"sublime","permalink":"https://www.hessentec.top/tags/sublime/"},{"name":"快捷键","slug":"快捷键","permalink":"https://www.hessentec.top/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hessentec.top/tags/Linux/"},{"name":"comm","slug":"comm","permalink":"https://www.hessentec.top/tags/comm/"},{"name":"sort","slug":"sort","permalink":"https://www.hessentec.top/tags/sort/"}]}